<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Programming Basics Continuation Course, Spring 2012</title>
    <link rel="stylesheet" href="stylesheets/common.css" type="text/css" media="screen, print" />
    <link rel="stylesheet" href="stylesheets/menu.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
    <link rel="stylesheet" href="stylesheets/exercises.css" type="text/css" media="screen, print" />

    <script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>

    <script type="text/javascript" src="javascripts/exercises-test.js"></script>
    <script type="text/javascript" src="javascripts/common-new.js"></script>

    <script type="text/javascript" src="javascripts/jquery.easing.js"></script>
    <script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
    <script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
</head>
<body>
    <h1>Advanced programming course</h1>

    <p>Arto Vihavainen and Matti Luukkainen</p>

    <div id="toc" class="menu" data-first-chapter-index="1" data-first-exercise-index="109">
      <div id="materiaali_toc"></div>
      <div id="tehtavat_toc"></div>
    </div>

    <p><strong><big>Note for the reader</big></strong></p>

    <p>This is direct continuation to the programming basics course <a href="../ohpe/index.html">material</a>.</p>

    <p>This material is meant for the Helsinki University Department of Computer Science fall 2012 programming basics and advanced programming course. The material is based on springs of 2012, 2011, and 2010 course materials, of which content has been affected by Matti Paksula, Antti Laaksonen, Pekka Mikkola, Juhana Laurinharju, Martin PÃ¤rtel, Joel Kaasinen  and Mikael Nousiainen.</p>

    <p>Read the material so that you do all of the examples you read yourself. It's worth making small changes to the examples and observe how the changes affect the program. At first you might think that doing the examples yourself and editing them too would slow down your learning. However, this isn't true at all. As far as we know, no one has yet learned to program by just reading (or by just listening to a lecture). Learning is based substantially on actively doing and growing a routine. The examples, and especially doing your own experiments, are one of the best ways to truly internalize the read text.</p>

    <p>Try to do assignments, or at least to try them out as you read the text. If you can't get an assignment pass right off the bat, don't get depressed, since you'll be always able to get help with the assignment at the workshop.</p>

    <p>The text isn't meant to be just read once. You'll most certainly have to return to parts you've already read, or to assignments you've already done. This text doesn't contain everything essential related to programming. As a matter of fact, no book exists that would have everything essential. So you will in every case - on your programming career - have to find information on your own. The excersises of the course already hold some instructions on how and where you'd be able to find useful information.</p>

    <p>To some parts we've also attached screencasts; by watching the videos you'll be able to see how the code is written instead of just reading ready-made code.</p>

    <p></p>

    <p>The course picks up where the programming basics left off, and everything learned in the programming basics course is now assumed to be known. It's a good idea to go and check the <a href="../ohpe/index.html">material</a> of the programming basics course.</p>


    <p><em>Note!</em> On this course we use a programming environment known as <a href="http://netbeans.org/">NetBeans</a>. The instructions for using NetBeans and the assignment server can be found <a href="netbeans.html">here</a>.</p>

<div class="tyhja"></div>

<div class="viikkoraja">Week 1</div>



<h2>Recapping the programming basics</h2>

    <p>In this chapter we briefly recap a few concepts we became familiar with in the programming basics. You can familiarize yourself with the programming basics course material <a href="../ohpe/index.html">here</a>.</p>

    <p>Rusty programming skills can also be refreshed with the help of the excersises found <a href="http://www.cs.helsinki.fi/group/java/s12/ohpe/materiaali-ohpekertaus.html">here</a>.</p>

    <h3>Program, commands and variables</h3>

    <p>A computer program consists of a series of commands that a computer runs one at a time, from top to bottom. The commands always have a predefined structure and semantics. In Java - the programming language we use on the course - the commands are read from top to down, left to right. Programming courses are traditionally started by introducing a program that prints the string <code>Hello World!</code>. Below is a command written in Java that prints the <code>Hello World!</code> string.</p>

<pre class="sh_java">
        System.out.println("Hello World!");
</pre>

    <p>In the command the method <code>println</code> - which belongs to the <code>System</code> class - gets called, which prints the string passed in to it as a parameter, and after that a linebreak. The method is given the string <code>Hello World!</code> as a parameter; consequently the program prints out <code>Hello World!</code> followed by a linebreak.</p>

    <p>Variables can be used as part of the functionality of the program. Below is a program which introduces the variable <code>length</code> of the integer type. The value 197 is set to this variable on the next line. After this the value <code>179</code> of the variable <code>length</code> is printed.</p>

<pre class="sh_java">
        int length;
        length = 179;
        System.out.println(length);
</pre>

    <p>The execution of the program above would happen one line at a time. First the line <code>int length;</code> is executed, in which the variable <code>length</code> is introduced. Next the line <code>length = 179;</code> is executed, in which we set the value <code>179</code> to the variable that was introduced on the previous line. After this the line <code>System.out.println(length);</code> is run, in which we call the print method we saw earlier. To this method we give the variable <code>length</code> as a parameter. The method prints the content - the value - of the variable <code>length</code>, which is <code>179</code>.</p>

    <p>In the program above we really wouldn't have to introduce the variable <code>length</code> on one line and then set it's value on the next. The introduction of a variable and setting it's value can be done on the same line.</p>

<pre class="sh_java">
        int length = 179;
</pre>

    <p>When executing the line above, the variable <code>length</code> is introduced and as it is introduced the value <code>179</code> is set to it.</p>

    <p>In reality all information within a computer is represented as a series of bits - ones and zeros. Variables are an abstraction offered by the programming language with which we can handle different values more easily. The variables are used to store values and to maintain the state of the program. In Java, we have the primitive variable types <code>int</code> (integer), <code>double</code> (floating-point), <code>boolean</code> (truth value), <code>char</code> (character), and the reference variable types <code>String</code> (character string), <code>ArrayList</code> (array), and all classes. We'll return to primitive data type variables and to reference type variables and their differences later.</p>


<h3>Comparing variables and reading input</h3>

    <p>The functionality of programs is built with the help of control structures. Control structures make different functions possible depending on the variables of the program. Below, an example of an <code>if - else if - else</code> control structure, in which a different function is made depending on result of the comparison. In the example a string <code>Accelerate</code> is printed if the value of the variable <code>speed</code> is smaller than 110, the string <code>Break</code> if the <code>speed</code> is greater than 120, and the string <code>Cruising</code> in other cases.</p>

<pre class="sh_java">
        int speed = 105;

        if (speed < 110) {
            System.out.println("Accelerate");
        } else if (speed > 120) {
            System.out.println("Break");
        } else {
            System.out.println("Cruising");
        }
</pre>

        <p>Because in the example above the value of the variable <code>speed</code> is 105, the program will always print the string <code>Accelerate</code>. Remember that the comparison of strings is done with the <code>equals</code> method that belongs to the string. Below is an example in which an object created from Java's <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a> class is used to read the input of a user. The program checks if the strings entered by the user are equal.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter the first string: ");
        String first = reader.nextLine();

        System.out.print("Enter the second string: ");
        String second = reader.nextLine();

        System.out.println();

        if (first.equals(second)) {
            System.out.println("The strings you entered are the same!");
        } else {
            System.out.println("The strings you entered weren't the same!");
        }
</pre>

        <p>The functionality of the program depends on the user's input. Below is an example; the red text is user input.</p>

<pre>
Enter the first string: <font color="red">carrot</font>
Enter the second string: <font color="red">lettuce</font>

The strings you entered weren't the same!
</pre>

<h3>Loops</h3>

        <p>Repetition is often required in programs. First we make a so-called while-true-break loop, which we run until the user inputs the string <code>password</code>. The statement <code>while(true)</code> begins the loop, which will then be repeated until it runs into the keyword <code>break</code>.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        while (true) {
            System.out.print("Enter password: ");
            String password = reader.nextLine();

            if (password.equals("password")) {
                break;
            }
        }

        System.out.println("Thanks!");
</pre>


<pre>
Enter password: <font color="red">carrot</font>
Enter password: <font color="red">password</font>
Thanks!
</pre>


        <p>You can also pass a comparison to a while loop instead of the boolean <code>true</code>. Below, the user input is printed so that there's stars above and below it.</p>

<pre class="sh_java">
        Scanner reader = new Scanner(System.in);

        System.out.print("Enter string: ");
        String characterString = reader.nextLine();

        int starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();

        System.out.println(characterString);

        starNumber = 0;
        while (starNumber &lt; characterString.length()) {
            System.out.print("*");
            starNumber = starNumber + 1;
        }
        System.out.println();
</pre>


<pre>
Enter string: <font color="red">carrot</font>
******
carrot
******
</pre>

        <p>The example above should make you feel a little bad inside. The bad feelings are hopefully because you see that the example violates the rules learned in the programming basics. The example has unneccessary repetition which should be removed with the help of methods.</p>

        <p>In addition to the while-loop we also have two versions of the for-loop at our disposal. The newer for-loop is used for going through lists.</p>

<pre class="sh_java">
        ArrayList&lt;String&gt; greets = new ArrayList&lt;String&gt;();
        greets.add("Hei");
        greets.add("Hallo");
        greets.add("Hi");

        for (String greet: greets) {
            System.out.println(greet);
        }
</pre>

<pre>
Hei
Hallo
Hi
</pre>

        <p>The more traditional for-loop is used in situations similiar to where you would use a while-loop. It can, for example, be used to go through arrays. In the following example all values in the array <code>values</code> will be multiplied by two and then finally printed using the newer for-loop.</p>

<pre class="sh_java">
        int[] values = new int[] {1, 2, 3, 4, 5, 6};

        for (int i = 0; i &lt; values.length; i++) {
            values[i] = values[i] * 2;
        }

        for (int value: values) {
            System.out.println(value);
        }
</pre>

<pre>
2
4
6
8
10
12
</pre>

        <p>The traditional for-loop is very useful in cases where we go through indices one at a time. The loop below will go through the characters of a character string one by one, and prints the character string <code>Hip!</code> every time we encounter the character <code>a</code>.</p>

<pre class="sh_java">
        String characterString = "saippuakauppias";
        for (int i = 0; i &lt; characterString.length(); i++) {
            if (characterString.charAt(i) == 'a') {
                System.out.println("Hip!");
            }
        }
</pre>

<pre>
Hip!
Hip!
Hip!
Hip!
</pre>

<h3>Methods</h3>

    <p>Methods are a way of chopping up the functionality of a program into smaller entities. All Java programs start their execution from the <code>main</code> program method, which is defined with the statement <code>public static void main(String[] args)</code>. The statement defines a static method - that is a method which belongs to the class - which receives a character string array as its parameter.</p>

    <p>The program defines methods to abstract the functionalities of the program. When programming, one should try to achieve a situation in which the program can be looked at from a <em>higher level</em>, in such a case the main method consists of calls to a group of self-defined, well-named methods. The methods then specify the functionality of the program and perhaps are based on calls to other methods.</p> 

    <p>Methods that are defined using the keyword <code>static</code> belong to the <em>class</em> that holds the method, and work as so-called support methods. The methods that are defined without the keyword <code>static</code> belong to the instances - <em>the objects</em> - created from the class and can modify the state of that individual object.</p>

    <p>A method always has a visibility modifier (public, visible to 'everyone', or private, only visible within its class), a return type (void, returns nothing) and a name. In the following code we create a method which belongs to a class, <code>public static void print(String characterString, int times)</code>. This method prints a character string the defined amount of times. This time we use the method <code>System.out.print</code>, which works just like <code>System.out.println</code>, but doesn't print a linebreak.</p>

<pre class="sh_java">
        public static void print(String characterString, int times) {
            for (int i = 0; i &lt; times; i++) {
                System.out.print(characterString);
            }
        }
</pre>

    <p>The method above prints the character string it receives as a parameter, the amount of times the integer - which was also passed in as a parameter - says.</p>

    <p>In the chapter on loops we noticed that the code had some nasty copy-paste stuff in it. With the help of methods, we can move the printing of stars to a separate method. We create a method <code>public static void printStars(int times)</code>, which prints the amount of stars it receives as a parameter. The method uses a <code>for</code> loop instead of a <code>while</code>.</p>

<pre class="sh_java">
        public static void printStars(int times) {
            for (int i = 0; i < kertaa; i++) {
                System.out.print("*");
            }
            System.out.println();
        }
</pre>

        <p>Metodia hyÃ¶dyntÃ¤essÃ¤ aiemmin kauhistusta aihettanut esimerkkimme nÃ¤yttÃ¤Ã¤ seuraavalta.</p>

<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);

        System.out.print("SyÃ¶tÃ¤ characterString: ");
        String characterString = reader.nextLine();

        printStars(characterString.length());
        System.out.println(characterString);
        printStars(characterString.length());
</pre>


<h3>Class</h3>

    <p>Methods can abstract a program up to a certain point, but as the program becomes larger it's sensible to chop down the program even further into smaller and more logical entities. With the help of classes, we can define higher level concepts of a program and functionalities related to those concepts. Every Java program requires a class in order to work, so the <code>Hello World!</code> example wouldn't work without the class definition. A class is defined with the keywords <code>public class nameOfTheClass</code>.</p>

<pre class="sh_java">
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
</pre>

    <p>In a program, classes are used to define concepts and functionalities related to those concepts. Objects can be created from a class which are the embodiments of the class. Every object belongs to a certain class has the same structure, but the variables belonging to the objects can be different. The methods of objects handle the state of the object, that is, the variables of the object.</p>

    <p>Let's inspect the class <code>Book</code> below; the class has the object variables name (String) and publishingYear (integer).</p>

<pre class="sh_java">
        public class Book {
            private String name;
            private int publishingYear;

            public Book(String name, int publishingYear) {
                this.name = name;
                this.publishingYear = publishingYear;
            }

            public String getName() {
                return this.name;
            }

            public int getPublishingYear() {
                return this.publishingYear;
            }
        }
</pre>

    <p>The definition in the beginning, <code>public class Book</code>, tells the name of the class. This is followed by the definitions of object variables. Object variables are variables which for each of the objects created from the class are their own -- the object variables of one object are unrelated to the state of the same variables of another object. It's usually appropriate to hide the object variables from the users of the class, to define the visibility modifier <em>private</em> for them. If the visibility modifier is set to <em>public</em>, the user of the object will be able to directly access the object variables.</p>

    <p>Objects are created from a class with a <em>constructor</em>. A constructor is a method that initializes an object (creates the variables belonging to the object) and executes the commands that are within the constructor. The constructor is always named the same as the class that has the constructor in it. In the constructor <code>public Book(String name, int publishingYear)</code> a new object is created from the class <code>Book</code> and it's variables are set to the values that were passed in as parameters.</p>

    <p>Two methods that handle the information in the object are also defined for the class above. The method <code>public String getName()</code> returns the name of the object in question. The method <code>public int getPublishingYear()</code> returns the publishing year of the object in question.</p>

    <h3>Object</h3>

    <p>Objects are created with the help of the constructor that is defined within a class. In the program code the costructor is called with the <code>new</code> command, which returns a reference to the new object. Objects are instances created from classes. Let's inspect a program that creates two different books, after which it prints the values returned by the <code>getName</code> methods beloning to the objects.</p>

<pre class="sh_java">
        Book senseAndSensibility = new Book("Sense and Sensibility", 1811);
        Book prideAndPrejudice = new Book("Pride and Prejudice", 1813);

        System.out.println(senseAndSensibility.getName());
        System.out.println(prideAndPrejudice.getName());
</pre>

<pre>
Sense and Sensibility
Pride and Prejudice
</pre>

    <p>So, each object has it's own internal state. The state is formed from object variables that belong to the object. Object variables can be both primitive type variables and reference type variables. If reference type variables belong to the objects, it is possible that other objects also refer to the same referenced objects! Let's visualize this with the bank example, in which there's accounts and persons.</p>

<pre class="sh_java">
        public class Account {
            private String accountID;
            private int balanceAsCents;

            public Account(String accountID) {
                this.accountID = accountID;
                this.balanceAsCents = 0;
            }

            public void deposit(int sum) {
                this.balanceAsCents += sum;
            }

            public int getBalanceAsCents() {
                return this.balanceAsCents;
            }

            // .. other methods related to an account
        }
</pre>

<pre class="sh_java">
        import java.util.ArrayList;

        public class Person {
            private String name;
            private ArrayList&lt;Account&gt; accounts;

            public Person(String name) {
                this.name = name;
                this.accounts = new ArrayList&lt;Account&gt;();
            }

            public void addAccount(Account account) {
                this.accounts.add(account);
            }

            public int moneyTotal() {
                int total = 0;
                for (Account account: this.accounts) {
                    total += account.getBalanceAsCents();
                }

                return total;
            }

            // ... other methods related to a person
        }
</pre>

    <p>Each object created from the <code>Person</code> class has it's own name and it's own list of accounts. Next, let's create two persons and two accounts. One of the accounts is owned by only one person and the other one is shared.</p>

<pre class="sh_java">
        Person matti = new Person("Matti");
        Person maija = new Person("Maija");

        Account salaryAccount = new Account("NORD-LOL");
        Account householdAccount = new Account("SAM-LOL");

        matti.addAccount(salaryAccount);
        matti.addAccount(householdAccount);
        maija.addAccount(householdAccount);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        salaryAccount.deposit(150000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();

        householdAccount.deposit(10000);

        System.out.println("Money on Matti's accounts: " + matti.moneyTotal());
        System.out.println("Money on Maija's accounts: " + maija.moneyTotal());
        System.out.println();
</pre>

<pre>
Money on Matti's accounts: 0
Money on Maija's accounts: 0

Money on Matti's accounts: 150000
Money on Maija's accounts: 0

Money on Matti's accounts: 160000
Money on Maija's accounts: 10000
</pre>

    <p>Initially, the accounts of both persons are empty. When money is added to the salaryAccount - which <code>matti</code> has a reference to - the amount of money on Matti's accounts grows. When money is added to the householdAccount <em>the amount of money each person has grows</em>. This is because both Matti and Maija have "access" to the householdAccount, so in each of the persons' object variable <code>accounts</code>, there's a reference to the householdAccount.</p>


<h3>The structure of a program</h3>

	<p>A program should be clear and easy to understand for both the original writer and others. The most important aspects of a clear program are class structure and good naming conventions. Each class should have a single, clearly defined responsibility. Methods are used to reduce repetition and to create a structure for the internal functionality of the class. A method should also have a clear responsibility to ensure it stays short and simple. Methods that do many things should be divided into smaller helper methods, which are called by the original method. A good programmer writes code that can be understood even weeks after it was originally written.</p>

	<p>Good, understandable code uses descriptive naming of variables, methods and classes, and consistent indentation. Let's look at the example below, a small program for buying and selling goods. Even though the only thing available is carrots, with no bookkeeping, the user interface could be extended to use a storage class to keep track of items.

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else if (command.equals("buy")) {
                String line = null;
                while(true) {
                    System.out.print("What to buy: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Bought!");
            } else if (command.equals("sell")) {
                String line = null;
                while(true) {
                    System.out.print("What to sell: ");
                    line = reader.nextLine();
                    if(line.equals("carrot")) {
                        break;
                    } else {
                        System.out.println("Item not found!");
                    }
                }

                System.out.println("Sold!");
            }
        }
    }
}
</pre>

	<p>This example has numerous problems. The first problem is the long <code>start</code> method. It can be shortened by moving most of the command handling to a separate method.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String line = null;
            while(true) {
                System.out.print("What to buy: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String line = null;
            while(true) {
                System.out.print("What to sell: ");
                line = reader.nextLine();
                if(line.equals("carrot")) {
                    break;
                } else {
                    System.out.println("Item not found!");
                }
            }

            System.out.println("Sold!");
        }
    }
}
</pre>

	<p><code>handleCommand</code> still has some repetition for reading the user input. Both buying and selling first print a character string with the question, then take input from the user. If the input is incorrect (other than "carrot"), "Item not found!" is printed. We will create a new method, <code>public String readInput(String question)</code>, to handle this. Note that if the program used some other object to keep track of inventory, we would compare user input to the inventory's contents instead.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            } else {
                handleCommand(command);
            }
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
</pre>

	<p>The program is now divided into appropriate parts. There are still a few things, other than implementing more methods, we can do to improve readability. The <code>start</code> method has an <code>if</code> branch that ends in <code>break</code>, which exits the loop. We can remove the unnecessary <code>else</code> branch, simply moving the <code>handleCommand</code> method to be called after the if statement. The program still works exactly as before, but the method is now shorter and easier to read. A similar situation exists in the <code>readInput</code> method, so we will clean it up too.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }
            
            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            String input = readInput("What to buy: ");
            System.out.println("Bought!");
        } else if (command.equals("sell")) {
            String input = readInput("What to sell: ");
            System.out.println("Sold!");
        }
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            }

            System.out.println("Item not found!");
        }
    }
}
</pre>


	<p>Dividing a program into smaller parts, like we did above, is called <em>refactoring</em>. It does not change how the program works, but the internal structure is changed to be more clear and easier to maintain. The current version is much more clear than the original one, but it can be improved further. For example, <code>handleCommand</code> can be further divided into two different methods, one for handling buying and the other for selling.</p>

<pre class="sh_java">
public class UserInterface {
    private Scanner reader;

    public UserInterface(Scanner reader) {
        this.reader = reader;
    }

    public void start() {
        while (true) {
            String command = reader.nextLine();

            if (command.equals("end")) {
                break;
            }
            
            handleCommand(command);
        }
    }

    public void handleCommand(String command) {
        if (command.equals("buy")) {
            commandBuy();
        } else if (command.equals("sell")) {
            commandSell();
        }
    }

    public void commandBuy() {
        String input = readInput("What to buy: ");
        System.out.println("Bought!");
    }

    public void commandSell() {
        String input = readInput("What to sell: ");
        System.out.println("Sold!");
    }

    public String readInput(String question) {
        while (true) {
            System.out.print(question);
            String line = reader.nextLine();

            if (line.equals("carrot")) {
                return line;
            } else {
                System.out.println("Item not found!");
            }
        }
    }
}
</pre>

	<p>The program now has a clear structure with descriptively named methods. Every method is short and has a small task to handle. Note that refactoring the code did not add any new functionality, it merely changed the way the program works internally.</p>

        <h3>Programming and the importance of practicing</h3>

	<p>As far as we know, nobody has yet learned programming by listening to lectures. To develop the skill required in programming, it is essential to practice both what you have learned earlier and things that are new to you. Programming can be compared to speaking languages or playing an instrument, both of which can only be learned by doing. Master violinists are probably not good at playing <em>only</em> because they practice a lot. Playing an instrument is fun, which makes one more motivated to practice. The same applies to programming.</p>

        <p>As Linus Torvalds said, <em>"Most good programmers do programming not because they expect to get paid or get adulation by the public, but because it is fun to program"</em>.</p>

	<p>Dr. Luukkainen has written a list of instructions for new programmers to follow when learning to program. Follow this advice to become a great programmer!</p>

        <ul>
          <li> Take small steps
            <ul>
	      <li> Divide the problem you are trying to solve into smaller parts and solve them <strong>one at a time</strong> </li>
              <li> Keep testing that your solution is moving in the right direction, ensuring that you have solved the current part correctly</li>
          </ul></li>
          <li> Keep the code as clean as you can
            <ul>
              <li> use proper indentation </li>
              <li> use descriptive names for variables, methods, classes, everything</li>
	      <li> keep all methods short, including <code>main</code> </li>
              <li> write methods that only do one thing </li>
              <li> <strong>remove all copy-paste code by refactoring (or don't copy and paste code in the first place!)</strong></li>
              <li> replace "bad" and unclear code with clean, easy to read code </li>
          </ul></li>
        </ul>



        <h3>Visibility</h3>

	<p>Until now, we have been using two different keywords to define the <em>visibility</em> of methods and instance variables. <code>public</code> makes the method or instance variable visible and accessable to everyone. Methods and constructors are usually marked as public, so that they can be called from outside the class.</p>

	<p>Declaring a method or instance variable <code>private</code> hides it from the outside, making it only accessible from inside the same class.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private String contents;

    public Book(String name, String contents) {
        this.name = name;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public String getContents() {
        return this.contents;
    }

    // ...
}
</pre>

	<p>The instance variables in the Book class above can only be accessed with the public methods <code>getName</code> and <code>getContents</code>. Fields declared as private are only accessible in code inside the class. Methods can also be declared as private, which prevents them from being called outside the class.</p>


        <p>Now it's time to start practicing!</p>

<div class="tehtavat" id="viikko7">

<NEXTWEEK></NEXTWEEK>

   <h3>Smileys</h3>

  <p>Create the support method <code>private static void printWithSmileys(String characterString)</code> for the class <code>Smileys</code> which comes with the assignment template. The method is to print the given character string surrounded with smileys. Use the character string <code>:)</code> as the smiley.</p>

<pre class="sh_java">
printWithSmileys("\\:D/");
</pre>

<pre>
:):):):):)
:) \:D/ :)
:):):):):)
</pre>

  <p>Note, that the character string must have \\ so we can print the symbol \.</p>

  <p><em>Note!</em> if the length of the character string is an odd number, add an extra space on the right side of the given character string.</p>

<pre class="sh_java">
printWithSmileys("\\:D/");
printWithSmileys("87.");
</pre>

<pre>
:):):):):)
:) \:D/ :)
:):):):):)
:):):):):)
:) 87.  :)
:):):):):)
</pre>

  <p>It's a good idea to first think how many smileys should be printed for a character string of a certain length. The length of a character string can be found out with the method <code>length</code> which belongs to it. A loop is helpful for printing the top and bottom smiley rows, the middle row can be handled with a normal print command. You can check if a length is an odd number with the help of a remainder <code>characterString.length() % 2 == 1</code>.</p>

<h3>character string changer</h3>

  <p>In this assignment we create a character string changer, which consists of two classes. The class <code>Changer</code> turns a single character to another one. The Changer holds a number of Changes and changes character strings with the help of Change objects it holds.</p>

  <h4>Change-class</h4>

  <p>Create a class <code>Change</code>, that has the following functionalities:</p>

  <ul>
    <li> constructor <code>public Change(char fromCharacter, char toCharacter)</code> that creates an object that makes changes from character <code>fromCharacter</code> to <code>toCharacter</code></li>
    <li> method <code>public String change(String characterString)</code> returns the changed version of the given character string</li>
  </ul>

  <p>The class is used in the following way:</p>

<pre class="sh_java">
  String word = "carrot";
  Change change1 = new Change('a', 'b');
  word = change1.change(word);

  System.out.println(word);

  Change Change2 = new Change('k', 'x');
  word = Change2.change(word);

  System.out.println(word);
</pre>

<p>The example above would print:</p>

<pre>
  porkkbnb
  porxxbnb
</pre>

<p><strong>Tip:</strong> you can handle replacing characters in two ways, either with the help of a method in the class <code>String</code> (look for it yourself!) or by going through the character string character by character while forming the changed character string.</p>

<p>If you don't use the ready-made method of String, it is good to remember that even though you compare character strings with the command <code>equals</code> you compare single characters with the == operator:</p>

<pre class="sh_java">
  String word = "carrot";

  String replacedA = ""; 
  for ( int i=0; i &lt; word.length(); i++) {
     char character = word.charAt(i);
     if ( character == 'a' ) {  
        replacedA += '*'
     }  else {
        replacedA += character;
     } 
  }

  System.out.println(replacedA);  // prints c*rrot
</pre>

<h4>Changer-class</h4>

  <p>Create the class <code>Changer</code>, with the following functions:</p>

  <ul>
    <li> constructor <code>public Changer()</code> creates a new changer</li>
    <li> method <code>public void addChange(Change change)</code> adds a new Change to the Changer</li>
    <li> method <code>public String change(String characterString)</code> executes all added Changes for the character string in the order of their adding and returns the changed character string</li>
  </ul>

  <p>The class is used in the following way:</p>

<pre class="sh_java">
  Changer scandiesAway = new Changer();
  scandiesPois.addChange(new Change('Ã¤', 'a'));
  scandiesPois.addChange(new Change('Ã¶', 'o'));
  System.out.println(scandiesAway.change("Ã¤Ã¤liÃ¶ Ã¤lÃ¤ lyÃ¶, Ã¶Ã¶liÃ¤ lÃ¤ikkyy"));
</pre>

  <p>The above example would print:</p>

<pre>
  aalio ala lyo, oolia laikkyy
</pre>

<p><strong>Tip:</strong> It's a good idea to store the Changes to a list object variable of Changer (in the same fashion as on the basics course we stored players to a team, phone numbers to a phone book or books to a library, for example) A Changer is executed so that the changes are done to the character string one at a time as in the following example:</p>

<pre class="sh_java">
    ArrayList&lt;Change&gt; changes = new ArrayList&lt;Change&gt;();

    changes.add( new Change('a', 'b') );
    changes.add( new Change('k', 'x') );
    changes.add( new Change('o', 'Ã¥') );

    String word = "carrot";

    for (Change Change : changes) {
        word = Change.change(word);
    }

    System.out.println(word);  // tulostuu pÃ¥rxxbnb
</pre>

<p><strong>REMINDER</strong> when you add an ArrayList, a Scanner or a Random, Java doesn't recognize the class unless you "import" it by adding the following lines to the beginning:</p>

<pre class="sh_java">
import java.util.ArrayList;    // imports ArrayList
import java.util.*;            // imports all tools from java.util, including ArrayList, Scanner ja Random
</pre>

<h3>Calculator</h3>

  <p>In this assignment, we make a similiar simple calculator that we already had in the material of programming basics' week 1. This time however, we pay attention to the structure of the program. Especially we will make the <em>main</em>-method (the main program) very light. The main program method doesn't actually do anything else than just start the program:</p>

<pre class="sh_java">
public class MainProgram {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        calculator.start();
    }
}
</pre>

  <p>What the main program here does is it just creates the object that implements the actual application logic and then starts it. This is the proper way of creating programs and from now on we'll try to achieve this structure.</p>

  <h4>Reader</h4>

  <p>In order to communicate with the user, the calculator needs a Scanner-object. As we've seen, reading integers with a Scanner is a little laborious. We now create a separate class <code>Reader</code> that encapsulates a Scanner-object.</p>

  <p>Implement the class <code>Reader</code> and add the following methods to it</p>

  <ul>
    <li><code>public String readString()</code></li>
    <li><code>public int readInteger()</code></li>
  </ul>

  <p>Within the Reader there should be a Scanner-object as an instance variable, which the methods use in the old familiar way we know from programming basics. Remember that when reading integers, it's good to first read the entire line and then turn that in to an integer. Here we can utilize the method <code>parseInt</code> of the <code>Integer</code>-class.</p>

  <h4>Application body</h4>

  <p>The calculator works like this:</p>

<pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
</pre>

  <p>Implement the class <code>Calculator</code> to take care of the application logic of your program, and for that class a method <code>public void start()</code> which looks exactly like this:</p>

<pre class="sh_java">
    public void start() {
        while (true) {
            System.out.print("command: ");
            String command = reader.readString();
            if (command.equals("end")) {
                break;
            }

            if (command.equals("sum")) {
                sum();
            } else if (command.equals("difference")) {
                difference();
            } else if (command.equals("product")) {
                product();
            }
        }

        statistics();
    }
</pre>

  <p>The calculator has the operations <code>sum, difference, product</code>.</p>

  <p>Finish the bodies for the methods <code>sum</code>, <code>difference</code>, <code>product</code> and <code>stasistics</code>. All of them are to be of the type <code>private void</code> which means that the methods are available only for internal use in the calculator.</p>

  <p>Add an instance variable of the type <code>Reader</code> for the calculator and create the reader in the constructor. <em>The calculator may not have a separate Scanner type variable!</em></p>

  <h4>Implementation of the application logic</h4>

  <p>Now implement the methods <code>sum</code>, <code>difference</code> and <code>product</code> so that they work according to the example above. In the example first a command is asked from the user and then two values, then the desired operation is executed and the value of the operation is printed. Notice that asking the user for the values happens within the methods <code>sum</code>, <code>difference</code> and <code>product</code>! The methods use the Reader-object to ask the values, so the body of the methods is as follows:</p>

<pre class="sh_java">
    private void sum() {
       System.out.print("value1: ");   
       int value1 = // read the value using the Reader-object
       System.out.print("value2: "); 
       int value2 = // read the value using the Reader-object
       // print the value according to the example above
    }
</pre>

<h4>Statistics</h4>

  <p>After the <code>while</code>-loop in the <code>start</code>-method, the method <code>statistics</code> is called. The method is meant to print the amount of operations done with the Calculator-object:</p>

<pre>
command: <font color="red">sum</font>
value1: <font color="red">4</font>
value2: <font color="red">6</font>
sum of the values 10

command: <font color="red">product</font>
luku1: <font color="red">3</font>
luku2: <font color="red">2</font>
product of the values 6

command: <font color="red">end</font>
Calculations done 2
</pre>

  <p>Implement the method <code>private void statistics()</code>, and make the required changes to the code of the Calculator-class in order to collect the statistics.</p>

  <p>Note: if an invalid command is given to the program (something other than sum, difference, product or end), the calculator will not react to the command in any way, but instead continues by asking the next command. Statistics is not to count an invalid command as a completed calculation.</p>

<pre>
command: <font color="red">integral</font>
command: <font color="red">difference</font>
value1: <font color="red">3</font>
value2: <font color="red">2</font>
difference of the values 1

command: <font color="red">end</font>
Calculations done 1
</pre>

<p><strong>Bonus assignment (not tested):</strong> Reading the user input is repeated in the same way in all three operation implementing methods. Remove the repetition from your code with the help of a support method. The method can return the two values asked from the user in an array, for example.</p>

</div>


<h2>Primitive and reference type variables</h2>

        <p>Java is a strongly typed language, what this means is that all of it's variables have a <em>type</em>. The types of the variables can be divided in to two categories: <strong>primitive type and reference type variables</strong>. Both types of variables have their own "slot", which holds the information belonging to them. Primitive type variables hold the concrete <em>value</em> in their slot, while the reference type variables hold a <em>reference</em> to a concrete <em>object</em>.</p>

        <h3>Primitive type variables</h3>

        <p>The value of a primitive type variable is saved in a slot created for the variable. Each primitive type variable has it's own slot and it's own value. A variable's slot is created when it is introduced (<code>int number;</code>, for example). A value is set to a slot with the assignment operation <code>=</code>. Below is an example of the introduction of a primitive type int (integer) variable and setting of it's value in the same expression.</p>

<pre class="sh_java">
int number = 42;
</pre>

        <p>Primtive type variables, among others, are <code>int</code>, <code>double</code>, <code>char</code>, <code>boolean</code> and more rarely used <code>short</code>, <code>float</code>, <code>byte</code> and <code>long</code>. Also <code>void</code> is a primitive type, but it doesn't have it's own slot or value. The void type is used when we want to express that a method doesn't return a value.</p>

    <p>Next we introduce two primitive type variables and set values to them.</p>

<pre class="sh_java">
int five = 5;
int six = 6;
</pre>

        <p>The primitive type variables introduced above are named <code>five</code> and <code>six</code>. When introducing the variable <code>five</code> the value 5 is set to the <em>slot</em> that was created for it (<code>int five = 5;</code>).  When introducing the variable <code>six</code> the value 6 is set to the <em>slot</em> that was created for it (<code>int six = 6;</code>). The variables <code>five</code> and <code>six</code> are both of the type <code>int</code>, or integers.</p>

        <p>Primitive type variables can be visualized as boxes that both have the values belonging to them saved in to them:</p>

        <p><img src="img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen.png" /></p>

        <p>Next lets inspect how the values of primitive type variables get copied.</p>

<pre class="sh_java">
int five = 5;
int six = 6;

five = six; // the variable 'five' now holds the value 6 - the value that was in the variable 'six'.
six = 64; // the variable 'six' now holds the value 64

// the variable 'five' still holds the value 6
</pre>

        <p>Above we introduce the variables <code>five</code> and <code>six</code> and we set values to them. After this the value held in the slot of the variable <code>six</code> is copied to the slot of the variable <code>five</code> (<code>five = six;</code>). If the value of the variable <code>six</code> is changed after this point the value in the variable <code>five</code> remains unaffected: the value of the variable <code>five</code> is in it's own slot and is not related to the value in the slot of the variable <code>six</code> in any way. The end situation as a picture.</p>

        <p><img src="img-ohja/vis/alkeis-vs-viittaus-vitonen-ja-kutonen-64.png" /></p>

        <h4>Primitive type variable as a method parameter and return value</h4>

        <p>When a primitive type variable is passed to a method as a parameter, the method parameter is set to the value in the given variable's slot. In practice, the method parameters also have own slots to which the value is copied like in an assignment expressions. Let us consider the following method <code>addToValue(int value, int amount)</code>.</p>

<pre class="sh_java">
public int addToValue(int value, int amount) {
    return value + amount;
}
</pre>

        <p>The method <code>addToValue</code> is given two parameters: <code>value</code> and <code>amount</code>. The method returns a new value, which is the sum of the given parameters. Let us investigate how the method is called.</p>

<pre class="sh_java">
int myValue = 10;
myValue = addToValue(myValue, 15);
// the variable 'myValue' now holds the value 25
</pre>

        <p>In the example, <code>addToValue</code> is called using the variable <code>myValue</code> and the value <code>15</code>. These are copied to the method parameters <code>value</code>, which will hold the value 10 (the contents of <code>myValue</code>), and <code>amount</code>, which wil hold the value 15. The method returns the sum of <code>value</code> and <code>amount</code>, which is equal to <code>10 + 15 = 25</code>.</p>

        <p>Note! In the previous example, the value of the variable <code>myValue</code> is changed only because it is assigned the return value of <code>addToValue</code> (<code>myValue = addToValue(myValue, 15);</code>). If the call to <code>addToValue</code> were as follows, the value of the variable <code>myValue</code> would remain unchanged.</p>

<pre class="sh_java">
int myValue = 10;
addToValue(myValue, 15);
// the variable 'myValue' still holds the value 10
</pre>

<h4>Minimum and maximum values</h4>

        <p>Each primitive data type can represent a specific range of values limited by its minimum and maximum value, which are the smallest and largest values representible by the type. This is because a predefined data size is used for the internal represetantion of the type in Java (and most other programming languages).</p>

        <p>The minimum and maximum values for a few Java primitive types are:</p>

        <p>
          <table cellspacing="5" >
            <tr><th>Data type</th><th>Description</th><th>Minimum value</th><th>Max value</th></tr>
            <tr><td>int</td><td>Integer</td><td>-2 147 483 648 (<code>Integer.MIN_VALUE</code>)</td><td>2 147 483 647 (<code>Integer.MAX_VALUE</code>)</td></tr>
            <tr><td>long</td><td>Long interger</td><td>-9 223 372 036 854 775 808 (<code>Long.MIN_VALUE</code>)</td><td>9 223 372 036 854 775 807 (<code>Long.MAX_VALUE</code>)</td></tr>
            <tr><td>boolean</td><td>Truth value</td><td colspan=2><code>true</code> or <code>false</code></td></tr>
            <tr><td>double</td><td>Floating point</td><td><code>Double.MIN_VALUE</code></td><td><code>Double.MAX_VALUE</code></td></tr>
          </table>
        </p>

        <p><strong>Rounding errors</strong></p>

        <p>When using floating point data types, it is important to keep in mind that floating point types are always an <em>approximation</em> of the actual value. Because floating point types use a predefined data size to represent the value similarly to all other primitive data types, we may observe quite surprising rounding errors. For example, consider the following case.</p>

<pre class="sh_java">
double a = 0.39;
double b = 0.35;
System.out.println(a - b);
</pre>

        <p>The example prints the value <code>0.040000000000000036</code>. Programming languages usually include tools to more accurately handle floating point numbers. In Java, for example, the class <em>BigDecimal</em> can be used to store infinitely long floating point numbers.</p>

        <p>When comparing floating point numbers, rounding errors are usually taken into account by comparing the distance between the values. For example, with the variables in the previous example, the expression <code>a - b == 0.04</code> does not produce the expected result due to a rounding error.</p>

<pre class="sh_java">
double a = 0.39;
double b = 0.35;

if((a - b) == 0.04) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
</pre>

<pre>
Failed comparison!
</pre>

        <p>One method to calculate the distance between two values is as follows. The helper function <code>Math.abs</code> returns the absolute value of the value passed to it.</p>

<pre class="sh_java">
double a = 0.39;
double b = 0.35;

double distance = 0.04 - (a - b);

if(Math.abs(distance) &lt; 0.0001) {
    System.out.println("Successful comparison!");
} else {
    System.out.println("Failed comparison!");
}
</pre>

<h3>Reference Type Variables</h3>

        <p>Reference type variables memorize the information which has been assigned to them "on the other end of the line". Reference type variables contain a reference to the location where the information is stored. Differently from primitive type variables, reference type variable do not have a limited scope because their value or <em>information</em> is stored at the referenced location. Another substantial difference between primitive type and reference type variables is that various different reference type variables can point to the same object.</p>

<!--
        <p>Reference type variables are objects which are created through the <code>new</code> keyword. The value of a reference type variable is still assigned using the operator <code>=</code>; however, the <code>new</code> operator creates an object and returns the reference to that object. The reference is stored within the variable, and it becomes its value.</p> 
-->

<p>Let us have a look at two reference type variables. In the following examples we make use of the class <em>Calculator</em>:</p>

<pre class="sh_java">
public class Calculator {
    private int value;

    public Laskuri(int originalValue) { // Contructor
        this.value = originalValue;
    }

    public void increaseValue() {
        this.value = this.value + 1;
    }

    public int getValue() {
        return value;
   }
}
</pre>

        <p>Main:</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);
</pre>

        <p>In the examples we first create a reference type variable called <code>bonusCalculator</code>. The <code>new</code> operator tells that we define storage space for the information to be assigned to the variable, then we execute the code which follows the <code>new</code> operator, and we return a referece to the object that has been so created. The reference which is returned is assigned to the <code>bonusCalculator</code> variable through the <code>=</code> equal sign. The same thing happens with the variable called <code>axeCalculator</code>. If we want to think about it with pictures, we can imagine a reference type variable as it were a box, the variable itself, with a line or an arrow, which starts at the box and points to an object. In fact, the variable does not contain the object, but it points to the object information. </p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit.png" /></p>

        <p>Next, let us have a look at how a referene type object is duplicated.</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                           // that is to say a reference to a Calculator type object which received the value 6 in its constructor is copied to the variable  bonusCalculator
</pre>

        <p>When we copy a reference type variable (see above <code>bonusCalculator =  axeCalculator;</code>), the reference to the variable duplicates, too. In this case, a reference to the <code>axeCalculator</code> variable slot is copied to the <code>bonusCalculator</code> variable slot. Now, both the objects point to the same place!</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-3.png" /></p>

        <p>Let us continue with the example above and let us set a new reference to the variable <code>axeCalculator</code>; this new reference will point to a new object created by the command <code>new Calculator(10)</code>.</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                           // that is to say a reference to a Calculator type object which received the value 6 in its constructor is copied to the variable 

axeCalculator = new Calculator(10); // a new reference is assigned to the axeCalculator variable 
                              // which points to the object created by the command new Laskuri(10)

// the bonusCalculator variable still contains a reference to the Calculator object which received value 6 in its parameter
</pre>

        <p>In these examples, we do the same operations which were shown in the assignment example in the primitive type variables section. In the very last example, we copied the reference of reference type variables, whereas in the primitive type variables section we copied the value of primitive type variables. In both cases, we copy the contents of a slot: the primitive type variable slot contains a value, whereas the reference type variable slot contains a reference.</p>

        <p>At the end of the previous example no variable points to the Calculator object which received value 5 in its constructor. Java's garbage collection deletes such useless objects from time to time. Our final situation looks like the following:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-2.png" /></p>

        <p>Let us have a look to a third example still, and let us focus on an essencial difference between primitive type and reference type variables.</p>

<pre class="sh_java">
Calculator bonusCalculator = new Calculator(5);
Calculator axeCalculator = new Calculator(6);

bonusCalculator = axeCalculator; // the reference contained by the variable axeCalculator is copied to the variable bonusCalculator
                           // that is to say a reference to a Calculator type object which received the value 6 in its constructor is copied to the variable 

axeCalculator.increaseValue(); // we increase by one the value of the object referenced by axeCalculator

System.out.println(bonusCalculator.getValue());
System.out.println(axeCalculator.getValue());
</pre>

<pre>
7
7
</pre>

        <p>Both <code>bonusCalculator</code>and <code>axeCalculator</code> point to the same object, after we have run the command <code>bonusCalculator = axeCalculator;</code>, and therefore, now they both have the same value 7, even though we have increased only one of them.</p>

        <p>The situation might be clear if we look at the following picture. The method <code>axeCalculator.increaseValue()</code> increases by one the <code>value</code> variable of the object pointing to the <code>axeCalculator</code> variable. Because <code>bonusCalculator</code> points to the same object, the method <code>bonusCalculator.getValue()</code> returns the same value which was increased by the method <code>axeCalculator.increaseValue()</code>.</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-4.png" /></p>

        <p>In the following example, three reference type variables all point to the same <code>Calculator</code> object.</p>

<pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;
</pre>

        <p>In the example, we create only one <code>Calculator</code> object, but all the three <code>Calculator</code> variables point to that same one. Therefore, <code>bonus</code>, <code>ihq</code>, and <code>lennon</code> method calls all modify the same object. To tell it once again: when reference type variables are copied, their references also duplicate. The same concept in a picture:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-5.png" /></p>

        <p>Let us focus again on duplication with one example.</p>

<pre class="sh_java">
Calculator bonus = new Calculator(5);
Calculator ihq = bonus;
Calculator lennon = bonus;

lennon = new Calculator(3);
</pre>

        <p>The modification of the <code>lennon</code> variable contents â that is to say the change of reference â does not affect the references of either <code>bonus</code> or <code>ihq</code>. Always when we assign a value to a variable, we change the contents of only that variable's own slot. The same concept in a picture:</p>

        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-6.png" /></p>

        <h4>A Reference Type Variables and Method Parameters</h4>

        <p>When a reference type variable is given to a method as its parameter, we create a method parameter which is the copy of the reference of a variable. In other words, we copy the reference to the parameter's own slot. Differently from what happens with original type variables, we copy the reference, and not their value. In fact, we can we can modify the object behind the reference even form within the method. Let us take the method <code>public void addToCalculator(Calculator calculator, int amount)</code>.</p>

<pre class="sh_java">
public void addToCalculator(Calculator calculator, int amount) {
    for (int i = 0; i &lt; amount; i++) {
        calculator.increaseValue();
    }
}
</pre>

        <p>We give two parameters to the method <code>addToCalculator</code> â a reference type value and an original type variable. The contents of both variable slots are copied to method parameter slots. The reference type parameter <code>calculator</code> receives a copy of a reference, whereas the original type parameter <code>amount</code> receives the copy of value. The method will call the <code>increaseValue()</code> method of the <code>Calculator</code> type parameter, and it will do it as many times as the value of the <code>amount</code> variable. Let us analise the method call more deeply.</p>

<pre class="sh_java">
int times = 10;

Calculator bonus = new Calculator(10);
addToCalculator(bonus, times);
// the bonus variable value is now 20
</pre>

        <p>In the example, we call the <code>addToCalculator</code> method whose given variables are <code>bonus</code> and <code>times</code>. This means that the reference of the reference type variable <code>bonus</code> and the value of the original type variable <code>times</code> â which is <code>10</code> â are copied as parameters whose names are <code>calculator</code> and <code>amount</code>, respectively. The method executes the <code>increaseValue()</code> method of the <code>calculator</code> variable a number of times which equals the value of <code>amount</code>. See the following picture:</p>


        <p><img src="img-ohja/vis/viittaustyyppiset-muuttujat-laskurit-7.png" /></p>

        <p><em>The method contains variables which are completely separated from the main program!</em></p>

        <p>As far as the reference type variable is concerned, a reference duplicates and it is given to the method, and the variable inside the method will still point to the same object. As far as the original type variable is concerned, a value is copied, and the variable inside the method will have its completely independent value.</p>

        <p>The method recognises the calculator which the <code>bonus</code> variable points to, and the alterations made by the method have a direct impact on the object. The situation is different with original type variables, and the method only receives a copy of the value of the <code>times</code> variable. In fact, it is not possible to modify the value of original type variables directly within a method.</p>

        <h4>A method which returns a reference type variable</h4>

        <p>When a method returns a reference type variable, it returns the reference to an object located elsewhere. Once the reference is returned by a method, it can be assigned to a variable in the same way as a normal assignment would happen, through the equal sign (=). Let us have a look at the method <code>public Calculator createCalculator(int startValue)</code>, which creates a new reference type variable.</p>

<pre class="sh_java">
public Calculator createCalculator(int startValue) {
    return new Calculator(startValue);
}
</pre>

    <p>The creteCalculator method creates an object and returns its <code>newCalculator</code> reference. By calling the method, we always create a new object. In the following example we create two different <code>Calculator</code> type objects.</p>

<pre class="sh_java">
Calculator bonus  = createCalculator(10);
Calculator lennon = createCalculator(10);
</pre>

        <p>The method <code>createCalculator</code> always creates a new <code>Calculator</code> type object. With the first call, <code>Calculator bonus  = createCalculator(10);</code> we assign the method return reference to the <code>bonus</code> variable. With the second call, we create another reference and we assign it to the <code>lennon</code> variable. The variables <code>bonus</code> and <code>lennon</code> do not contain the same reference because the method creates a new object in both cases, and it returns the reference to that particular object.</p>


        <h2 id="stat_ja_ei">Static and Non-Static</h2>


        <p>Let us go back to a topic which we introduced in the 30th section of Introduction to Programming, and let us go deeper into into. The static or non-static nature of a variable or of a method depends on their scope. Static methods are always related to their class, whereas non-static methods can modify the variables of the object itself.</p>

        <h3>Static, Class Libraries and Final</h3>

        <p>The methods which receive the definition static are not related to objects but to classes. it is possible to define class-specific variables by adding the word <code>static</code> to their name. For instance, <code>Integer.MAX_VALUE</code>, <code>Long.MIN_VALUE</code> and <code>Double.MAX_VALUE</code> are all static methods. Static methods are called via their class name, for instance <code>ClassName.variable</code> or <code>ClassName.method()</code>.</p>

        <p>We call class library that class which contains common-use methods and variables. For instance, Java <code>Math</code> class is a class library. It provides the <code>Math.PI</code> variable, inter alia. Often, creating your own class libraries can prove useful. Helsinki Regional Transport Authority (Finnish: Helsingin Seudun Liikenne, HSL) could use a class library to keep its ticket prices at its fingertips.</p>

<pre class="sh_java">
public class HslPrices {
    public static final double SINGLETICKET_AUDULT = 2.50;
    public static final double TRAMTICKET_AUDULT = 2.50;
}
</pre>

        <p>The keyword <code>final</code> in the variable definition tells that once we assign a value to a variable, we can not assign a new one to it. Final type variables are constant, and they always have to have a value. For instance, the class variable which tells the greatest integer, <code>Integer.MAX_VALUE</code>, is a constant class variable.</p>

        <p>Once we have the class presented above, <code>HslPrices</code>, all the programs which need the single or tram-ticket price can have access to it through the class <code>HslPrices</code>. With the next example, we present the class <code>Person</code>, which has the method <code>enoughMoneyForSingleTicket()</code>, which makes use of the ticket price found in the class <code>HslPrices</code>.</p>

<pre class="sh_java">
public class Person {
    private String name;
    private double money;
    // more object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.rahat >= HslPrices.SINGLETICKET_AUDULT) {
            return true;
        }

        return false;
    }

    // the other methods regarding the class Person
}
</pre>

<p>The method <code>public boolean enoughMoneyForSingleTicket()</code> compares the object variable <code>money</code> of class <code>Person</code> to the static variable <code>SINGLETICKET_AUDULT</code> of class <code>HslPrices</code>. The method <code>enoughMoneyForSingleTicket()</code> can be called only through an object reference. For instance:</p>

<pre class="sh_java">
Person matti = new Person();

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
</pre>

<p>Note the naming convention! All <em>constants</em>, i.e. all variable which are provided with the definition final, are written with CAPITAL_LETTERS_AND_UNDERLINE_CHARACTERS.</p> 

<p>Static methods function analogously. For instance, the class <code>HslPrices</code> could <em>encapsulate</em> the variables and only provide <em>accessors</em>. We call accessors the methods which allow us to either read a variable value or to assign them a new one.</p>

<pre class="sh_java">
public class HslPrices {
    public static final double SINGLETICKET_AUDULT = 2.50;
    public static final double TRAMTICKET_AUDULT = 2.50;

  public static double getSingleTicketPrice() {   // Accessor
    return SINGLETICKET_AUDULT;
  }

  public static double getTramTicketPrice() {   // Accessor
    return TRAMTICKET_AUDULT;
  }
}
</pre>

<p>In such cases, when we code a class such as <code>Person</code>, we can't call the variable straight, but we have to get it through the method <code>getSingleTicketPrice()</code>.</p>

<pre class="sh_java">
public class Peson {
    private String name;
    private double money;
    // other object variables

    // constructor

    public boolean enoughMoneyForSingleTicket() {
        if(this.money >= HslPrices.giveSingleTicketPrice()) {
            return true;
        }

        return false;
    }

    // other methods regarding the class Person
}
</pre>


<p>Even though Java allows for static variable use, we do not usually require it. Often, using static methods causes problems with the program structure, because static variables are as inconvenient as <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">global variables</a>. <b>The only static variables we use in this course are constant, i.e. final!</b></p>

    <h3>Non-Static</h3>

    <p>Non-static methods and variables are related to objects. The object variables, or attributes, are defined at the beginning of the class. When an object is created with the <code>new</code> operator, we allocate storage space for all its object variables. The variable values are personal of the object, which means that every object receives personal variable values. Let us focus again on the class <code>Person</code>, which has got the object variable <code>name</code> and <code>money</code>.</p>

<pre class="sh_java">
public class Person {
  private String name;
  private double money;

  // other details
}
</pre>

    <p>When we create a new instance of class <em>Person</em>, we also initialize its variables. If we do not initialize the reference type variable <code>name</code>, it receives value <em>null</em>. Let us add the <em>constructor</em> and a couple of methods to our class <em>Person</em>.</p>

<pre class="sh_java">
public class Person {
  private String name;
  private double money;

    // constructor
    public Person(String name, double money) {
        this.name = name;
        this.money = money;
    }

    public String getName() {
        return this.name;
    }

    public double getMoney() {
        return this.money;
    }

    public void addMoney(double amount) {
        if(amount &gt; 0) {
          this.money += amount;
        }
    }

    public boolean enoughMoneyForSigleTicket() {
        if(this.money >= HslPrices.getSingleTicketPrice()) {
            return true;
        }

        return false;
    }
}
</pre>

    <p>The constructor <code>Person(String name, double money)</code> creates a new Person object, and it returns its reference. The method <code>getName()</code> returns the reference to a <code>name</code> object, and the <code>getMoney()</code> method returs the original type variable <code>money</code>. The method <code>addMoney(double amount)</code> receives as parameter an amount of money, and it adds it to the <code>money</code> object variable if the parameter's value is greater than 0.</p>

    <p>Object methods are called through their object reference. The following code example creates a new Person object, increases its money, and prints its name, at the end. Note that the method calls follow the pattern <code>objectName.methodName()</code></p>

<pre class="sh_java">
Person matti = new Person("Matti", 5.0);
matti.addMoney(5); 

if (matti.enoughMoneyForSingleTicket()) {
    System.out.println("I'll buy a single ticket.");
} else {
    System.out.println("Fare dodging, yeah!");
}
</pre>

    <p>The example prints "<code>I'll buy a single ticket.</code>"</p>

    <h4>Class Methods</h4>

    <p>Non-static class methods can be also called without specifing the object affix which indicates the class. In the following example, the <code>toString()</code> method points to the class <code>Person</code>, which calls the object method <code>getName()</code>.</p>

<pre class="sh_java">
public class Person {
    // earlier written content

    public String toString() {
        return this.getName();
    }
}
</pre>

    <p>The <code>toString()</code> method calls the class method <code>getName()</code>, which belongs to the object in question. The <code>this</code> affix emphasize that the calls precisely refers to this object.</p>

    <p>Non-static methods can also call static methods, that is the class-specific ones. On the other hand, static methods can not call non-static methods without a reference to the object itself, which is essential to retrive the object information.</p>


    <h4>A Variable within a Method</h4>

    <p>The variables which are defined inside a method are auxiliary variables used during the method execution, and they are not to be confused with object variables. The example below shows how a local variable is created inside a method. The <code>index</code> variable exists and is accessible only during the method execution.</p>

<pre class="sh_java">
public class ... {
    ...

    public static void printTable(String[] table) {
        int index = 0;

        while(index &lt; table.length) {
            System.out.println(table[index]);
            index++;
        }
    }
}
</pre>

    <p>In the <code>printTable()</code> method, we create the auxiliary variable <code>index</code> which we use to parse the table. The variable <code>index</code> exists only during the method execution.</p>


<div class="tehtavat">
  <h3>Tavara, Matkalaukku ja Lastiruuma</h3>

  <p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤sarjassa tehdÃ¤Ã¤n luokat <code>Tavara</code>, <code>Matkalaukku</code> ja <code>Lastiruuma</code>, joiden avulla harjoitellaan olioita, jotka sisÃ¤ltÃ¤vÃ¤t toisia olioita.</p>

  <h4 class="req">Tavara-luokka</h4>

  <p>Tee luokka <code>Tavara</code>, josta muodostetut oliot vastaavat erilaisia tavaroita. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).</p>

  <p>LisÃ¤Ã¤ luokkaan seuraavat metodit:</p>

  <ul>
    <li>Konstruktori, jolle annetaan parametrina tavaran nimi ja paino</li>
    <li>Metodi <code>public String getName()</code>, joka palauttaa tavaran nimen</li>
    <li>Metodi <code>public int getPaino()</code>, joka palauttaa tavaran painon</li>
    <li>Metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "nimi (paino kg)"</li>
  </ul>

  <p>Seuraavassa on luokan kÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);

        System.out.println("Bookn nimi: " + kirja.getName());
        System.out.println("Bookn paino: " + kirja.getPaino());

        System.out.println("Book: " + kirja);
        System.out.println("Puhelin: " + puhelin);
    }
}
</pre>

<p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Bookn nimi: Aapiskukko
Bookn paino: 2
Book: Aapiskukko (2 kg)
Puhelin: Nokia 3210 (1 kg)
</pre>

<h4 class="req">Matkalaukku-luokka</h4>

  <p>Tee luokka <code>Matkalaukku</code>. Matkalaukkuun liittyy tavaroita ja maksimipaino, joka mÃ¤Ã¤rittelee tavaroiden suurimman mahdollisen yhteispainon.</p>

  <p>LisÃ¤Ã¤ luokkaan seuraavat metodit:</p>

  <ul>
    <li> Konstruktori, jolle annetaan maksimipaino</li>
    <li> Metodi <code>public void lisaaTavara(Tavara tavara)</code>, joka lisÃ¤Ã¤ parametrina annettavan tavaran matkalaukkuun. Metodi ei palauta mitÃ¤Ã¤n arvoa.</li>
    <li> Metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "x tavaraa (y kg)"</li>
  </ul>

  <p>Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:</p>

<pre class="sh_java">
ArrayList&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
</pre>

  <p>Luokan <code>Matkalaukku</code> tulee valvoa, ettÃ¤ sen sisÃ¤ltÃ¤mien tavaroiden yhteispaino ei ylitÃ¤ maksimipainoa. Jos maksimipaino ylittyisi lisÃ¤ttÃ¤vÃ¤n tavaran vuoksi, metodi <code>lisaaTavara</code> ei saa lisÃ¤tÃ¤ uutta tavaraa laukkuun.</p>

  <p>Seuraavassa on luokan kÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(5);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(kirja);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(puhelin);
        System.out.println(matkalaukku);

        matkalaukku.lisaaTavara(tiiliskivi);
        System.out.println(matkalaukku);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
0 tavaraa (0 kg)
1 tavaraa (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>

  <h4>Kielenhuoltoa</h4>

  <p>Ilmoitukset "0 tavaraa" ja "1 tavaraa" eivÃ¤t ole kovin hyvÃ¤Ã¤ suomea &ndash; paremmat muodot olisivat "ei tavaroita" ja "1 tavara". Tee tÃ¤mÃ¤ muutos luokkaan <code>Matkalaukku</code>.</p>

  <p>Nyt edellisen ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
ei tavaroita (0 kg)
1 tavara (2 kg)
2 tavaraa (3 kg)
2 tavaraa (3 kg)
</pre>

<h4 class="req">Kaikki tavarat</h4>

<p>LisÃ¤Ã¤ luokkaan <code>Matkalaukku</code> seuraavat metodit:</p>

<ul>
  <li> metodi <code>tulostaTavarat</code>, joka tulostaa kaikki matkalaukussa olevat tavarat</li>
  <li> metodi <code>yhteispaino</code>, joka palauttaa tavaroiden yhteispainon</li>
</ul>

<p>Seuraavassa on luokan kÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        System.out.println("Matkalaukussa on seuraavat tavarat:");
        matkalaukku.tulostaTavarat();
        System.out.println("Yhteispaino: " + matkalaukku.yhteispaino() + " kg");
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Matkalaukussa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
Tiiliskivi (4 kg)
Yhteispaino: 7 kg
</pre>


  <p>Muokkaa myÃ¶s luokkaasi siten, ettÃ¤ kÃ¤ytÃ¤t vain kahta oliomuuttujaa. Toinen sisÃ¤ltÃ¤Ã¤ maksimipainon, toinen on lista laukussa olevista tavaroista.</p>

<h4 class="req">Raskain tavara</h4>

  <p>LisÃ¤Ã¤ vielÃ¤ luokkaan <code>Matkalaukku</code> metodi <code>raskainTavara</code>, joka palauttaa painoltaan suurimman tavaran. Jos yhtÃ¤ raskaita tavaroita on useita, metodi voi palauttaa minkÃ¤ tahansa niistÃ¤. Metodin tulee palauttaa olioviite. Jos laukku on tyhjÃ¤, palauta arvo <em>null</em>.</p>

  <p>Seuraavassa on luokan kÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("Tiiliskivi", 4);

        Matkalaukku matkalaukku = new Matkalaukku(10);
        matkalaukku.lisaaTavara(kirja);
        matkalaukku.lisaaTavara(puhelin);
        matkalaukku.lisaaTavara(tiiliskivi);

        Tavara raskain = matkalaukku.raskainTavara();
        System.out.println("Raskain tavara: " + raskain);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Raskain tavara: Tiiliskivi (4 kg)
</pre>

<h4 class="req">Lastiruuma-luokka</h4>

  <p>Tee luokka <code>Lastiruuma</code>, johon liittyvÃ¤t seuraavat metodit:</p>

  <ul>
    <li> konstruktori, jolle annetaan maksimipaino</li>
    <li> metodi <code>public void lisaaMatkalaukku(Matkalaukku laukku)</code>, joka lisÃ¤Ã¤ parametrina annetun matkalaukun lastiruumaan</li>
    <li> metodi <code>public String toString()</code>, joka palauttaa characterStringn muotoa "x matkalaukkua (y kg)"</li>
  </ul>

  <p>Tallenna matkalaukut sopivaan <code>ArrayList</code>-rakenteeseen.</p>

  <p>Luokan <code>Lastiruuma</code> tulee valvoa, ettÃ¤ sen sisÃ¤ltÃ¤mien matkalaukkujen yhteispaino ei ylitÃ¤ maksimipainoa. Jos maksimipaino ylittyisi uuden matkalaukun vuoksi, metodi <code>lisaaMatkalaukku</code> ei saa lisÃ¤tÃ¤ uutta matkalaukkua.</p>

<p>Seuraavassa on luokan kÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println(lastiruuma);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
2 matkalaukkua (7 kg)
</pre>

<h4 class="req">Lastiruuman sisÃ¤ltÃ¶</h4>

  <p>LisÃ¤Ã¤ luokkaan <code>Lastiruuma</code> metodi <code>public void tulostaTavarat()</code>, joka tulostaa kaikki lastiruuman matkalaukuissa olevat tavarat.</p>

<p>Seuraavassa on luokan kÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Tavara kirja = new Tavara("Aapiskukko", 2);
        Tavara puhelin = new Tavara("Nokia 3210", 1);
        Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

        Matkalaukku matinLaukku = new Matkalaukku(10);
        matinLaukku.lisaaTavara(kirja);
        matinLaukku.lisaaTavara(puhelin);

        Matkalaukku pekanLaukku = new Matkalaukku(10);
        pekanLaukku.lisaaTavara(tiiliskivi);

        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lastiruuma.lisaaMatkalaukku(matinLaukku);
        lastiruuma.lisaaMatkalaukku(pekanLaukku);

        System.out.println("Ruuman matkalaukuissa on seuraavat tavarat:");
        lastiruuma.tulostaTavarat();
    }
}
</pre>

<p>Ohjelman tulostuksen tulisi olla seuraava:</p>

<pre>
Ruuman matkalaukuissa on seuraavat tavarat:
Aapiskukko (2 kg)
Nokia 3210 (1 kg)
tiiliskivi (4 kg)
</pre>

<h4>Paljon tiiliskiviÃ¤</h4>

  <p>Testataan vielÃ¤, ettÃ¤ lastiruuman toiminta on oikea eikÃ¤ maksimipaino pÃ¤Ã¤se ylittymÃ¤Ã¤n. Tee Main-luokkaan metodi <code>public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma)</code>, joka lisÃ¤Ã¤ parametrina annettuun lastiruumaan 100 matkalaukkua, joissa jokaisessa on yksi tiiliskivi. Tiiliskivien painot ovat 1, 2, 3, ..., 100 kg.</p>

  <p>Ohjelman runko on seuraava:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        Lastiruuma lastiruuma = new Lastiruuma(1000);
        lisaaMatkalaukutTiiliskivilla(lastiruuma);
        System.out.println(lastiruuma);
    }

    public static void lisaaMatkalaukutTiiliskivilla(Lastiruuma lastiruuma) {
        // 100 matkalaukun lisÃ¤Ã¤minen, jokaiseen tulee tiiliskivi
    }
}
</pre>

  <p>Ohjelman tulostus on seuraava:</p>

<pre>
44 matkalaukkua (990 kg)
</pre>

</div>

    <h2 id="hashmap">HashMap</h2>

    <p><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html">HashMap</a> is one of Java's most useful data structures. The idea behind HashMap is we define an index for an object key - a unique value, as for instance a social number, a student number, or a phone number. We call <em>hashing</em> the process of changing a key into an index, or simply to define an index. The hashing happens thanks to a particular function which makes sure that we get always the same index with a known key.</p>

    <p>Adding and retriving items based on the keys, allows for a particularly quick search process. Instead of parsing the table items one by one (in the worst case we would have to go through all the items), and instead of looking for a value with a binar search (in which case we would have to go through a number of items which would depend on the logarithm of the table size), we can look at only one table index and check whether a value is mapped to that index.</p>

    <p>HashMap uses the <code>Object</code> class <code>hashCode()</code> method to find a key value. Every HashMap subclass will <em>inherit</em> the <code>hashCode()</code> method. However, we will not go deep into HasMap workings in this course. We will return to heritage in week 4.</p>


    <p>Java's <code>HashMap</code> class capsulates - or hides - the way it works, and it returns made-up methods ready to use.</p>

    <p>When we create a HashMap we need two <em>type parameters</em>, a type for the key variable, and a type for the stored object. The following example uses a <code>String</code> type object as key, and a <code>String</code> type object as the stored object.</p>


<pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
</pre>

<pre>
Yksi
Kaksi
null
null
</pre>


    <p>In the example, we create a HashMap which both the key and the stored object are strings. We add information to the HashMap with the <code>put()</code> method, which receives the references to the key and to the stored object as parameter. The method <code>get()</code> returns either the reference to the key given as parameter or a <code>null</code> value in case the key was not found.</p>

    <p>Each key is mapped to one value, within the HashMap. If we store a new value with an already existing key, the old value is lost.</p>

<pre class="sh_java">
HashMap&lt;String, String&gt; numbers = new HashMap&lt;String, String&gt;();
numbers.put("One", "Yksi");
numbers.put("Two", "Kaksi");
numbers.put("One", "Uno");

String translation = numbers.get("One");
System.out.println(translation);

System.out.println(numbers.get("Two"));
System.out.println(numbers.get("Three"));
System.out.println(numbers.get("Yksi"));
</pre>

    <p>Because the key "<code>Yksi</code>" is assigned a new value, the print output of the example is like the following.</p>

<pre>
Uno
Kaksi
null
null
</pre>

<div class="tehtavat">

  <h3>Lempinimet</h3>

  <p>Luo <code>main</code>-metodissa
  uusi <code>HashMap&lt;String,String&gt;</code>-olio. Tallenna tÃ¤hÃ¤n
  HashMappiin seuraavien henkilÃ¶iden nimet ja lempinimet niin, ettÃ¤
  nimi on avain ja lempinimi on arvo. KÃ¤ytÃ¤ pelkkiÃ¤ pieniÃ¤ kirjaimia.</p>

  <ul>
    <li>matin lempinimi on mage</li>
    <li>mikaelin lempinimi on mixu</li>
    <li>arton lempinimi on arppa</li>
  </ul>

  <p>TÃ¤mÃ¤n jÃ¤lkeen hae HashMapistÃ¤ mikaelin lempinimi ja tulosta se.</p>

<p>Testit edellyttÃ¤vÃ¤t ettÃ¤ kirjoitat nimet pienellÃ¤ alkukirjaimella.</p>

</div>

        <h3 id="kirjastotietokanta">Book Search through HashMap</h3>

        <p>Let us go deeper into HashMap workings with the help of the following example. Books can be retrived based on their name, which acts as book key. If we find a book for the given name, we obtain the respective reference, as well as the book details. Let us create the example class <code>Book</code>, which has a name and the book contents as object variables.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private String contents;
    private int publishingYear;

    public Book(String name, int publishingYear, String contents) {
        this.name = name;
        this.publishingYear = publishingYear;
        this.contents = contents;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    public void setPublishingYear(int publishingYear) {
        this.publishingYear = publishingYear;
    }

    public String getContents() {
        return this.contents;
    }

    public void setContents(String contents) {
        this.contents = contents;
    }

    public String toString() {
        return "Nimi: " + this.name + " (" + this.publishingYear + ")\n"
                + "Contents: " + this.contents;
    }
}
</pre>

        <p>In the following example, we create a HashMap which makes use of the book name - a String type object - and stores the references which point to <code>Book</code>-objects.</p>

<pre class="sh_java">
HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
</pre>

    <p>The HashMap above has a <code>String</code> object as key. Let us extend our example so that we would add two books to our book collection, <code>"Sense and Sensibility"</code> and <code>"Pride and Prejudice"</code>.</p>

<pre class="sh_java">
Book senseAndSensibility = new Book("Sense and Sensibility", 1811, "...");
Book prideAndPrejudice = new Book("Pride and Prejudice", 1813, "....");

HashMap&lt;String, Book&gt; bookCollection = new HashMap&lt;String, Book&gt;();
bookCollection.put(senseAndSensibility.getName(), senseAndSensibility);
librabookCollectionry.put(prideAndPrejudice.getName(), prideAndPrejudice);
</pre>

        <p>Books can be retrived from the book collection based on their name. A search for the book <code>"Persuasion"</code> does not return a corresponding entry, in which case the HashMap returns a <code>null</code> reference. However, the book "Pride and Prejudice" was found.</p>

<pre class="sh_java">
Book book = bookCollection.get("Persuasion");
System.out.println(book);
System.out.println();
book = bookCollection.get("Pride and Prejudice");
System.out.println(book);
</pre>

<pre>
null

Name: Pride and Prejudice (1813)
Contents: ...
</pre>

    <p>HashMaps are useful when we know the key to use for our search. Keys are always unique, and it is not possible to store more than one object together with one key alone. The object which we store can still be a list or another HashMap, of course!</p>

    <h3 id="kapseloitu_kirjasto">Library</h3>

    <p>The problem with the book collection above is that we must remember the correct book name when we search for it, character by character. Java built-in <code>String</code> class provides us the tools for this. The <code>toLowerCase()</code> method turns a string's characters to lower case, and the <code>trim()</code> method deletes the white spaces at the beginning and at the end of the string. Computer users tend to write white spaces at the beginning or end of a text, involuntarily.</p>

<pre class="sh_java">
String text = "Pride and Prejudice ";
text = text.toLowerCase(); // the text is now "Pride and Prejudice "
text = text.trim() // the text is now "Pride and Prejudice"
</pre>

    <p>Let us create the the class <code>Library</code>, which capsulates a HashMap containing books, and allows for book search regardless of its spelling. Let us add the methods <code>addBook(Book book)</code> and <code>removeBook(String bookName)</code> to our <code>Library</code> class. It's already clear that we would need various different methods to clean a string. Therefore, we can create a separate method called <code>private String stringCleaner(String string)</code>.</p>

<pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public void lisaaBook(Book book) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(nimi)) {
            System.out.println("The book is already in the library!");
        } else {
            collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
</pre>
        <p>We implement our search functionality so that we can retrieve a book using a hash algorithm based on the book name.</p>

<pre class="sh_java">
    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }
</pre>

    <p>The method above returns the wanted book when this is found, otherwise it returns a <code>null</code> value. We can also also go through all the collection keys one by one, and say look for the beginning characters of the book's name. In this way, we would anyway fail to capitalise on HashMap performance speed, because we would need to go through all the book names, in the worst case. Search based on the beginning characters of a string is possible through the <code>keySet()</code> method. The <code>keySet()</code> method returns a set of keys, which can be parsed with the <code>for each</code> loop.</p>

<pre class="sh_java">
    public Book getBookUsingItsBeginningCharacters(String beginning) {
        beginning = stringCleaner(beginning);

        for (String key: this.collection.keySet()) {
            if (key.startsWith(beginning)) {
                return this.collection.get(key);
            }
        }

        return null;
    }
</pre>

    <p>Let us leave the method above out of our library, anyway. Our library is still lacking an essential feature concerning book addition. Let us create the method <code>public ArrayList&lt;Book&gt; bookList()</code>, which returns a list of the books in our library. The method <code>bookList()</code> makes use of the <code>values()</code> method, which is provided by HashList. The <code>values()</code> method returns a set of our library books, which can be given as parameter to the constructor of an <code>ArrayList</code> class.</p>

<pre class="sh_java">
public class Library {
    private HashMap&lt;String, Book&gt; collection;

    public Library() {
        this.collection = new HashMap&lt;String, Book&gt;();
    }

    public Book getBook(String bookName) {
        bookName = stringCleaner(bookName);
        return this.collection.get(bookName);
    }

    public void addBook(Book kirja) {
        String name = stringCleaner(book.getName());

        if(this.collection.containsKey(name)) {
            System.out.println("The book is already in the library!");
        } else {
            this.collection.put(name, book);
        }
    }

    public void removeBook(String bookName) {
        bookName = stringCleaner(bookName);

        if(this.collection.containsKey(bookName)) {
            this.collection.remove(bookName);
        } else {
            System.out.println("The book was not found, you can't remove it!");
        }
    }

    public ArrayList&lt;Book&gt; bookList() {
        return new ArrayList&lt;Book&gt;(this.collection.values());
    }

    private String stringCleaner(String string) {
        if (string == null) {
            return "";
        }

        string = string.toLowerCase();
        return string.trim();
    }
}
</pre>

    <p>Among the programming principles, there is the so called <em>DRY</em> principle (Don't Repeat Yourself), according to which we try to avoid repeting the same code in different places. Turning a string to lower case, and its <em>trimming</em> - that is to say removing white spaces from the beginning and the end of a string - would have recourred various different times without the <code>stringCleaner()</code> method. We hardly notice we are repeating the same code before we have written it, in which case it eventually ends up there. This is not bad, however. The most important thing is that we clean our code as soon as we notice the need.</p>


    <h3>Orignial Type Variables in a HashMap</h3>

    <p>Both HashMap keys and stored objects are referece type variables. If we want to use an original type variable as key or stored value, we can use their reference type equivalent. Some are introduced below.</p>

    <p>
      <table>
        <tr><th>Original type</th><th>Reference type equivalent</th><tr>
        <tr><td>int</td><td><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html" target="_blank">Integer</a></td></tr>
        <tr><td>double</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Double.html" target="_blank">Double</a></td></tr>
        <tr><td>char</td><td><a href="docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_blank">Character</a></td></tr>
      </table>
    </p>

        <p>In fact, Java automatically capsulates original type values and translates them into reference type values when that is needed. Even though the number <code>1</code> is an original type variable, it can be used as an <code>Integer</code> key directly in the following way.</p>

<pre class="sh_java">
HashMap&lt;Integer, String&gt; table = new HashMap&lt;Integer, String&gt;();
table.put(1, "Be!");
</pre>

        <p>In Java, the automatic translation of original type variables into reference type ones is called <em>auto-boxing</em>, i.e. allocation into a slot. The same process also works in the opposite way. We can create a method which returns a HashMap containing an Integer. In the following example, the automatic translation happens inside the method <code>addTwitch</code>.</p>


<pre class="sh_java">
public class TwitchRegister {
    private HashMap&lt;String, Integer&gt; twitched;

    public NumberBookkeeping() {
        this.twitched = new HashMap&lt;String, Integer&gt;();
    }

    public void addTwitch(String name, int number) {
        this.twitched.put(nimi, numero);
    }

    public int lastTwitch(String name) {
        this.twitched.get(name);
    }
}
</pre>

        <p>Even though the HashMap contains Integer objects, Java can also translate certain reference type variables into their original type equivalent. For instance, <code>Integer</code> objects can be translated into <code>int</code> values, if needed. However, this can be misleading! If we try to translate a null reference into a number, we receive the <em>java.lang.reflect.InvocationTargetException</em> error. When we make use of this automatic translation, we have to be sure that the value we want to translate is not null. The above <code>lastTwitch</code> method must be fixed in the following way.</p>

<pre class="sh_java">
    public int lastTwitch(String name) {
        if(this.twitched.containsKey(name) {
            return this.twitched.get(name);
        }

        return 0;
    }
</pre>



<div class="tehtavat">
  <h3>Velkakirja</h3>

  <p>Luo luokka <code>Velkakirja</code>, jolla on seuraavat toiminnot:</p>

  <ul>
    <li> konstruktori <code>public Velkakirja()</code> luo uuden velkakirjan</li>
    <li> metodi <code>public void asetaLaina(String kenelle, double maara)</code> tallettaa velkakirjaan merkinnÃ¤n lainasta tietylle henkilÃ¶lle.</li>
    <li> metodi <code>public double paljonkoVelkaa(String kuka)</code> palauttaa velan mÃ¤Ã¤rÃ¤n annetun henkilÃ¶n nimen perusteella</li>
  </ul>

<p>Luokkaa kÃ¤ytetÃ¤Ã¤n seuraavalla tavalla:</p>

<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Mikael", 30);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
  System.out.println(matinVelkakirja.paljonkoVelkaa("Joel"));
</pre>

<p>YllÃ¤ oleva esimerkki tulostaisi:</p>

<pre>
51.5
0
</pre>

<p>Ole tarkkana tilanteessa, jossa kysytÃ¤Ã¤n velattoman ihmisen velkaa. Kertaa luvun 4.3 lopun esimerkki!</p>

  <p>Huom! Velkakirjan ei tarvitse huomioida vanhoja lainoja. Kun asetat uuden velan henkilÃ¶lle jolla on vanha velka, vanha velka unohtuu.</p>  

<pre class="sh_java">
  Velkakirja matinVelkakirja = new Velkakirja();
  matinVelkakirja.asetaLaina("Arto", 51.5);
  matinVelkakirja.asetaLaina("Arto", 10.5);

  System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
</pre>

<pre>
10.5
</pre>

  <h3>Sanakirja</h3>

  <p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤sarjassa toteutetaan sanakirja, josta voi hakea suomen kielen sanoille englanninkielisiÃ¤ kÃ¤Ã¤nnÃ¶ksiÃ¤. Sanakirjan tekemisessÃ¤ kÃ¤ytetÃ¤Ã¤n <code>HashMap</code>-tietorakennetta.</p>

  <h4 class="req">Luokka Sanakirja</h4>

  <p>Toteuta luokka nimeltÃ¤ <code>Sanakirja</code>. Luokalla on aluksi seuraavat metodit:</p>

  <ul>
    <li> <code>public String kaanna(String sana)</code> metodi palauttaa parametrinsa kÃ¤Ã¤nnÃ¶ksen. Jos sanaa ei tunneta, palautetaan <em>null</em>.</li>
    <li> <code>public void lisaa(String sana, String kaannos)</code> metodi lisÃ¤Ã¤ sanakirjaan uuden kÃ¤Ã¤nnÃ¶ksen</li>
  </ul>

  <p>Toteuta luokka Sanakirja siten, ettÃ¤ sen ainoa oliomuuttuja on <code>HashMap</code>-tietorakenne.</p>

  <p>Testaa sanakirjasi toimintaa:</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("porkkana"));
</pre>

<pre>
monkey
null
</pre>

<h4>Sanojen lukumÃ¤Ã¤rÃ¤</h4>

  <p>LisÃ¤Ã¤ sanakirjaan metodi <code>public int sanojenLukumaara()</code>, joka palauttaa sanakirjassa olevien sanojen lukumÃ¤Ã¤rÃ¤n.</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    System.out.println(sanakirja.sanojenLukumaara());

    sanakirja.lisaa("cembalo", "harpsichord");
    System.out.println(sanakirja.sanojenLukumaara());
</pre>


<pre>
2
3
</pre>

<h4>Kaikkien sanojen listaaminen</h4>

  <p>LisÃ¤Ã¤ sanakirjaan metodi <code>public ArrayList&lt;String&gt; kaannoksetListana()</code> joka palauttaa sanakirjan sisÃ¤llÃ¶n listana <i>avain = arvo</i> muotoisia characterStringja.</p>

<pre class="sh_java">
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    ArrayList&lt;String&gt; kaannokset = sanakirja.kaannoksetListana();
    for(String kaannos: kaannokset) {
        System.out.println(kaannos);
    }
</pre>

<pre>
banaani = banana
apina = monkey
cembalo = harpsichord
</pre>

<p><strong>Vihje:</strong> saat kÃ¤ytyÃ¤ kaikki HashMapissa olevat avaimet lÃ¤pi metodin <code>keySet</code> avulla seuraavasti:</p>

<pre class="sh_java">
    HashMap&lt;String, String&gt; sanaparit = new HashMap&lt;String, String&gt;();

    sanaparit.put("apina", "elÃ¤in");
    sanaparit.put("etelÃ¤", "ilmansuunta");
    sanaparit.put("sauerkraut", "ruoka");

    for ( String avain : sanaparit.keySet() ) {
        System.out.print( avain + " " );
    }
 
    // tulostuu apina etelÃ¤ sauerkraut
</pre>



  <h4 class="req">TekstikÃ¤yttÃ¶liittymÃ¤n alku</h4>

  <p>Harjoitellaan tÃ¤ssÃ¤kin tehtÃ¤vÃ¤ssÃ¤ erillisen tekstikÃ¤yttÃ¶liittymÃ¤n tekemistÃ¤. Luo luokka <code>Tekstikayttoliittyma</code>, jolla on seuraavat metodit
    <ul>
      <li> konstruktori <code>public Tekstikayttoliittyma(Scanner lukija, Sanakirja sanakirja)</code></li>
      <li> metodi <code>public void start()</code>, joka kÃ¤ynnistÃ¤Ã¤ tekstikÃ¤yttÃ¶liittymÃ¤n.</li>
    </ul>
  </p>

<p>TekstikÃ¤yttÃ¶liittymÃ¤ tallettaa konstruktorin parametrina saamansa lukijan ja sanakirjan oliomuuttujiin. Muita oliomuuttujia ei tarvita.
<strong>
KÃ¤yttÃ¤jÃ¤n syÃ¶tteen lukeminen tulee hoitaa konstruktorin parametrina saatua lukija-olioa kÃ¤yttÃ¤en! MyÃ¶s kaikki kÃ¤Ã¤nnÃ¶kset on talletettava  konstruktorin parametrina saatuun sanakirja-olioon. TekstikÃ¤yttÃ¶liittymÃ¤ ei saa luoda olioita itse! 
</strong>
</p>

<p><strong>HUOM:</strong> vielÃ¤ uudelleen edellinen, eli <strong>TekstikÃ¤yttÃ¶liittymÃ¤ ei saa luoda itse skanneria</strong> vaan sen on kÃ¤ytettÃ¤vÃ¤ parametrina saamaansa skanneria syÃ¶tteiden lukemiseen!</p>

  <p>TekstikÃ¤yttÃ¶liittymÃ¤ssÃ¤ tulee aluksi olla vain komento <code>lopeta</code>, joka poistuu tekstikÃ¤yttÃ¶liittymÃ¤stÃ¤. Jos kÃ¤yttÃ¤jÃ¤ syÃ¶ttÃ¤Ã¤ jotain muuta, kÃ¤yttÃ¤jÃ¤lle sanotaan "Tuntematon komento".</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.start();
</pre>

<pre>
Komennot:
  lopeta - poistuu kÃ¤yttÃ¶liittymÃ¤stÃ¤

Komento: <font color="red">apua</font>
Tuntematon komento.

Komento: <font color="red">lopeta</font>
Hei hei!
</pre>

  <h4 class="req">Sanojen lisÃ¤Ã¤minen ja kÃ¤Ã¤ntÃ¤minen</h4>

  <p>LisÃ¤Ã¤ tekstikÃ¤yttÃ¶liittymÃ¤lle komennot <code>lisaa</code> ja <code>kaanna</code>. Komento <code>lisaa</code> lisÃ¤Ã¤ kysyy kÃ¤yttÃ¤jÃ¤ltÃ¤ sanaparin ja lisÃ¤Ã¤ sen sanakirjaan. Komento <code>kaanna</code> kysyy kÃ¤yttÃ¤jÃ¤ltÃ¤ sanaa ja tulostaa sen kÃ¤Ã¤nnÃ¶ksen.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.start();
</pre>

<pre>
Komennot:
  lisaa - lisÃ¤Ã¤ sanaparin sanakirjaan
  kaanna - kysyy sanan ja tulostaa sen kÃ¤Ã¤nnÃ¶ksen
  lopeta - poistuu kÃ¤yttÃ¶liittymÃ¤stÃ¤

Komento: <font color="red">lisaa</font>
Suomeksi: <font color="red">porkkana</font>
KÃ¤Ã¤nnÃ¶s: <font color="red">carrot</font>

Komento: <font color="red">kaanna</font>
Anna sana: <font color="red">porkkana</font>
KÃ¤Ã¤nnÃ¶s: carrot

Komento: <font color="red">lopeta</font>
Hei hei!
</pre>

</div>


<h2>Towards Automatic Tests</h2>

<p>Testing a program manually is a hopeless burden. It is possible to automate inputs by setting up a string as a Scanner object parameter. The example below shows how it is possible to test automatically the program above.</p>

<pre class="sh_java">
    String input = "translate\n" + "monkey\n"  +
                   "translate\n" + "cheese\n" +
                   "add\n"  + "cheese\n" + "juusto\n" +
                   "translate\n" + "cheese\n" +
                   "quit\n";

    Scanner reader = new Scanner(input);
    Dictionary dictionary = new Dictionary();

    TextUserInterface interface = new TextUserInterface(reader, dictionary);
    interface.start();
</pre>

  <p>The print output contains only the program output, and not the user commands.</p>

<pre>
Commands:
  add - adds a word couple to the dictionary
  translate - asks for a word and prints its translation
  quit - stops the user interface

Command: Give word: Unknown word!

Command: Give word: Unknown word!

Command: In Finnish: Translation:
Command: Give word: Translation: juusto

Command: Cheers!
</pre>

<p>Giving a string to a Scanner class is a way to replace the String inputs given with the keyboard. The contents of the String variable <code>input</code> "simulates" the user input. <code>\n</code> denotes a line break. Each single part of the <code>input</code> variable which ends with a line break corresponds to one nextLine() input.</p>

<p>It is easy to change the text input, and we can add new words to our dictionary, in the following way:</p>

<pre class="sh_java">
    String input = "add\n"  + "cheese\n" + "juusto\n" +
                   "add\n"  + "bier\n" + "olut\n" +
                   "add\n"  + "book\n" + "kirja\n" +
                   "add\n"  + "computer\n" + "tietokone\n" +
                   "add\n"  + "auto\n" + "car\n" +
                   "quit\n";
</pre>

<p>If you want to test again your program manually, change the Scanner object constructor parameter into <code>System.in</code>, i.e system input stream.</p>

<p>The program functionality must be checked from the output pane, still. The result can still be confusing at the beginning, because the athomatic input does not appear in the output pane at all.</p>

<p>The final goal will be to automate also the program functionality inspection, so that both testing the program and analising its output text would happen successfully in a click.</p>




<h2>Java API</h2>

        <p>The Java programming language we use in our course is made of three things. The first is the program syntax and semantics: the way we define variables, the control flow, the variable and class structure, and their functionality. The second is JVM, i.e. <em>Java Virtual Machine</em>, used for running our programs. Our Java programs are translated into a <em>bytecode</em>, which can be run on whatever computer has JVM. We haven't dealt with program translation because the program environment does it on our behalf. Sometimes, if the program environtment does not work as expected we may have to choose <em>clean & build</em>, which deletes the old source code and translates our program again. The third is API (<em>Application Programming Interface</em>), that is to say the program interface or standard library.</p>

        <p>API is a set of built-in classes specific of the programming language, which is provided to users for their own projects. For instance the casses <code>ArrayList</code>, <code>Arrays</code>, <code>Collections</code>, and <code>String</code> are all part of Java's build-in API. A description of the API of Java 7 can be found at the address <a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank">http://docs.oracle.com/javase/7/docs/api/</a>. On the left side of the page we find a description of Java's built-in classes. If you look for the <code>ArrayList</code> class, you  find a link to <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html" target="_blank">http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html</a>, which shows the stucture, constructors, and methods of the class.</p>

        <p>NetBeans is able to show a class API, if needed. If you write a class name and add the relative import sentence, you can right click on the class name and and choose <em>Show Javadoc</em>. This opens the class API description in your browser.</p>

<div class="tehtavat">
  <h3>LentokenttÃ¤</h3>

  <p>Jokaisella viikolla on yksi laajempi tehtÃ¤vÃ¤, jossa pÃ¤Ã¤set vapaasti suunnittelemaan ohjelman rakenteen, kÃ¤yttÃ¶liittymÃ¤n ulkomuoto ja vaaditut komennot on mÃ¤Ã¤ritelty ennalta. Ohjelmoinnin jatkokurssin ensimmÃ¤inen vapaasti suunniteltava tehtÃ¤vÃ¤ on <em>LentokenttÃ¤</em>.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. ÃlÃ¤ myÃ¶skÃ¤Ã¤n kÃ¤ytÃ¤ staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillÃ¤ suorituskerroilla jÃ¤Ã¤neet arvot todennÃ¤kÃ¶isesti hÃ¤iritsevÃ¤t testien toimintaa!</b></p>

  <p>LentokenttÃ¤-tehtÃ¤vÃ¤ssÃ¤ toteutetaan lentokentÃ¤n hallintasovellus. LentokentÃ¤n hallintasovelluksessa hallinnoidaan lentokoneita ja lentoja. Lentokoneista tiedetÃ¤Ã¤n aina tunnus ja kapasiteetti. Lennoista tiedetÃ¤Ã¤n lennon lentokone, lÃ¤htÃ¶paikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Helsinki_Airport" target="_blank">HEL</a>) ja kohdepaikan tunnus (esim. <a href="http://en.wikipedia.org/wiki/Batman_Airport" target="_blank">BAL</a>).</p>

  <p>SekÃ¤ lentokoneita ettÃ¤ lentoja voi olla useita. Sama lentokone voi myÃ¶s lentÃ¤Ã¤ useaa eri lentoa (useaa eri reittiÃ¤). Sovelluksen tulee toimia kahdessa vaiheessa. Ensin lentokentÃ¤n tyÃ¶ntekijÃ¤ syÃ¶ttÃ¤Ã¤ lentokoneiden ja lentojen tietoja hallintakÃ¤yttÃ¶liittymÃ¤ssÃ¤.</p>

  <p>Kun kÃ¤yttÃ¤jÃ¤ poistuu hallintakÃ¤yttÃ¶liittymÃ¤ssÃ¤, avautuu kÃ¤yttÃ¤jÃ¤lle mahdollisuus lentopalvelun kÃ¤yttÃ¶Ã¶n. Lentopalvelussa on kolme toimintoa; lentokoneiden tulostaminen, lentojen tulostaminen, ja lentokoneen tietojen tulostaminen. TÃ¤mÃ¤n lisÃ¤ksi kÃ¤yttÃ¤jÃ¤ voi poistua ohjelmasta valitsemalla vaihtoehdon <code>x</code>. Jos kÃ¤yttÃ¤jÃ¤ syÃ¶ttÃ¤Ã¤ epÃ¤kelvon komennon, kysytÃ¤Ã¤n komentoa uudestaan.</p>


<pre>
LentokentÃ¤n hallinta
--------------------

Valitse toiminto:
[1] LisÃ¤Ã¤ lentokone
[2] LisÃ¤Ã¤ lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lentokoneen kapasiteetti: <font color="red">42</font>
Valitse toiminto:
[1] LisÃ¤Ã¤ lentokone
[2] LisÃ¤Ã¤ lento
[x] Poistu hallintamoodista
> <font color="red">1</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lentokoneen kapasiteetti: <font color="red">101</font>
Valitse toiminto:
[1] LisÃ¤Ã¤ lentokone
[2] LisÃ¤Ã¤ lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lÃ¤htÃ¶paikan tunnus: <font color="red">HEL</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] LisÃ¤Ã¤ lentokone
[2] LisÃ¤Ã¤ lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">G-OWAC</font>
Anna lÃ¤htÃ¶paikan tunnus: <font color="red">JFK</font>
Anna kohdepaikan tunnus: <font color="red">BAL</font>
Valitse toiminto:
[1] LisÃ¤Ã¤ lentokone
[2] LisÃ¤Ã¤ lento
[x] Poistu hallintamoodista
> <font color="red">2</font>
Anna lentokoneen tunnus: <font color="red">HA-LOL</font>
Anna lÃ¤htÃ¶paikan tunnus: <font color="red">BAL</font>
Anna kohdepaikan tunnus: <font color="red">HEL</font>
Valitse toiminto:
[1] LisÃ¤Ã¤ lentokone
[2] LisÃ¤Ã¤ lento
[x] Poistu hallintamoodista
> <font color="red">x</font>

Lentopalvelu
------------

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">1</font>
G-OWAC (101 henkilÃ¶Ã¤)
HA-LOL (42 henkilÃ¶Ã¤)
Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">2</font>
HA-LOL (42 henkilÃ¶Ã¤) (HEL-BAL)
HA-LOL (42 henkilÃ¶Ã¤) (BAL-HEL)
G-OWAC (101 henkilÃ¶Ã¤) (JFK-BAL)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">3</font>
MikÃ¤ kone: <font color="red">G-OWAC</font>
G-OWAC (101 henkilÃ¶Ã¤)

Valitse toiminto:
[1] Tulosta lentokoneet
[2] Tulosta lennot
[3] Tulosta lentokoneen tiedot
[x] Lopeta
> <font color="red">x</font>
</pre>

<p><strong>Huom1:</strong> Testien kannalta on oleellista ettÃ¤ <em>kÃ¤yttÃ¶liittymÃ¤</em> toimii <b>tÃ¤smÃ¤lleen</b> kuten yllÃ¤ kuvattu. Ohjelman tulostamat menut kannattaneekin copypasteta tÃ¤stÃ¤ ohjelmakoodiin. Testit eivÃ¤t oleta, ettÃ¤ ohjelmasi on varautunut epÃ¤kelpoihin syÃ¶tteisiin. TÃ¤mÃ¤ tehtÃ¤vÃ¤ on kolmen yksittÃ¤isen tehtÃ¤vÃ¤pisteen arvoinen.</p>

<p><strong>Huom2:</strong> Ã¤lÃ¤ kÃ¤ytÃ¤ luokkein nimissÃ¤ skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

<p><em><strong>Ohjelman tulee kÃ¤ynnistyÃ¤ kun tehtÃ¤vÃ¤pohjassa oleva main-metodi suoritetaan.</strong></em></p>

<p><b>VielÃ¤ uudelleen varoitus:</b> jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. ÃlÃ¤ myÃ¶skÃ¤Ã¤n kÃ¤ytÃ¤ staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillÃ¤ suorituskerroilla jÃ¤Ã¤neet arvot todennÃ¤kÃ¶isesti hÃ¤iritsevÃ¤t testien toimintaa!</p>
</div>



<div class="tyhja"></div>

<div class="viikkoraja">Week 2</div>

<h2 id="object">Object</h2>

        <p>In our course, we have been using frequently the method <code>public String toString()</code> when we wanted to print an object in the shape of a string. Calling the method without setting it up properly does usually cause an error. We can have a look at the class <code>Book</code>, which does not contain the method <code>public String toString()</code> yet, and see what happens when the program uses the method <code>System.out.println()</code> and tries to print an object of <code>Book</code> class.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }
}
</pre>

<pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
</pre>

        <p>if we take an object of <code>Book</code> class and use it as the parameter of the method <code>System.out.println()</code>, our program does not print an error message. Our program does not crash, and instead of reading an error message, we notice an interesting print output. The print output contains the name of the lass, <code>Book</code>, plus an indefinite String which follows a @ character. Notice that when we call <code>System.out.println(objectBook)</code> Java calls <code>System.out.println(objectBook.toString())</code>, in fact, but this does not cause an error.</p>

        <p>The explenation is related to the way Java classes are built. Each Java class automatically <em>inherits</em> the <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">Object</a></code> class, which contains a set of methods that are useful to each Java class. Heritage means that our class has access to the features and functions defined in the inherited class. Among the others, the class <code>Object</code> contains the method <code>toString</code>, which is inherited by the classes we create.</p>

        <p>The <code>toString</code> method inherited from the object class is not usually the one we'd want. That's why we will want to <em>replace</em> it with one we make personally. Let us add the method <code>public String toString()</code> to our <code>Book</code> class. This method will replace the <code>toString</code> method inherited from the <code>Object</code> class.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }
}
</pre>

        <p>If now we create an object instance, and we set it into the print method, we notice that the <code>toString</code> method of the <code>Book</code> class produces a string.</p>

<pre class="sh_java">
Book objectBook = new Book("Object book", 2000);
System.out.println(objectBook);
</pre>

<pre>
Object book (2000)
</pre>

        <p>Above the <code>toString</code> method of class <code>Book</code> we see the <code>@Override</code> <em>annotation</em>. We use annotations to give guidelines to both the translator and the reader about how to relate to the methods. The <code>@Override</code> annotation tells that the following method replaces the one defined inside the inherited class. If we don't add an annotation to the method we replace, the translator gives us a <em>warning</em>, however avoiding writing annotations is not a mistake.</p>

        <p>There are also other useful methods we inherit from the <code>Object</code> class. Let us now get acquainted with the methods <code>equals</code> and <code>hashCode</code>.</p>

        <h3>Equals Method</h3>

        <p>The <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)" target="_blank">equals</a></code> method is used to compare two objects. The method is particularly used when we compare two <code>String</code> objects.</p>

<pre class="sh_java">
Scanner reader = new Scanner(System.in);

System.out.print("Write password: ");
String password = reader.nextLine();

if(password.equals("password")) {
    System.out.println("Right!");
} else {
    System.out.println("Wrong!");
}
</pre>

<pre>
Write password: <font color="red">mightycarrot</font>
Wrong!
</pre>

        <p>The <code>equals</code> method is defined in the <code>Object</code> class, and it makes sure that both the parameter object and the compared object have the same reference. In other words, by default the method makes sure that we are dealing with <em>one</em> unique object. If the reference is the same, the method returns <code>true</code>, otherwise <code>false</code>. The following example should clarify the concept. The class <code>Book</code> doesn't implement its own <code>equals</code> method, and therefore it uses the one created by the <code>Object</code> class.</p>

<pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = objectBook;

if (objectBook.equals(objectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}

// Now we create an object with the same contents, which is however a different, independent object
anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books were the same");
} else {
    System.out.println("The books were not the same");
}
</pre>

<p>Print output:</p>

<pre>
The books were the same
The books were not the same
</pre>

        <p>Even if the internal structure of both <code>Book</code> objects (i.e. the object variable values) is exactly the same, only the first comparison prints "<code>The books were the same</code>". This depends on the fact that only in the first case also the references were the same, i.e. we were comparing an object with itself. In the second example, we had two different objects even though they both had the same values.</p>

<p>When we use the <code>equals</code> method to compare strings, it works as we want it to: it identifies two strings as equal if the have the same <em>contents</em> even though they are two different objects. In fact, the default <code>equals</code> method is replaced with a new implementation in the String class.</p>

        <p>We want that book comparison happened against name and year. We replace the <code>equals</code> method in the <code>Object</code> class with an implementation in the <code>Book</code> class. The <code>equals</code> method has to make sure whether the object is the same as the one received as parameter. First, we define a method according to which all the objects are the same.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        return true;
    }
</pre>

        <p>Our method is a little too optimistic, so let us change its functionality slightly. Let us define that the objects are not the same if the parameter object is <em>null</em> or if the the two object types are different. We can find out the type of an object with the method <code>getClass()</code> (which is denifed in the <code>oject</code> class). Otherwise, we expect that the objects are the same.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (this.getClass() != object.getClass()) {
            return false;
        }

        return true;
    }
</pre>

        <p>The <code>equals</code>method finds out the class difference of two objects, but it is not able to distinguish two similar objects from each other. In order to compare our object with the object we received as parameter, and whose reference is <code>Object</code> type, we have to change the type of the Object reference. The reference type can be changed if and only if the object type is really such as we are converting it into. Type casting happens by specifying the desired class within brakets on the right side of the assignment sentence:</p>

<pre class="sh_java">
    WantedType variable = (WantedType) oldVariable;
</pre>

        <p>Type casting is possible because we know two objects are the same type. If they are different type, the above <code>getClass</code> method returns false. Let us change the <code>Object</code> parameter received with the <code>equals</code> method into <code>Book</code> type, and let us identify two different books against their publishing year. The books are otherwise the same.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if(this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        return true;
    }
</pre>

        <p>Now, our comparison method is able to distinguish books against their publishing year. Wa want to check still that our book names are the same, and our own book name is not <em>null</em>.</p>

<pre class="sh_java">
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
</pre>

        <p>Excellent, we have got a method for comparison which works, finally! Below is our <code>Book</code> class as it looks like at the moment.</p>

<pre class="sh_java">
public class Book {
    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }
}
</pre>

        <p>Now, our book comparison returns <code>true</code>, if the book contents are the same.</p>

<pre class="sh_java">
Book objectBook = new Book("Objectbook", 2000);
Book anotherObjectBook = new Book("Objectbook", 2000);

if (objectBook.equals(anotherObjectBook)) {
    System.out.println("The books are the same");
} else {
    System.out.println("The books are not the same");
}
</pre>

<pre>
The books are the same
</pre>

        <h4>Equals and ArrayList</h4>

        <p>Various different Java made-up methods make use of the <code>equals</code> method to implement their search functionality. For instance, the <code>contains</code> mehod of class <code>ArrayList</code> compares objects through the <code>equals</code> method. Let us continue to use the <code>Book</code> class we defied for our examples. If our objects do not implement the <code>equals</code> method, we can't use the <code>contains</code> method, for instance. Try out the code below in two different <code>book</code> classes. The first class implements the <code>equals</code> method, the other does not.</p>

<pre class="sh_java">
ArrayList&lt;Book&gt; kirjat = new ArrayList&lt;Book&gt;();
Book objectBook = new Book("Objectbook", 2000);
books.add(olioBook);

if (books.contains(objectBook)) {
    System.out.println("The object book was found.");
}

objectBook = new Book("Objectbook", 2000);

if (!books.contains(objectBook)) {
    System.out.println("The object book was not found.");
}
</pre>

        <h3>HashCode Method</h3>

        <p>The <code>hashCode</code> method takes an object and returns a numeric value, i.e. a hash value. We need numeric values for instance when we use and object as HashMap keys. So far, we have been using only String and Integer objects as HashMap keys, and their <code>hashCode</code> method is implemented by default. Let us make an example where it is not so: let us continue with our book examples and let us start to take note of our books on loan. We want to implement our bookkeeping through Hashmap. The key is the book, and the book's value is a string, which tells the loaner's name:</p>

<pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();
       
        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );
        
        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
</pre>

<p>Print output:</p>

<pre>
Pekka
null
null
</pre>

        <p>We can find the loaner by searching against the same object which was given as HashMap key with the <code>put</code> method. However, if our search item is the same book but a different object, we are not able to find its loaner and we are retured with a <em>null</em> reference. This is again due to the default implementation of the <code>hashCode</code> method of <code>Object</code> class. The default implementation creates an index based on the reference; this means that different objects with the same content receive different hashCode method outputs, and therefore it is not possible to find the right place of the object in the HashMap.</p>

        <p>To be sure the HashMap worked in the way we want - i.e. it returned the loaner when the key is an object with the right <em>content</em> (not necessarily the same object as the original value) - the class which works as key must overwrite both the <code>equals</code> method and the <code>hashCode</code> method. The method must be overwritten in such a way, so that it would assign the same numeric value to all objects which have the same content. Some objects with different content may eventually be assigned the same hashCode; however, different content objects should be assigned the same hashCode as rarely as possible, if we want our HashMap to be efficient.</p> 

<p>Previously, we have successfully used <code>String</code> objects as HashMap keys, and we can therefore say that the <code>String</code> class has got a <code>hashCode</code> implementation which works as expected. Let us <em>delegate</em> the calculation to the <code>String</code> object.</p>

<pre class="sh_java">
    public int hashCode() {
        return this.name.hashCode();
    }
</pre>

        <p>The solution above is quite good; but if <code>name</code> is <em>null</em>, we are thrown a <code>NullPointerException</code>. We can fix this by setting the condition: if the value of the <code>name</code> variable is is <em>null</em>, return value 7. Seven is a value chosen casually, thirteen could have done as well.</p>

<pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.name.hashCode();
    }
</pre>

<p>We can still improve the <code>hashCode</code> method by taking into consideration the book publishing year, in our calculations:</p>

<pre class="sh_java">
    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
</pre>


        <p>An additional remark: the output of the hashCode method of HashMap key objects tells us their value slot in the hash construction, i.e. their index in the HashMap. You may now be wondering: "doesn't this lead to a situation where more than one object ends up with the same index in the HashMap?". The answer is yes and no. Even if the <code>hashCode</code> method gave the same value to two different objects, HashMaps are built in such way that various different obejcts may have the same index. In order to distinguish objects with the same index, the key objects of the HashMap must have implemented the <code>equals</code> method. You will find more information about Hashmap implementation in the course <em>Data Structures and Algorithms</em>.</p>

        <p>The final <code>Book</code> class now.</p>

<pre class="sh_java">
public class Book {

    private String name;
    private int publishingYear;

    public Book(String name, int publishingYear) {
        this.name = name;
        this.publishingYear = publishingYear;
    }

    public String getName() {
        return this.name;
    }

    public int getPublishingYear() {
        return this.publishingYear;
    }

    @Override
    public String toString() {
        return this.name + " (" + this.publishingYear + ")";
    }

    @Override
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }

        if (getClass() != object.getClass()) {
            return false;
        }

        Book compared = (Book) object;

        if (this.publishingYear != compared.getPublishingYear()) {
            return false;
        }

        if (this.name == null || !this.name.equals(compared.getName())) {
            return false;
        }

        return true;
    }

    public int hashCode() {
        if (this.name == null) {
            return 7;
        }

        return this.publishingYear + this.name.hashCode();
    }
}
</pre>

<p><b>Let us sum up everything again:</b> in order to use a class as HashMap key, we have to define</p>
<ul>
<li>The <code>equals</code> method in a way that objects with the same content will return true when compared, whereas different-content objects shall return false</li>
<li>The <code>hashCode</code> method in a way that it assigns the same value to all the objects whose content is regarded as similar</li>
</ul>

<p>The equals and hashCode methods of our Book class fulfill these two conditions. Now, the problem we faced before is solved, and we can find out the book loaners:</p>

<pre class="sh_java">
        HashMap&lt;Book, String&gt; loaners = new HashMap&lt;Book, String&gt;();
       
        Book objectbook = new Book("Objectbook", 2000);
        loaners.put( objectbook, "Pekka" );
        loaners.put( new Book("Test Driven Development",1999), "Arto" );
        
        System.out.println( loaners.get( objectbook ) );
        System.out.println( loaners.get( new Book("Objectbook", 2000) );
        System.out.println( loaners.get( new Book("Test Driven Development", 1999) );
</pre>

<p>Print output:</p>

<pre>
Pekka
Pekka
Arto
</pre>

        <p><em>NetBeans allows for the authomatic creation of the <code>equals</code> and <code>hashCode</code> methods. You from the menu Source -> Insert Code, you can choose <em>equals() and hashCode()</em>. After this, NetBeans asks which object variables the methods shall use.</em></p>

        <div class="tehtavat" id="viikko8">

<NEXTWEEK></NEXTWEEK>

<h3>Autorekisterikeskus</h3>

<h4>Rekisterinumeron equals ja hashCode</h4>

<p>Eurooppalaiset rekisteritunnukset koostuvat kahdesta osasta: yksi tai kaksikirjaimisesta maatunnuksesta ja maakohtaisesti mÃ¤Ã¤rittyvÃ¤stÃ¤ rekisterinumerosta, joka taas koostuu numeroista ja merkeistÃ¤. Rekisterinumeroita esitetÃ¤Ã¤n seuraavanlaisen luokan avulla:</p>

<pre class="sh_java">
public class Rekisterinumero {
    // HUOM: oliomuuttujissa on mÃ¤Ã¤re final eli niiden arvoa ei voi muuttaa!
    private final String rekNro;
    private final String maa;

    public Rekisterinumero(String rekNro, String maa) {
       this.rekNro = rekNro;
       this.maa = maa;
    }

    public String toString(){
        return maa+ " "+rekNro;
    }
}
</pre>

<p>Rekisterinumeroja halutaan tallettaa esim. ArrayList:eille ja kÃ¤yttÃ¤Ã¤ HashMap:in avaimina, eli kuten yllÃ¤ mainittu, tulee niille toteuttaa 
metodit <code>equals</code> ja <code>hashCode</code>, muuten ne eivÃ¤t toimi halutulla tavalla. </p>

<p><strong>Vihje:</strong> ota equals- ja hashCode-metodeihin mallia yllÃ¤ olevasta Book-esimerkistÃ¤. Rekisterinumeron hashCode voidaan muodostaa esim. maatunnuksen ja rekNro:n hashCodejen summana.</p>

<p>Esimerkkiohjelma:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Rekisterinumero rek1 = new Rekisterinumero("FI", "ABC-123");
        Rekisterinumero rek2 = new Rekisterinumero("FI", "UXE-465");
        Rekisterinumero rek3 = new Rekisterinumero("D", "B WQ-431");

        ArrayList&lt;Rekisterinumero&gt; suomalaiset = new ArrayList&lt;Rekisterinumero&gt;();
        suomalaiset.add(rek1);
        suomalaiset.add(rek2);

        Rekisterinumero uusi = new Rekisterinumero("FI", "ABC-123");
        if (!suomalaiset.contains(uusi)) {
            suomalaiset.add(uusi);
        }
        System.out.println("suomalaiset: " + suomalaiset);
        // jos equals-metodia ei ole ylikirjoitettu, menee sama rekisterinumero toistamiseen listalle

        HashMap&lt;Rekisterinumero, String&gt; omistajat = new HashMap&lt;Rekisterinumero, String&gt;();
        omistajat.put(rek1, "Arto");
        omistajat.put(rek3, "JÃ¼rgen");

        System.out.println("omistajat:");
        System.out.println(omistajat.get(new Rekisterinumero("FI", "ABC-123")));
        System.out.println(omistajat.get(new Rekisterinumero("D", "B WQ-431")));
        // jos hashCode ei ole ylikirjoitettu, eivÃ¤t omistajat lÃ¶ydy
    }
</pre>

<p>Jos equals ja hashCode on toteutettu oikein, tulostus on seuraavanlainen</p>

<pre>
suomalaiset: [FI ABC-123, FI UXE-465]   
omistajat:
Arto
JÃ¼rgen

</pre>

<h4>Omistaja rekisterinumeron perusteella</h4>

<p>Toteuta luokka <code>Ajoneuvorekisteri</code> jolla on seuraavat metodit:</p>

<ul>
<li><code>public boolean lisaa(Rekisterinumero rekkari, String omistaja)</code> lisÃ¤Ã¤ parametrina olevaa rekisterinumeroa vastaavalle autolle parametrina olevan omistajan, metodi palauttaa true jos omistajaa ei ollut ennestÃ¤Ã¤n, jos rekisterinumeroa vastaavalla autolla oli jo omistaja, metodi palauttaa false ja ei tee mitÃ¤Ã¤n</li>
<li><code>public String hae(Rekisterinumero rekkari)</code> palauttaa parametrina olevaa rekisterinumeroa vastaavan auton omistajan. Jos auto ei ole rekisterissÃ¤, palautetaan <code>null</code></li>
<li><code>public boolean poista(Rekisterinumero rekkari)</code> poistaa parametrina olevaa rekisterinumeroa vastaavat tiedot, metodi palauttaa true jos tiedot poistetiin, ja false jos parametria vastaavia tietoja ei ollut rekisterissÃ¤</li>
</ul>

<p><strong>Huom:</strong> Ajoneuvorekisterin tÃ¤ytyy tallettaa omistajatiedot <code>HashMap&lt;Rekisterinumero, String&gt; omistajat</code> -tyyppiseen oliomuuttujaan!</p>

<h4>Ajoneuvorekisteri laajenee</h4>

<p>LisÃ¤Ã¤ Ajoneuvorekisteriin vielÃ¤ seuraavat metodit:</p>

<ul>
<li><code>public void tulostaRekisterinumerot()</code> tulostaa rekisterissÃ¤ olevat rekisterinumerot</li>
<li><code>public void tulostaOmistajat()</code> tulostaa rekisterissÃ¤ olevien autojen omistajat, yhden omistajan nimeÃ¤ ei saa tulostaa kuin kertaalleen vaikka omistajalla olisikin useampi auto</li>
</ul>

</div>

        <h2 id="rajapinta">Interface</h2>

        <p><em>Interface</em> is an instrument we have to define the functionality our classes should have. Interfaces are defined as normal Java classes, but instead of the definition "<code>public class ...</code>", we write "<code>public interface ...</code>". The interfaces influence class behaviour by defining the method names and return values, but they <em>do not containt method implementation</em>. The access modifier is not specified, because it is always <code>public</code>. Let us have a look at the interface <em>Readable</em>, which defines whether an object can be read.</p>

<pre class="sh_java">
public interface Readable {
    String read();
}
</pre>

        <p>The interface <code>Readable</code> defines the method <code>lue()</code>, which returns a string object. The classes which implement an interface decide <em>in which way</em> the methods defined in the interface have to be implemented, in the end. A class implements an interface by adding the keyword <em>implements</em> between the class and the interface name. Below, we create the class <code>SMS</code> which implements <code>Readable</code> interface.</p>

<pre class="sh_java">
public class SMS implements Readable {
    private String sender;
    private String content;

    public Tekstiviesti(String sender, String content) {
        this.sender = sender;
        this.sisalto = content;
    }

    public String getSender() {
        return this.sender;
    }

    public String read() {
        return this.content;
    }
}
</pre>

        <p>Because the class <code>SMS</code> implements the interface <code>Readable</code> (<code>public class SMS implements Readable</code>), the class <code>SMS</code> <em>must</em> implement the method <code>public String read()</code>. The implementations of methods defined in the interface must always have public access.</p>

        <p><em>An interface is a behavioural agreement. In order to implement the behaviour, the class must implement the methods defined by the interface. The programmer of a class which implements an interface has to define what the behaviour will be like. Implementing an interface means to agree that the class will offer all the actions defined by the interface, i.e. the behaviour defined by the interface. A class which implements an interface but does not implement some of the interface methods can not exist.</em></p>

        <p>Let us implement another class which implements the <code>Readable</code> interface, in addition to our <code>SMS</code> class. The class <code>EBook</code> is the electronic implementation of a book, and it contains the book name and page number. The EBook reads one page at time, and the <code>public String read()</code> method always returns the string of the following page.</p>

<pre class="sh_java">
public class EBook implements Readable {
    private String name;
    private ArrayList&lt;String&gt; pages;
    private int pageNumber;

    public Sahkokirja(String name, ArrayList&lt;String&gt; pages) {
        this.name = name;
        this.pages = pages;
        this.pageNumber = 0;
    }

    public String getName() {
        return this.name;
    }

    public int howManyPages() {
        return this.pages.size();
    }

    public String read() {
        String page = this.pages.get(this.pageNumber);
        nextPage();
        return page;
    }

    private void nextPage() {
        this.pageNumber = this.pageNumber + 1;
        if(this.pageNumber % this.pages.size() == 0) {
            this.pageNumber = 0;
        }
    }
}
</pre>

        <p>Classes which implement interfaces generate objects as well as normal classes, and they can be used as ArrayList types too.</p>

<pre class="sh_java">
    SMS message = new SMS("ope", "Awesome stuff!");
    System.out.println(message.read());

    ArrayList&lt;Tekstiviesti&gt; messages = new ArrayList&lt;Tekstiviesti&gt;();
    messages.add(new SMS("unknown number", "I hid the body.");
</pre>

<pre>Awesome stuff!</pre>

<pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    sivut.add("Split your method into short clear chunks.");
    sivut.add("Devide the user interface logic from the application logic.");
    sivut.add("At first, always code only a small program which solves only a part of the problem.");
    sivut.add("Practice makes perfect. Make up your own fun project.");

    EBook book = new EBook("Programming Hints.", pages);
    for(int page = 0; page < book.howManyPages(); page++) {
        System.out.println(book.read());
    }
</pre>

<pre>

Split your method into short clear chunks.
Divide the user interface logic from the application logic.
At first, always code only a small program which solves only a part of the problem.
Practice makes perfect. Make up your own fun project.
</pre>

<div class="tehtavat">

<h3>Palvelusvelvollinen</h3>

<p>TehtÃ¤vÃ¤pohjassa on valmiina rajapinta <code>Palvelusvelvollinen</code>, jossa on seuraavat toiminnot:</p>

  <ul>
    <li> metodi <code>int getTJ()</code> palauttaa jÃ¤ljellÃ¤ olevien palveluspÃ¤ivien mÃ¤Ã¤rÃ¤n</li>
    <li> metodi <code>void palvele()</code> vÃ¤hentÃ¤Ã¤ yhden palveluspÃ¤ivÃ¤n. PalveluspÃ¤ivien mÃ¤Ã¤rÃ¤ ei saa mennÃ¤ negatiiviseksi.</li>	
  </ul>

<pre class="sh_java">
public interface Palvelusvelvollinen {
    int getTJ();
    void palvele();
}
</pre>

<h4>Sivari</h4>

<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Sivari</code>, jolla parametriton konstruktori. Luokalla on oliomuuttuja TJ, joka alustetaan konstruktorikutsun yhteydessÃ¤ arvoon 362.</p>

<h4>Asevelvollinen</h4>

<p>Tee <code>Palvelusvelvollinen</code>-rajapinnan toteuttava luokka <code>Asevelvollinen</code>, jolla on parametrillinen konstruktori, jolla mÃ¤Ã¤ritellÃ¤Ã¤n palvelusaika (<code>int tj</code>).</p>
</div>


<h3>An Interface as Variable Type</h3>

        <p>When we create a new variable we always specify its type. There are two types of variable types: primitive-type variables (int, double, ...) and reference-type (all objects). As far as reference-type variables are concerned, their class has also been their type, so far.</p>

<pre class="sh_java">
    String string = "string-object";
    SMS message = new SMS("teacher", "Something crazy is going to happen");
</pre>

        <p>The type of an object can be different from its class. For instance, if a class implements the interface <code>Readable</code>, its type is <code>Readable</code>, too. For instance, since the class <code>SMS</code> implements the interface <code>Readable</code>, it has got two types: <code>SMS</code> and <code>Readable</code>.</p>

<pre class="sh_java">
    SMS message = new SMS("teacher", "Awesome stuff!");
    Readable readable = new SMS("teacher", "The SMS is Readable!");
</pre>

<pre class="sh_java">
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("A method can call itself.");

    Readable book = new EBook("Recursion Principles", pages);
    for(int page = 0; page < book.howManyPages(); page++) {
        System.out.println(book.read());
    }
</pre>

        <p>Because an interface can be used as type, it is possible to create a list containing interface-type objects.</p>

<pre class="sh_java">
    ArrayList&lt;Readable&gt; numberList = new ArrayList&lt;Readable&gt;();

    numberList.add(new SMS("teacher", "never been programming before..."));
    numberList.add(new SMS("teacher", "gonna love it i think!"));
    numberList.add(new SMS("teacher", "give me something more challenging! :)"));
    numberList.add(new SMS("teacher", "you think i can do it?"));
    numberList.add(new SMS("teacher", "up here we send several messages each day"));

    for (Readable readable: numberList) {
        System.out.println(readable.read());
    }
</pre>

        <p>The <code>EBook</code> class implements the interface <code>Readable</code>. However, notice that even though the type of the class <code>EBook</code> is an interface, <code>EBook</code> is not the type of all the classes which implement the <code>Readable</code> interface. It is possible to assign an <code>EBook</code> object to a <code>Readable</code> variable, but the assignment does not work in the opposite way without a particular type change.</p>

<pre class="sh_java">
    Readable readable = new Readable("teacher", "The SMS is Readable!"); // works
    SMS message = readable; // not possible

    SMS transformedMessage = (Message) Readable; // works
</pre>

        <p>Type casting works if and only if the variable's type is really what we try to change it into. Type casting is not usually a best practice; one of the only cases where that is legitimate is in connection with the <code>equals</code> method.</p>

        <h3>An Interface as Method Parameter</h3>

        <p>The real use of interfaces becomes clear when we use them for the type of a method parameter. Because interfaces can be used as variable type, they can be used in method calls as parameter type. For instance, the below method <code>print</code> of class <ode>Printer</code> receives a <code>Readable</code> variable.</p>

<pre class="sh_java">
public class Printer {
    public void print(Readable readable) {
        System.out.println(readable.read());
    }
}
</pre>

        <p>The real value of the <code>print</code> method of class <code>Printer</code> is that it's parameter can be <em>whatever</em> class instance which implements our <code>Readable</code> interface. When we call the method of an object, the method will work regardless of the class of this object, as long as the object implements Readable.</p>

<pre class="sh_java">
    SMS message = new SMS("teacher", "Huhhuh, this printer is able to print them, actually!");
    ArrayList&lt;String&gt; pages = new ArrayList&lt;String&gt;();
    pages.add("{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.");

    EBook book = new EBook("Introduction to University Mathematics.", pages);

    Printer printer = new Printer();
    printer.print(SMS);
    printer.print(book);
</pre>

<pre>
Huhhuh, this printer is able to print them, actually!
{3, 5} are the numbers in common between {1, 3, 5} and {2, 3, 4, 5}.
</pre>

        <p>Let us implement another <code>numberList</code> class, where we can add interesting readable stuff. The class has got an <code>ArrayList</code> instance as object variable where we save things to read. We add items to our number list through the <code>add</code> method which receives a <code>Readable</code> variable as parameter.</p>

<pre class="sh_java">
public class NumberList {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }
}
</pre>

        <p>Number lists are usually readable, so we can implement the <code>Readable</code> interface to the <code>NumberList</code> class. The number list <code>read</code> method reads all the objects of the <code>readables</code> list, and it adds them one by one to a string which is returned by the <code>read()</code> method.</p>

<pre class="sh_java">
public class NumberList implements Readable {
    private ArrayList&lt;Readable&gt; readables;

    public NumberList() {
        this.readables = new ArrayList&lt;Readable&gt;();
    }

    public void add(Readable readable) {
        this.readables.add(readable);
    }

    public int howManyReadables() {
        return this.readables.size();
    }

    public String read() {
        String read = "";
        for(Readable readable: this.readables) {
            read += readable.read() + "\n";
        }

        this.readables.clear();
        return read;
    }
}
</pre>

<pre class="sh_java">
    NumberList myList = new NumberList();
    joelList.lisaa(new SMS("matti", "have you already written the tests?"));
    joelList.lisaa(new SMS("matti", "did you have a look at the submissions?"));

    System.out.println("Joel has got " + joelList.howManyReadables() + " messages to read");
</pre>

<pre>
Joel has got got 2 messages to read
</pre>

        <p>Because the type of <code>NumerList</code> is <code>Readable</code>, we can add <code>NumerList</code> objects to our number list, too. In the example below, Joel has got a lot of messages to read, luckily Mikael deals with it and reads the messages on behalf of Joel.</p>

<pre class="sh_java">
    NumberList joelList = new NumberList();
    for (int i = 0; i < 1000; i++) {
        joelList.lisaa(new SMS("matti", "have you already written the tests?"));
    }

    System.out.println("Joel has got " + joelList.howManyReadables() + " messages to read");
    System.out.println("Let's delegate some reading to Mikael");

    NumberList mikaelList = new NumberList();
    mikaelList.add(joelList);
    mikaelList.read();

    System.out.println();
    System.out.println("Joel has got " + joelList.howManyReadables() + " messages to read");
</pre>

<pre>
Joel has got 1000 messages to read
Delegoidaan lukeminen Mikaelille

Joel has got 0 messages to read
</pre>

        <p>The <cide>read</code> method which is called in connection to Mikael's list parses all the <code>Readable</code> objects contained in the list, and calls their <code>read</code> method. At the end of each <code>read</code> method call the list is cleared. In other words, Joel's number list is cleared as soon as Mikael reads it.</p>

        <p><em>At this point, there are a lot of references; it would be good to draw down the objects and try to grasp how the <code>read</code> method call connected to <code>mikaelList</code> works!</em></p>

<div class="tehtavat">

  <h3>Tavaroita ja laatikoita</h3>

  <h4 class="req">Talletettavia</h4>

  <p>Muuton yhteydessa tarvitaan muuttolaatikoita. Laatikoihin talletetaan erilaisia esineitÃ¤. Kaikkien laatikoihin talletettavien esineiden on toteutettava seuraava rajapinta:</p>

<pre class="sh_java">
public interface Talletettava {
    double paino();
}
</pre>

  <p>LisÃ¤Ã¤ rajapinta ohjelmaasi. Rajapinta lisÃ¤tÃ¤Ã¤n melkein samalla tavalla kuin luokka, <i>new Java class</i> sijaan valitaan <i>new Java interface</i>.</p>

  <p>Tee rajapinnan toteuttavat luokat <code>Book</code> ja <code>CDLevy</code>. Book saa konstruktorin parametreina kirjan kirjoittajan (String), kirjan nimen (String), ja kirjan painon (double). CD-Levyn konstruktorin parametreina annetaan artisti (String), levyn nimi (String), ja julkaisuvuosi (int). Kaikkien CD-levyjen paino on 0.1 kg.</p>

  <p>Muista toteuttaa luokilla myÃ¶s rajapinta <code>Talletettava</code>. Luokkien tulee toimia seuraavasti:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Book kirja1 = new Book("Fedor Dostojevski", "Rikos ja Rangaistus", 2);
        Book kirja2 = new Book("Robert Martin", "Clean Code", 1);
        Book kirja3 = new Book("Kent Beck", "Test Driven Development", 0.5);

        CDLevy cd1 = new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973);
        CDLevy cd2 = new CDLevy("Wigwam", "Nuclear Nightclub", 1975);
        CDLevy cd3 = new CDLevy("Rendezvous Park", "Closer to Being Here", 2012);

        System.out.println(kirja1);
        System.out.println(kirja2);
        System.out.println(kirja3);
        System.out.println(cd1);
        System.out.println(cd2);
        System.out.println(cd3);
    }
</pre>

  <p>Tulostus:</p>

<pre>
Fedor Dostojevski: Rikos ja Rangaistus
Robert Martin: Clean Code
Kent Beck: Test Driven Development
Pink Floyd: Dark Side of the Moon (1973)
Wigwam: Nuclear Nightclub (1975)
Rendezvous Park: Closer to Being Here (2012)
</pre>

  <p>Huom! Painoa ei ilmoiteta tulostuksessa.</p>

<h4 class="req">Laatikko</h4>

  <p>Tee luokka laatikko, jonka sisÃ¤lle voidaan tallettaa <code>Talletettava</code>-rajapinnan toteuttavia tavaroita. Laatikko saa konstruktorissaan parametrina laatikon maksimikapasiteetin kiloina. Laatikkoon ei saa lisÃ¤tÃ¤ enempÃ¤Ã¤ tavaraa kuin sen maksimikapasiteetti mÃ¤Ã¤rÃ¤Ã¤. Laatikon sisÃ¤ltÃ¤mien tavaroiden paino ei siis koskaan saa olla yli laatikon maksimikapasiteetin.</p>

  <p>Seuraavassa esimerkki laatikon kÃ¤ytÃ¶stÃ¤:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Laatikko laatikko = new Laatikko(10);

        laatikko.lisaa( new Book("Fedor Dostojevski", "Rikos ja Rangaistus", 2) ) ;
        laatikko.lisaa( new Book("Robert Martin", "Clean Code", 1) );
        laatikko.lisaa( new Book("Kent Beck", "Test Driven Development", 0.7) );

        laatikko.lisaa( new CDLevy("Pink Floyd", "Dark Side of the Moon", 1973) );
        laatikko.lisaa( new CDLevy("Wigwam", "Nuclear Nightclub", 1975) );
        laatikko.lisaa( new CDLevy("Rendezvous Park", "Closer to Being Here", 2012) );

        System.out.println( laatikko );
    }
</pre>

  <p>Tulostuu</p>

<pre>
Laatikko: 6 esinettÃ¤, paino yhteensÃ¤ 4.0 kiloa
</pre>

<p>Huom: koska painot esitetÃ¤Ã¤n doubleina, saattaa laskutoimituksissa tulla pieniÃ¤ pyÃ¶ristysvirheitÃ¤. TehtÃ¤vÃ¤ssÃ¤ ei tarvitse vÃ¤littÃ¤Ã¤ niistÃ¤.</p>

<h4 class="req">Laatikon paino</h4>

  <p>Jos teit laatikon sisÃ¤lle oliomuuttujan <code>double paino</code>, joka muistaa laatikossa olevien esineiden painon, korvaa se metodilla, joka laskee painon:</p>

<pre class="sh_java">
public class Laatikko {
    //...

    public double paino() {
        double paino = 0;
        // laske laatikkoon talletettujen tavaroiden yhteispaino
        return paino;
    }
}
</pre>

  <p>Kun tarvitset laatikon sisÃ¤llÃ¤ painoa esim. uuden tavaran lisÃ¤yksen yhteydessÃ¤, riittÃ¤Ã¤ siis kutsua laatikon painon laskevaa metodia.</p>

  <p>Metodi toki voisi palauttaa myÃ¶s oliomuuttujan arvon. Harjoittelemme tÃ¤ssÃ¤ kuitenkin tilannetta, jossa oliomuuttujaa ei tarvitse eksplisiittisesti yllÃ¤pitÃ¤Ã¤ vaan se voidaan tarpeentullen laskea. Seuraavan tehtÃ¤vÃ¤n jÃ¤lkeen laatikossa olevaan oliomuuttujaan talletettu painotieto ei kuitenkaan vÃ¤lttÃ¤mÃ¤ttÃ¤ enÃ¤Ã¤ toimisi. Miksi? </p>

  <h4 class="req">Laatikkokin on talletettava!</h4>

  <p>Rajapinnan <code>Talletettava</code> toteuttaminen siis edellyttÃ¤Ã¤ ettÃ¤ luokalla on metodi <code>double paino()</code>. Laatikollehan lisÃ¤ttiin juuri tÃ¤mÃ¤ metodi. Laatikosta voidaan siis tehdÃ¤ talletettava!</p>

  <p>Laatikot ovat oliota joihin voidaan laittaa <code>Talletettava</code>-rajapinnan toteuttavia olioita. Laatikot toteuttavat itsekin rajapinnan. Eli <b>laatikon sisÃ¤llÃ¤ voi olla myÃ¶s laatikoita!</b></p>

  <p>Kokeile ettÃ¤ nÃ¤in varmasti on, eli tee ohjelmassasi muutama laatikko, laita laatikoihin tavaroita ja laita pienempiÃ¤ laatikoita isompien laatikoiden sisÃ¤Ã¤n. Kokeile myÃ¶s mitÃ¤ tapahtuu kun laitat laatikon itsensÃ¤ sisÃ¤lle. Miksi nÃ¤in kÃ¤y?</p>
</div>

<h3>An Interface as Method Return Value</h3>

        <p>As well as any other variable type, an interface can also be used as method return value. Below you find <code>Factory</code>, which can be used to produce different objects that implement the interface <code>Item</code>. In the beginning, Factory produces books and disks at random.</p>

<pre class="sh_java">
   public class Factory {
      public Factory(){
          // Attention: it is not necessary to write an empty constructor if there are no other constructors in the class. 
	  // In such cases, Java creates a default constructor, i.e a constructor without parameter 
      }

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(4);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           }      
       }
   }
</pre>

<p>It is possible to use our Fabric without knowing precisely what kind of classes are present in it, as long as they all implement Item. Below you find the class <code>Packer</code> which can be used to get a boxful of items. The Packer knows the fabric which produces its Items:</p>

<pre class="sh_java">
   public class Packer {
       private Fabric fabric; 

       public Packer(){
            fabric = new Fabric();
       }

       public Box giveABoxful() {
            Box box = new Box(100);
             
            for ( int i=0; i &lt; 10; i++ ) {
                Iteam newItem = fabric.produceNew();
                box.add(newItem);
            }
  
            return box;
       }
   }
</pre>

<p>Because the packer doesn't know the classes which implement the Item interface, it is possble to add new classes which implement the interface without having to modify the packer. Below, we create a new class which implements our Item interface - <code>ChocolateBar</code>. Our Fabric was modified to produce chocolate bars in addition to books and CDs. The class <code>Packer</code> works fine with the extended fabric version, without having to change it.</p>

<pre class="sh_java">
   public class ChocolateBar implements Item {
      // we don't need a constructor because Java is able to generate a default one! 

      public double weight(){
         return 0.2;
      }
   }

   public class Fabric {
      // we don't need a constructor because Java is able to generate a default one! 

       public Item produceNew(){
           Random random = new Random();
           int num = random.nextInt(5);
           if ( num==0 ) {
               return new CD("Pink Floyd", "Dark Side of the Moon", 1973);
           } else if ( num==1 ) {
               return new CD("Wigwam", "Nuclear Nightclub", 1975);
           } else if ( num==2 ) {
               return new Book("Robert Martin", "Clean Code", 1 );
           } else if ( num==3 ) {
               return new Book("Kent Beck", "Test Driven Development", 0.7);
           } else {
               return new ChocolateBar();
           }     
       }
   }
</pre>


  <p><em>Using interfaces while programming permits us to reduce the number of dependences among our classes. In our example, Packer is not dependent on the classes which implement Item interface, it is only dependent on the interface itself. This allows us to add classes wihout having to change the class Packer, as long as they implement our interface. We can even add classes that implement the interface to the methods which make use of our packer without compromising the process. In fact, less dependences make it easy to extend a program.</em></p>



<p>We can imlement now the classes <code>PieceOfNews</code> and <code>NewsService</code>; the first reports a singular piece of news, and the second produces the news to be read. The code which makes use of our news service does not have to know the actual news implementation, and that is not even sensible. The only essencial thing is that the program is able to read the news. In fact, the news service can submit its news through the <code>Readable</code> interface.</p>

<pre class="sh_java">
public class PieceOfNews implements Readable {
    private String text;

    public PieceOfNews(String text) {
        this.text = text;
    }

    public String read() {
        return this.text;
    }
}
</pre>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot Topics!");
    }
}
</pre>

        <p>The news service always submits a <code>Readable</code> interface object. At this point, people often wonder a simple question: "<code>Why shouldn't we simply use the class PieceOfNews?</code>". The answer is quite long but hopefully it will clear the idea behind this.</p>

        <p>Let us think about a situation where we have a <code>Publisher</code> which publishes news. The publisher has to read the news from the NewsService regularly, and print out the messages (the Publisher could send the message to different media, but let's stick to a basic example). Let us suppose that NewsService returns PieceOfNews objects.</p>

<pre class="sh_java">
public class NewsService {

    public Luettava getLatestNews() {
        return new PieceOfNews("Latest Hot News!");
    }
}
</pre>

        <p>Publisher's essential functionality is a loop, which calls the method <code>getLatestNews</code> with regular intermissions.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            PieceOfNews news = newsService.getLatestNews();
            System.out.println(news.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>So far, everything works well. We can now suppose our CEO notices that they need a new format for graphic news. Thus, we create a different class called <code>GraphicPieceOfNews</code>. GraphicPieceOfNews is readable so our NewsService programmer make it implement our Readable interface.</p>

<pre class="sh_java">
public class GraphicPieceOfNews implements Readable {
    private String imageAddress;
    private String text;

    public GraphicPieceOfNews(String text, String imageAddress) {
        this.text = text;
        this.imageAddress = imageAddress;
    }

    public String read() {
        return this.text + " (image address: " + this.imageAddress + ")";
    }
}
</pre>

        <p>Meanwhile, they also have to modify NewsService class, because it doesn't support the new news format: </p>

<pre class="sh_java">
public class NewsService {

    public GraphicPieceOfNews getLatestNews() {
        return new GraphicPieceOfNews("Latest Hot News!", "image address");
    }
}
</pre>

        <p>Now <em>we have to</em> modify our Publisher. In fact, it does not work any more because it returns an instance of the class <code>GraphicPieceOfNews<code>. How many classes we would have to modify if the news service used ten services, and what about one thousand? At this point <em>each</em> implementation which used our news service should change its own functionality.</p>

        <p>And what about if not all the pieces of news contained photos, and sometimes we wanted to return a <code>PieceOfNews</code> class instance? The method above, <code>getLatestNews</code>, may not be enough.</p>

        <p>Let's go back to our news format change, where the return type of the news service method <code>getLatestNews</code> is <code>Readable</code>.</p>


<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new PieceOfNews("The Latest Hot News!");
    }
}
</pre>

        <p>If the news service CEO wanted to get a new image format, we would not need to modify the <code>getLatestNews</code> method at all.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        return new GraphicPieceOfNews("THe Latest Hot News!", "Photo's address");
    }
}
</pre>

        <p>Not even the Publisher would need any modification.</p>

<pre class="sh_java">
public class Publisher {
    private NewsService newsService;

    public Publisher() {
        this.newsService = new NewsService();
    }

    public void start() {
        while (true) {
            Readable readable = newsService.GraphicPieceOfNews();
            System.out.println(readable.read());

            try {
                Thread.sleep(10000);
            } catch (Exception e) {
            }
        }
    }
}
</pre>

        <p>How many classes should we have modified if our news service offered ten services, and what about one thousand? Zero. And what about if our news service wanted to send sometimes normal news and sometimes graphic news? Easy! We only need to change our news service.</p>

<pre class="sh_java">
public class NewsService {

    public Readable getLatestNews() {
        Random random = new Random();

        if(random.nextDouble() > 0.5) {
            return new PieceOfNews("The Latest Hot News!");
        }

        return new GraphicPieceOfNews("The Latest Hot News!", "photo's address");
    }
}
</pre>

    <p>Even in this case we don't need to change the implementations which make use of our NewsService.</p>


    <p><em>Coding to interface allows for reducing the dependences. If all the services which make use of our news service were coded to the interface Readable, they would not be dependent on any particular class which implements the Readable interface. In the wxamples above, the internal implementation of the news service can be modified so that the modifications would not affect the objects which make use of the news service, in any way.</em></p>



    <h3>Made-Up Interfaces</h3>

    <p>Java API offers a sensible number of made-up interfaces. Below, we get to know some of Java's most used interfaces: <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html" target="_blank">List</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html" target="_blank">Map</a></code>, <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> and <code><a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a></code>.</p>

    <h4>List</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List</a> interface defines lists basic functionality. Because the class ArrayList implements the <code>List</code> interface, it can also be initialized through the <code>List</code> interface.</p>

<pre class="sh_java">
List&lt;String&gt; strings = new ArrayList&lt;String&gt;();
strings.add("A String object within an ArrayList object!");
</pre>

    <p>As we notice from the <a href="http://download.oracle.com/javase/6/docs/api/java/util/List.html">List interface Java API</a>, there are a lot of classes which implement the interface <code>List</code>. A list construction which is familiar to hakers like us is the <a href="http://docs.oracle.com/javase/6/docs/api/java/util/LinkedList.html" target="_blank">linked list</a>. A linked list can be used through the List interface in the same way as the objects created from ArrayList.</p>

<pre class="sh_java">
List&lt;String&gt; strings = new LinkedList&lt;String&gt;();
strings.add("A string object within a LinkedList object!");
</pre>

    <p>Both implementations of the <code>List</code> interface work in the same way, in the user point of view. In fact, the interface <em>abstracts</em> their internal functionality. ArrayList and linkedList internal construction is evidently different, anyway. ArrayList saves the objects into a table, and the search is quick with a specific index. Differently, LinkedList builds up a list where each item has got a reference to the following item. When we search for an item in a linked list, we have to go through all the list items till we reach the index.</p>

    <p>When it comes to bigger lists, we can point out more than evident performance differences. LinkedList's strength is that adding new items is always fast. Differently, behind ArrayList there is a table which grows as it fills up. Increasing the size of the table means creating a new one and copying there the information of the old. However, searching against an index is extremely fast with an ArrayList, whereas we have to go thourgh all the list elements one by one before reaching the one we want, with a LinkedList. More information about data structures such as ArrayList and LinkedList internal implementation comes with the course <em>Data structures and algorithms</em>.</p>

    <p>In our programming course you will rather want to choose ArrayList, in fact. Programming to interface is worth of it, anyway: implement your program so that you'll use data structures via interfaces.</p>

    <h4>Map</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Map.html">Map</a> Interface defines HashMap basic fuctionality. Because HashMaps implement the <code>Map</code> interface, it is possible to initialize them trough the <code>Map</code> interface.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
kaannokset.put("gambatte", "tsemppiÃ¤");
kaannokset.put("hai", "kyllÃ¤");
</pre>

    <p>You get HashMap keys thourgh the method <code>keySet</code>.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

for(String key: translations.keySet()) {
    System.out.println(key + ": " + translations.get(key));
}
</pre>

<pre>
gambatte: good luck
hai: yes
</pre>

    <p>The <code>keySet</code> method returns a set made of keys which implement <code>Set</code> interface. The set which implement the <code>Set</code> interface can be parsed with a for-each loop. HashMap values are retrieved through the <code>values</code> method, which returns a set of values which implement the <code>Collection</code> interface. We should now focus on Set and Collection interfaces.</p>

    <h4>Set</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a> interface defines the functionality of Java's sets. Java's sets always contain 0 or 1 element of a certain type. Among the others, <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code> is one of the classes which implement the Set interface. We can parse a key set through a for-each loop, in the following way</p>

<pre class="sh_java">
Set&lt;String&gt; set = new HashSet&lt;String&gt;();
set.add("one");
set.add("one");
set.add("two");

for (String key: set) {
    System.out.println(key);
}
</pre>

<pre>
one
two
</pre>

    <p>Notice that HashSet is not concerned on the order of its keys.</p>

    <h4>Collection</h4>

    <p>The <a href="http://download.oracle.com/javase/6/docs/api/java/util/Collection.html" target="_blank">Collection</a> interface defines the functionality of collections. Among the others, Java's lists and sets are collections -- that is, List and Set interfaces implement the Collection interface. Collection interface provides methods to check object existence (the <code>contains</code> method) and to check the collection size (<code>size</code> method). We can parse any class which implements the Collection interface with a <code>for-each</code> loop. </p>

    <p>We now create a HashMap and parse first its keys, and then its values.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

Set&lt;String&gt; keys = translations.keySet();
Collection&lt;String&gt; keySet = keys;

System.out.println("Keys:");
for(String key: keySet) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
Collection&lt;String&gt; values = translations.values();
for(String value: values) {
    System.out.println(value);
}
</pre>

<pre>
Keys:
gambatte
hai

Values:
yes
good luck
</pre>


    <p>The following example would have produced the same output, too.</p>

<pre class="sh_java">
Map&lt;String, String&gt; translations = new HashMap&lt;String, String&gt;();
translations.put("gambatte", "good luck");
translations.put("hai", "yes");

System.out.println("Keys:");
for(String key: translations.keySet()) {
    System.out.println(key);
}

System.out.println();
System.out.println("Values:");
for(String value: translations.values()) {
    System.out.println(value);
}
</pre>

    <p>In the following excercise we build an online shop, and we train to use classes through their interfaces.</p>

<div class="tehtavat">
  <h3>Verkkokauppa</h3>

  <p>Teemme tehtÃ¤vÃ¤ssÃ¤ muutamia verkkokaupan hallinnointiin soveltuvia ohjelmakomponentteja.</p>

  <h4>Varasto</h4>

  <p>Tee luokka Varasto jolla on seuraavat metodit:</p>

  <ul>
    <li><code>public void lisaaTuote(String tuote, int hinta, int saldo)</code> lisÃ¤Ã¤ varastoon tuotteen jonka hinta ja varastosaldo ovat parametrina annetut values</li>
    <li><code>public int hinta(String tuote)</code> palauttaa parametrina olevan tuotteen hinnan, jos tuotetta ei ole varastossa, palauttaa metodi -99</li>
  </ul>


  <p>Varaston sisÃ¤llÃ¤ tuotteiden hinnat (ja seuraavassa kohdassa saldot) tulee tallettaa <code>Map&lt;String, Integer&gt;</code>-tyyppiseksi mÃ¤Ã¤riteltyyn muuttujaan! Luotava olio voi olla tyypiltÃ¤Ã¤n <code>HashMap</code>, muuttujan tyyppinÃ¤ on kuitenkin kÃ¤ytettÃ¤vÃ¤ <code>Map</code>-rajapintaa (ks. <a href="#46.4.2">46.4.2.</a>)</p>

  <p>Seuraavassa esimerkki varaston kÃ¤ytÃ¶stÃ¤:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 7);

        System.out.println("hinnat:");
        System.out.println("maito:  " + varasto.hinta("maito"));
        System.out.println("kahvi:  " + varasto.hinta("kahvi"));
        System.out.println("sokeri: " + varasto.hinta("sokeri"));
</pre>

<p>Tulostuu:</p>

<pre>
hinnat:
maito:  3
kahvi:  5
sokeri: -99
</pre>

<h4>Tuotteen varastosaldo</h4>

  <p>Talleta tuotteiden varastosaldot samaan tapaan <code>Map&lt;String, Integer&gt;</code>-tyyppiseen muuttujaan kuin talletit hinnat. TÃ¤ydennÃ¤ varastoa seuraavilla metodeilla:</p>

  <ul>
    <li><code>public int saldo(String tuote)</code> palauttaa parametrina olevan tuotteen varastosaldon.</li>
    <li><code>public boolean ota(String tuote)</code> vÃ¤hentÃ¤Ã¤ parametrina olevan tuotteen saldoa yhdellÃ¤ ja palauuttaa <em>true</em> jos tuotetta oli varastossa. Jos tuotetta ei ole varastossa, palauttaa metodi <em>false</em>, tuotteen saldo ei saa laskea alle nollan.</li>
  </ul>


  <p>Esimerkki varaston kÃ¤ytÃ¶stÃ¤:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("kahvi", 5, 1);

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));

        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan kahvi " + varasto.ota("kahvi"));
        System.out.println("otetaan sokeri " + varasto.ota("sokeri"));

        System.out.println("saldot:");
        System.out.println("kahvi:  " + varasto.saldo("kahvi"));
        System.out.println("sokeri: " + varasto.saldo("sokeri"));
</pre>

<p>Tulostuu:</p>

<pre>
saldot:
kahvi:  1
sokeri: 0
otetaan kahvi true
otetaan kahvi false
otetaan sokeri false
saldot:
kahvi:  0
sokeri: 0
</pre>

<h4>Tuotteiden listaus</h4>

  <p>ListÃ¤tÃ¤Ã¤n varastolle vielÃ¤ yksi metodi:</p>

  <ul>
    <li><code>public Set&lt;String&gt; tuotteet()</code> palauttaa <em>joukkona</em> varastossa olevien tuotteiden nimet</li>
  </ul>

  <p>Metodi on helppo toteuttaa. Saat tietoon varastossa olevat tuotteet kysymÃ¤llÃ¤ ne joko hinnat tai saldot muistavalta Map:iltÃ¤ metodin <code>keySet</code> avulla.</p>

<p>Esimerkki varaston kÃ¤ytÃ¶stÃ¤:</p>

<pre class="sh_java">
        Varasto varasto = new Varasto();
        varasto.lisaaTuote("maito", 3, 10);
        varasto.lisaaTuote("kahvi", 5, 6);
        varasto.lisaaTuote("piimÃ¤", 2, 20);
        varasto.lisaaTuote("jugurtti", 2, 20);

        System.out.println("tuotteet:");
        for (String tuote : varasto.tuotteet()) {
            System.out.println(tuote);
        }
</pre>

<p>Tulostuu:</p>

<pre>
tuotteet:
piimÃ¤
jugurtti
kahvi
maito
</pre>

<h4>Ostos</h4>

  <p>Ostoskoriin lisÃ¤tÃ¤Ã¤n <em>ostoksia</em>. Ostoksella tarkoitetaan tiettyÃ¤ mÃ¤Ã¤rÃ¤Ã¤ tiettyjÃ¤ tuotteita. Koriin voidaan laittaa esim. ostos joka vastaa yhtÃ¤ leipÃ¤Ã¤ tai ostos joka vastaa 24:Ã¤Ã¤ kahvia.</p>

  <p>Tee luokka <code>Ostos</code> jolla on seuraavat toiminnot:</p>

  <ul>
    <li><code>public Ostos(String tuote, int kpl, int yksikkohinta)</code> konstruktori joka luo ostoksen joka vastaa parametrina annettua tuotetta. Tuotteita ostoksessa on <em>kpl</em> kappaletta ja yhden tuotteen hinta on kolmantena parametrina annettu <em>yksikkohinta</em></li>
    <li><code>public int hinta()</code> palauttaa ostoksen hinnan. Hinta saadaan kertomalla kappalemÃ¤Ã¤rÃ¤ yksikkÃ¶hinnalla</li>
    <li><code>public void kasvataMaaraa()</code> kasvattaa ostoksen kappalemÃ¤Ã¤rÃ¤Ã¤ yhdellÃ¤</li>
    <li><code>public String toString()</code> palauttaa ostoksen characterStringmuodossa, joka on alla olevan esimerkin mukainen</li>
  </ul>

  <p>Esimerkki ostoksen kÃ¤ytÃ¶stÃ¤</p>

<pre class="sh_java">
        Ostos ostos = new Ostos("maito", 4, 2);
        System.out.println( "ostoksen joka sisÃ¤ltÃ¤Ã¤ 4 maitoa yhteishinta on " + ostos.hinta() );
        System.out.println( ostos );
        ostos.kasvataMaaraa();
        System.out.println( ostos );
</pre>

<p>Tulostuu:</p>

<pre>
ostoksen joka sisÃ¤ltÃ¤Ã¤ 4 maitoa yhteishinta on 8
maito: 4
maito: 5
</pre>

  <p>Huom: <em>toString</em> on siis muotoa <em>tuote: kpl</em> hintaa ei characterStringesitykseen tule!</p>

<h4>Ostoskori</h4>

  <p>Vihdoin pÃ¤Ã¤semme toteuttamaan luokan ostoskori!</p>

  <p>Ostoskori tallettaa sisÃ¤isesti koriin lisÃ¤tyt tuotteet <em>Ostos-olioina</em>. Ostoskorilla tulee olla oliomuuttuja jonka tyyppi on joko <code>Map&lt;String, Ostos&gt;</code> tai <code>List&lt;Ostos&gt;</code>. ÃlÃ¤ laita mitÃ¤Ã¤n muita oliomuuttujia ostoskorille kuin ostosten talletukseen tarvittava Map tai List.</p>

  <p>Huom: jos talletat Ostos-oliot Map-tyyppiseen apumuuttujaan, on tÃ¤ssÃ¤ ja seuraavassa tehtÃ¤vÃ¤ssÃ¤ hyÃ¶tyÃ¤ Map:in metodista values(), jonka avulla on helppo kÃ¤ydÃ¤ lÃ¤pi kaikki talletetut ostos-oliot.</p>

  <p>TehdÃ¤Ã¤n aluksi ostoskorille parametriton konstruktori ja metodit:</p>

  <ul>
    <li><code>public void lisaa(String tuote, int hinta)</code> lisÃ¤Ã¤ ostoskoriin ostoksen joka vastaa parametrina olevaa tuotetta ja jolla on parametrina annettu hinta.</li>
    <li><code>public int hinta()</code> palauttaa ostoskorin kokonaishinnan</li>
</ul>

<p>Esimerkki ostoksen kÃ¤ytÃ¶stÃ¤</p>

<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.lisaa("piimÃ¤", 2);
        kori.lisaa("juusto", 5);
        System.out.println("korin hinta: " + kori.hinta());
        kori.lisaa("tietokone", 899);
        System.out.println("korin hinta: " + kori.hinta());
</pre>

<p>Tulostuu:</p>

<pre>
korin hinta: 10
korin hinta: 909
</pre>

<h4>Ostoskorin tulostus</h4>

  <p>TehdÃ¤Ã¤n ostoskorille metodi <code>public void tulosta()</code> joka tulostaa korin sisÃ¤ltÃ¤mÃ¤t <em>Ostos</em>-oliot. TulostusjÃ¤rjestyksessÃ¤ ei ole merkitystÃ¤. Edellisen esimerkin ostoskori tulostetuna olisi:</p>

<pre>
piimÃ¤: 1
juusto: 1
tietokone: 1
maito: 1
</pre>

  <p>Huomaa, ettÃ¤ tulostuva numero on siis tuotteen korissa oleva kappalemÃ¤Ã¤rÃ¤, ei hinta!</p>

<h4>yhtÃ¤ tuotetta kohti vain yksi Ostos-olio</h4>

  <p>TÃ¤ydennetÃ¤Ã¤n Ostoskoria siten, ettÃ¤ jos korissa on jo tuote joka sinne lisÃ¤tÃ¤Ã¤n, ei koriin luoda uutta Ostos-olioa vaan pÃ¤ivitetÃ¤Ã¤n jo korissa olevaa tuotetta vastaavaa ostosolioa kutsumalla sen metodia <em>kasvataMaaraa()</em>.</p>

<p>Esimerkki:</p>

<pre class="sh_java">
        Ostoskori kori = new Ostoskori();
        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("piimÃ¤", 2);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");

        kori.lisaa("maito", 3);
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta() +"\n");
</pre>

<p>Tulostuu:</p>

<pre>
maito: 1
korin hinta: 3

piimÃ¤: 1
maito: 1
korin hinta: 5

piimÃ¤: 1
maito: 2
korin hinta: 8

piimÃ¤: 1
maito: 3
korin hinta: 11
</pre>

  <p>Eli ensin koriin lisÃ¤tÃ¤Ã¤n maito ja piimÃ¤ ja niille omat ostos-oliot. Kun koriin lisÃ¤tÃ¤Ã¤n lisÃ¤Ã¤ maitoa, ei luoda uusille maidoille omaa ostosolioa, vaan pÃ¤ivitetÃ¤Ã¤n jo korissa olevan maitoa kuvaavan ostosolion kappalemÃ¤Ã¤rÃ¤Ã¤.</p>

<h4>Kauppa</h4>

  <p>Nyt meillÃ¤ on valmiina kaikki osat "verkkokauppaa" varten. Verkkokaupassa on varasto joka sisÃ¤ltÃ¤Ã¤ kaikki tuotteet. Jokaista asiakkaan asiointia varten on oma ostoskori. Aina kun asiakas valitsee ostoksen, lisÃ¤tÃ¤Ã¤n se asiakkaan ostoskoriin jos tuotetta on varastossa. Samalla varastosaldoa pienennetÃ¤Ã¤n yhdellÃ¤.</p>

  <p>Seuraavassa on valmiina verkkokaupan koodin runko. Tee projektiin luokka <code>Kauppa</code> ja kopioi alla oleva koodi luokkaan.</p>

<pre class="sh_java">
import java.util.Scanner;

public class Kauppa {

    private Varasto varasto;
    private Scanner lukija;

    public Kauppa(Varasto varasto, Scanner lukija) {
        this.varasto = varasto;
        this.lukija = lukija;
    }

    // metodi jolla hoidetaan yhden asiakkaan asiointi kaupassa
    public void asioi(String asiakas) {
        Ostoskori kori = new Ostoskori();
        System.out.println("Tervetuloa kauppaan " + asiakas);
        System.out.println("valikoimamme:");

        for (String tuote : varasto.tuotteet()) {
            System.out.println( tuote );
        }

        while (true) {
            System.out.print("mitÃ¤ laitetaan ostoskoriin (pelkkÃ¤ enter vie kassalle):");
            String tuote = reader.nextLine();
            if (tuote.isEmpty()) {
                break;
            }

            // tee tÃ¤nne koodi joka lisÃ¤Ã¤ tuotteen ostoskoriin jos sitÃ¤ on varastossa
            // ja vÃ¤hentÃ¤Ã¤ varastosaldoa
            // Ã¤lÃ¤ koske muuhun koodiin!

        }

        System.out.println("ostoskorissasi on:");
        kori.tulosta();
        System.out.println("korin hinta: " + kori.hinta());
    }
}
</pre>

<p>Seuraavassa pÃ¤Ã¤ohjelma joka tÃ¤yttÃ¤Ã¤ kaupan varaston ja laittaa Pekan asioimaan kaupassa:</p>

<pre class="sh_java">
    Varasto varasto = new Varasto();
    varasto.lisaaTuote("kahvi", 5, 10);
    varasto.lisaaTuote("maito", 3, 20);
    varasto.lisaaTuote("piimÃ¤", 2, 55);
    varasto.lisaaTuote("leipÃ¤", 7, 8);

    Kauppa kauppa = new Kauppa(varasto, new Scanner(System.in));
    kauppa.asioi("Pekka");
</pre>

  <p>Kauppa on melkein valmiina. Yhden asiakkaan asioinnin hoitavan metodin <code>public void asioi(String asiakas)</code> on kommenteilla merkitty kohta jonka joudut tÃ¤ydentÃ¤mÃ¤Ã¤n. LisÃ¤Ã¤ kohtaan koodi joka tarkastaa onko asiakkaan haluamaa tuotetta varastossa. Jos on, vÃ¤hennÃ¤ tuotteen varastosaldoa ja lisÃ¤Ã¤ tuote ostoskoriin.</p>

  <p><em>Vapise, verkkokauppa.com!</em></p>
</div>

<h2>Generics</h2>

    <p>We speak about <em>Generics</em> in connection to the way classes can conserve objects of genric type. Generics is based on the generic type parameter which is used when we define a class, and which helps us to define the types that have to be chosen when an <em>object is created</em>. A class generics can be defined by setting up the number of type parameters we want. This number is written after the class name and between the greater-than and less-than signs. We now implement our own generic class <code>Slot</code> which be assigned whatever object.</p>

<pre class="sh_java">
public class Slot&lt;T&gt; {
    private T key;

    public void setValue(T key) {
        this.key = key;
    }

    public T getValue() {
        return key;
    }
}
</pre>

    <p>The definition <code>public class Slot&lt;T&gt;</code> tells us that we have to give a type parameter to the constructor of the class <code>Slot</code>. After the constructor call the object variables have to be the same type as what established with the call. We now create a slot which memorizes strings.</p>

<pre class="sh_java">
    Slot&lt;String&gt; string = new Slot&lt;String&gt;();
    string.setValue(":)");

    System.out.println(string.getValue());
</pre>

<pre>
:)
</pre>

    <p>If we change the type parameter we can create different kinds of <code>Slot</code> ojects, whose purpose is to memorize objects. For instance, we can memorize an integer in the following way:</p>

<pre class="sh_java">
    Slot&lt;Integer&gt; num = new Slot&lt;Integer&gt;();
    num.setValue(5);

    System.out.println(slot.getValue());
</pre>


<pre>
5
</pre>

    <p>An important part of Java data structures are programmed to be generic. For instance, ArrayList receives one parameter, HashMap two.</p>

<pre class="sh_java">
    List&lt;String&gt; string = new ArrayList&lt;String&gt;();
    Map&lt;String, String&gt; keyCouples = new HashMap&lt;String, String&gt;();
</pre>

    <p>In the future, when you see the type <code>ArrayList&lt;String&gt;</code>, for instance, you know that its internal structure makes use of a generic type parameter.</p>

    <h3>The Interface which Makes Use of Generics: Comparable</h3>

    <p>In addition to normal interfaces, Java has got interfaces which make use of generics. The internal value types of generic interfaces are defined in the same way as for generic classes. Let us have a look at Java made-up <code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Comparable.html">Comparable</a></code> interface. The <code>Comparable</code> interface defines the <code>compareTo</code> method, which returns the place of <code>this</code> object, in relation to the parameter obect (a negative number, 0, or a positive number). If <code>this</code> object is placed before the parameter object in the comparison order, the method returns a negative value, whereas it returns a positive value if it is placed after the parameter object. If the objects are placed at the same place in the comparison order, the method returns 0. With comparison order we mean the object order of magnitude defined by the programmer, i.e. the object order, when they are sorted with the sort method.</p>

    <p>One of the advantages of the <code>Comparable</code> interface is that it allows us to sort a list of Comparable type keys by using the standard library method <code>Collections.sort</code>, for instance. <code>Collections.sort</code> uses the <code>compareTo</code> method of a key list to define in which order these keys should be. We call <em>Natural Ordering</em> this ordering technique which makes use of the <code>compareTo</code> method.

    <p>We create the class <code>ClubMember</code>, which depicts the young people and children who belong to the club. The members have to eat in order of height, so the club members will implement the interface <code>Comparable</code>. The interface <code>Comparable</code> also takes as type parameter the class which it is compared to. As type parameter, we use the <code>ClubMember</code> class.</p>

<pre class="sh_java">
public class ClubMember implements Comparable&lt;ClubMember&gt; {
    private String name;
    private int height;

    public Kerholainen(String name, int height) {
        this.name = name;
        this.height = height;
    }

    public String getName() {
        return this.name;
    }

    public int getHeigth() {
        return this.height;
    }

    @Override
    public String toString() {
        return this.getName() + " (" + this.getHeigth() + ")";
    }

    @Override
    public int compareTo(ClubMember clubMember) {
        if(this.heigth == clubMember.getHeight()) {
            return 0;
        } else if (this.height &gt; clubMember.getHeight()) {
            return 1;
        } else {
            return -1;
        }
    }
}
</pre>

    <p>The interface requires the method <code>compareTo</code>, which returns an integer that tells us the comparison order. Our <code>compareTo()</code> method has to return a negative number if <code>this</code> object is smaller than its parameter object, or zero, if the two members are equally tall. Therefore, we can implement the above <code>compareTo</code> method, in the following way:</p>

<pre class="sh_java">
    @Override
    public int compareTo(ClubMember clubMember) {
        return this.height - clubMember.getHeight();
    }
</pre>

    <p>Sorting club members is easy, now.</p>

<pre class="sh_java">
    List&lt;Kerholainen&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    System.out.println(clubMembers);
    Collections.sort(clubMembers);
    System.out.println(clubMembers);
</pre>

<pre>
[mikael (182), matti (187), joel (184)]
[mikael (182), joel (184), matti (187)]
</pre>

    <p>If we want to sort the members in descending order, we only have to switch the variable order in our <code>compareTo</code> method.</p>


<div class="tehtavat">

  <h3>KÃ¶yhÃ¤t kyykkyyn</h3>

  <p>Saat valmiin luokan Ihminen. IhmisellÃ¤ on nimi- ja palkkatiedot. Muokkaa Ihminen-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, ettÃ¤ <code>compareTo</code>-metodi lajittelee ihmiset palkan mukaan jÃ¤rjestykseen - suuripalkkaiset ensin, kÃ¶yhÃ¤t kyykkyyn listan loppuun.</p>


  <h3>Opiskelijat nimijÃ¤rjestykseen</h3>

  <p>Saat valmiin luokan Opiskelija. Opiskelijalla on nimi. Muokkaa Opiskelija-luokasta <code>Comparable</code>-rajapinnan toteuttava niin, ettÃ¤ <code>compareTo</code>-metodi lajittelee opiskelijat nimen mukaan aakkosjÃ¤rjestykseen.</p>

  <p><b>Vinkki:</b> Opiskelijan nimi on String, ja String-luokka on itsessÃ¤Ã¤n <code>Comparable</code>. Voit hyÃ¶dyntÃ¤Ã¤ String-luokan <code>compareTo</code>-metodia Opiskelija-luokan metodia toteuttaessasi. <code>String.compareTo</code> kohtelee kirjaimia eriarvoisesti kirjainkoon mukaan, ja tÃ¤tÃ¤ varten String-luokalla on myÃ¶s metodi <code>compareToIgnoreCase</code> joka nimensÃ¤ mukaisesti jÃ¤ttÃ¤Ã¤ kirjainkoon huomioimatta. Voit kÃ¤yttÃ¤Ã¤ opiskelijoiden jÃ¤rjestÃ¤miseen kumpaa nÃ¤istÃ¤ haluat.</p>


  <h3>Kortit ojennukseen</h3>

<p>TehtÃ¤vÃ¤pohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on <em>2, 3, ..., 10, J, Q, K </em> tai <em>A</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Arvo ja maa kuitenkin esitetÃ¤Ã¤n olioiden sisÃ¤llÃ¤ kokonaislukuina. Kortilla on myÃ¶s metodi toString, jota kÃ¤yttÃ¤en kortin arvo ja maa tulostuvat "ihmisystÃ¤vÃ¤llisesti". </p>

<p>Jotta korttien kÃ¤yttÃ¤jÃ¤n ei tarvitsisi kÃ¤sitellÃ¤ korttien maita numeroina, on luokkaan mÃ¤Ã¤ritelty neljÃ¤ <strong>vakioa</strong> eli <code>public static final</code> -muuttujaa: </p>

<pre class="sh_java">
public class Kortti {
    public static final int RISTI  = 0;
    public static final int RUUTU  = 1;
    public static final int HERTTA = 2;
    public static final int PATA   = 3;

    // ...
}
</pre>

<p>Nyt ohjelmassa voidaan luvun 1 sijaan kÃ¤yttÃ¤Ã¤ vakioa <code>Kortti.RUUTU</code>. Seuraavassa esimerkissÃ¤ luodaan kolme korttia ja tulostetaan ne:</p>

<pre class="sh_java">
  Kortti eka = new Kortti(2, Kortti.RUUTU);
  Kortti toka = new Kortti(14, Kortti.PATA);  
  Kortti kolmas = new Kortti(12, Kortti.HERTTA);

  System.out.println(eka);
  System.out.println(toka);
  System.out.println(kolmas);
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata A
Hertta Q
</pre>

<p><b>HUOM:</b> vaikioiden kÃ¤yttÃ¶ yllÃ¤olevaan tapaan ei ole tyylikkÃ¤in tapa asian hoitamiseen. MyÃ¶hemmin kurssilla opimme oikeaoppisen tyylin maan esittÃ¤miseen!</p>

  <h4>Kortti-luokasta Comparable</h4>

  <p>Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, ettÃ¤ korttien jÃ¤rjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitÃ¤ maan perusteella nousevassa jÃ¤rjestyksessÃ¤: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em> </p> 

<p>JÃ¤rjestyksessÃ¤ pienin kortti siis olisi risti kakkonen ja suurin pataÃ¤ssÃ¤.</p>

<h4>KÃ¤si</h4>

<p>TehdÃ¤Ã¤n seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kÃ¤dessÃ¤Ã¤n pitÃ¤mÃ¤Ã¤ korttien joukkoa. Tee kÃ¤delle seuraavat metodit:</p>

<ul>
<li><code>public void lisaa(Kortti kortti)</code> lisÃ¤Ã¤ kÃ¤teen kortin</li>
<li><code>public void tulosta()</code> tulostaa kÃ¤dessÃ¤ olevat kortit alla olevan esimerkin tyylillÃ¤</li>
</ul>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata A
Hertta Q
Pata 2
</pre>

<p>Talleta kÃ¤den sisÃ¤llÃ¤ olevat kortit ArrayListiin.</p>

<h4>KÃ¤den jÃ¤rjestÃ¤minen</h4>

<p>Tee kÃ¤delle metodi <code>public void jarjesta()</code> jota kutsumalla kÃ¤den sisÃ¤llÃ¤ olevat kortit menevÃ¤t suuruusjÃ¤rjestykseen. JÃ¤rjestÃ¤misen jÃ¤lkeen kortit tulostuvat jÃ¤rjestyksessÃ¤:</p>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjesta(); 

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Pata 2
Hertta Q
Pata A
</pre>

<h4>KÃ¤sien vertailu</h4>

<p>ErÃ¤Ã¤ssÃ¤ korttipelissÃ¤ kahdesta korttikÃ¤destÃ¤ arvokkaampi on se, jonka sisÃ¤ltÃ¤mien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tÃ¤mÃ¤n kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.</p>

<p>Esimerkkiohjelma, jossa vertaillaan kÃ¤siÃ¤:</p>

<pre class="sh_java">
  Kasi kasi1 = new Kasi();

  kasi1.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi1.lisaa( new Kortti(14, Kortti.PATA) );
  kasi1.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi1.lisaa( new Kortti(2, Kortti.PATA) );

  Kasi kasi2 = new Kasi();

  kasi2.lisaa( new Kortti(11, Kortti.RUUTU) );
  kasi2.lisaa( new Kortti(11, Kortti.PATA) );
  kasi2.lisaa( new Kortti(11, Kortti.HERTTA) );

  int vertailu = kasi1.compareTo(kasi2);

  if ( vertailu &lt; 0 ) {
    System.out.println("arvokkaampi kÃ¤si sisÃ¤ltÃ¤Ã¤ kortit");
    kasi2.tulosta();
  } else if ( vertailu &gt; 0 ){
    System.out.println("arvokkaampi kÃ¤si sisÃ¤ltÃ¤Ã¤ kortit");
    kasi1.tulosta(); 
  } else {
    System.out.println("kÃ¤det yhtÃ¤ arvokkaat");
  }
</pre>

<p>Tulostuu</p>

<pre>
arvokkaampi kÃ¤si sisÃ¤ltÃ¤Ã¤ kortit
Ruutu J
Pata J
Hertta J
</pre>

<h4>Korttien jÃ¤rjestÃ¤minen eri kriteerein</h4>

<p>EntÃ¤ jos haluaisimme vÃ¤lillÃ¤ jÃ¤rjestÃ¤Ã¤ kortit hieman eri tavalla, esim. kaikki saman maan kortit perÃ¤kkÃ¤in? 
Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia jÃ¤rjestyksiÃ¤ saadaksemme turvautumaan muihin keinoihin.</p>

<p>
Vaihtoehtoiset jÃ¤rjestÃ¤mistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten jÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. JÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on jÃ¤rjestyksessÃ¤ ennen korttia k2, positiivinen arvo jos k2 on jÃ¤rjestyksessÃ¤ ennen k1:stÃ¤ ja 0 muuten.

<p>
Periaatteena on luoda jokaista jÃ¤rjestÃ¤mistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkÃ¤in vievÃ¤n jÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤ luokka:</p>

<pre class="sh_java">
import java.util.Comparator;

public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
    public int compare(Kortti k1, Kortti k2) {
        return k1.getMaa()-k2.getMaa();
    }
}
</pre>

<p>Maittainen jÃ¤rjestys on sama kuin kortin metodin <code>compareTo</code> maille mÃ¤Ã¤rittelemÃ¤ jÃ¤rjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em></p>

<p>JÃ¤rjestÃ¤minen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen jÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokan olion:</p>

<pre class="sh_java">
  ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;Kortti&gt;(); 

  kortit.add( new Kortti(3, Kortti.PATA) );
  kortit.add( new Kortti(2, Kortti.RUUTU) );
  kortit.add( new Kortti(14, Kortti.PATA) );
  kortit.add( new Kortti(12, Kortti.HERTTA) );
  kortit.add( new Kortti(2, Kortti.PATA) );

  SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
  Collections.sort(kortit, samatMaatVierekkainJarjestaja ); 
  
  for (Kortti k : kortit) {
    System.out.println( k );
  }
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Hertta Q
Pata 3
Pata A
Pata 2
</pre>

<p>JÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤ olio voidaan myÃ¶s luoda suoraan sort-kutsun yhteydessÃ¤:</p>

<pre class="sh_java">
  Collections.sort(kortit, new SamatMaatVierekkain() ); 
</pre>
<p>

  <p>Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/notes-java/data/collections/comparators.html">tÃ¤Ã¤llÃ¤</a></p>

<p>Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code>
jonka avulla saat kortit muuten samanlaiseen jÃ¤rjestykseen kuin edellisessÃ¤ esimerkissÃ¤ paitsi, ettÃ¤ saman maan kortit jÃ¤rjestyvÃ¤t arvon mukaiseesti.
</p>

<h4>KÃ¤den jÃ¤rjestÃ¤minen maittain</h4>

<p>LisÃ¤Ã¤ luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla kÃ¤den sisÃ¤llÃ¤ olevat kortit menevÃ¤t edellisen tehtÃ¤vÃ¤n vertailijan mÃ¤Ã¤rittelemÃ¤Ã¤n jÃ¤rjestykseen. JÃ¤rjestÃ¤misen jÃ¤lkeen kortit tulostuvat jÃ¤rjestyksessÃ¤:</p>

<pre class="sh_java">
  Kasi kasi = new Kasi();

  kasi.lisaa( new Kortti(12, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(4, Kortti.PATA) );
  kasi.lisaa( new Kortti(2, Kortti.RUUTU) );
  kasi.lisaa( new Kortti(14, Kortti.PATA) );
  kasi.lisaa( new Kortti(7, Kortti.HERTTA) );
  kasi.lisaa( new Kortti(2, Kortti.PATA) );

  kasi.jarjestaMaittain(); 

  kasi.tulosta();
</pre>

<p>Tulostuu:</p>

<pre>
Ruutu 2
Hertta 7
Hertta Q
Pata 2
Pata 4
Pata A
</pre>

</div>

<h2>Collections</h2>

    <p>The class library <code><a href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html" target="_blank">Collections</a></code> is Java's general-purpose library for collection classes. As we can see, <code>Collections</code> provides methods to sort objects either through the interface <code>Comparable</code> or <code>Comparator</code>. In addition to sorting, we can use this class library to retrieve the minimum and maximum values (through the methods <code>min</code> and <code>max</code>, respectively), retrieve a specific value (<code>binarySearch</code> method), or reverse the list (<code>reverse</code> method).</p>

    <h3>Search</h3>

    <p>The Collections class library provides a made-up binary search functionality. The method <code>binarySearch()</code> returns the index of our searched key, if this is found. If the key is not found, the search algorithm returns a negative value. The method <code>binarySearch()</code> makes use of the Comparable interface to retieve objects. If the object's <code>compareTo()</code> method returns the value 0, i.e. if it is the same object, the key is considered found.</p>

    <p>Our ClubMember class compares people's heights in its <code>compareTo()</code> method, i.e. we look for club members whose height is the same while we parse our list.</p>

<pre class="sh_java">
    List&lt;ClubMember&gt; clubMembers = new ArrayList&lt;ClubMember&gt;();
    clubMembers.add(new ClubMember("mikael", 182));
    clubMembers.add(new ClubMember("matti", 187));
    clubMembers.add(new ClubMember("joel", 184));

    Collections.sort(clubMembers);

    ClubMember wanted = new ClubMember("Name", 180);
    int index = Collections.binarySearch(clubMembers, wanted);
    if(index &gt;= 0) {
        System.out.println("A person who is 180 centimiters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }

    wanted = new ClubMember("Name", 187);
    int index = Collections.binarySearch(clubMembers, wanted);
    if(indeksi &gt;= 0) {
        System.out.println("A person who is 187 centimiters tall was found at index " + index);
        System.out.println("name: " + clubMembers.get(index).getName());
    }
</pre>

    <p>The print output is the following:</p>

<pre>
A person who is 187 centimiters tall was found at index 2
name: matti
</pre>

    <p>Notice that we also called the method <code>Collections.sort()</code>, in our example. This is because binary search cannot be done if our table or list are not already sorted up.</p>







<div class="tehtavat">

<h3>MÃ¤kihyppy</h3>

        <p>Harjoitellaan taas ohjelman rakenteen omatoimista suunnittelua. KÃ¤yttÃ¶liittymÃ¤n ulkomuoto ja vaadittu toiminnallisuus on mÃ¤Ã¤ritelty ennalta, rakenteen saat toteuttaa vapaasti.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. ÃlÃ¤ myÃ¶skÃ¤Ã¤n kÃ¤ytÃ¤ staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillÃ¤ suorituskerroilla jÃ¤Ã¤neet arvot todennÃ¤kÃ¶isesti hÃ¤iritsevÃ¤t testien toimintaa!</b></p>

        <p>MÃ¤kihyppy on suomalaisille erittÃ¤in rakas laji, jossa pyritÃ¤Ã¤n hyppÃ¤Ã¤mÃ¤Ã¤n hyppyrimÃ¤estÃ¤ mahdollisimman pitkÃ¤lle mahdollisimman tyylikkÃ¤Ã¤sti. TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ tulee toteuttaa simulaattori mÃ¤kihyppykilpailulle.</p>

        <p>Simulaattori kysyy ensin kÃ¤yttÃ¤jÃ¤ltÃ¤ hyppÃ¤Ã¤jien nimiÃ¤. Kun kÃ¤yttÃ¤jÃ¤ antaa tyhjÃ¤n characterStringn (eli painaa enteriÃ¤) hyppÃ¤Ã¤jÃ¤n nimeksi siirrytÃ¤Ã¤n hyppyvaiheeseen. Hyppyvaiheessa hyppÃ¤Ã¤jÃ¤t hyppÃ¤Ã¤vÃ¤t yksitellen kÃ¤Ã¤nteisessÃ¤ pistejÃ¤rjestyksessÃ¤. HyppÃ¤Ã¤jÃ¤ jolla on vÃ¤hiten pisteitÃ¤ kerÃ¤ttynÃ¤ hyppÃ¤Ã¤ aina kierroksen ensimmÃ¤isenÃ¤, toiseksi vÃ¤hiten pisteitÃ¤ omaava toisena jne, ..., eniten pisteitÃ¤ kerÃ¤nnyt viimeisenÃ¤.</p>

        <p>HyppÃ¤Ã¤jÃ¤n yhteispisteet lasketaan yksittÃ¤isten hyppyjen pisteiden summana. YksittÃ¤isen hypyn pisteytys lasketaan hypyn pituudesta (kÃ¤ytÃ¤ satunnaista kokonaisluku vÃ¤liltÃ¤ 60-120) ja tuomariÃ¤Ã¤nistÃ¤. Jokaista hyppyÃ¤ kohden annetaan 5 tuomariÃ¤Ã¤ntÃ¤ (satunnainen luku vÃ¤liltÃ¤ 10-20). TuomariÃ¤Ã¤niÃ¤ laskettaessa otetaan huomioon vain kolme keskimmÃ¤istÃ¤ Ã¤Ã¤ntÃ¤: pienintÃ¤ ja suurinta Ã¤Ã¤ntÃ¤ ei oteta huomioon. Esimerkiksi jos Mikael hyppÃ¤Ã¤ 61 metriÃ¤ ja saa tuomariÃ¤Ã¤net 11, 12, 13, 14 ja 15, on hÃ¤nen hyppynsÃ¤ yhteispisteet 100.</p>

        <p>Kierroksia hypÃ¤tÃ¤Ã¤n niin monta kuin ohjelman kÃ¤yttÃ¤jÃ¤ haluaa. Kun kÃ¤yttÃ¤jÃ¤ haluaa lopettaa tulostetaan lopuksi kilpailun lopputulokset. Lopputuloksissa tulostetaan hyppÃ¤Ã¤jÃ¤t, hyppÃ¤Ã¤jien yhteispisteet ja hyppÃ¤Ã¤jien hyppÃ¤Ã¤mien hyppyjen pituudet. Lopputulokset on jÃ¤rjestetty hyppÃ¤Ã¤jien yhteispisteiden mukaan siten, ettÃ¤ eniten pisteitÃ¤ kerÃ¤nnyt on ensimmÃ¤inen.</p>

        <p>TehtÃ¤vÃ¤n tekemisessÃ¤ on hyÃ¶tyÃ¤ <em>muun muassa</em> metodeista <code>Collections.sort</code> ja <code>Collections.reverse</code>. Kannattaa aluksi hahmotella minkÃ¤laisia luokkia ja olioita ohjelmassa voisi olla. On myÃ¶s hyvÃ¤ pyrkiÃ¤ tilanteeseen, jossa kÃ¤yttÃ¶liittymÃ¤luokka on ainut luokka joka kutsuu tulostuskomentoa.</p>

<pre>
Kumpulan mÃ¤kiviikot

SyÃ¶tÃ¤ kilpailun osallistujat yksi kerrallaan, tyhjÃ¤llÃ¤ characterStringlla siirtyy hyppyvaiheeseen.
  Osallistujan nimi: <font color="red">Mikael</font>
  Osallistujan nimi: <font color="red">Mika</font>
  Osallistujan nimi:

Kilpailu alkaa!

Kirjoita "hyppaa" niin hypÃ¤tÃ¤Ã¤n, muuten lopetetaan: <font color="red">hyppaa</font>

1. kierros

HyppyjÃ¤rjestys:
  1. Mikael (0 pistettÃ¤)
  2. Mika (0 pistettÃ¤)

Kierroksen 1 tulokset
  Mikael
    pituus: 95
    tuomaripisteet: [15, 11, 10, 14, 14]
  Mika
    pituus: 112
    tuomaripisteet: [14, 12, 18, 18, 17]

Kirjoita "hyppaa" niin hypÃ¤tÃ¤Ã¤n, muuten lopetetaan: <font color="red">hyppaa</font>

2. kierros

HyppyjÃ¤rjestys:
  1. Mikael (134 pistettÃ¤)
  2. Mika (161 pistettÃ¤)

Kierroksen 2 tulokset
  Mikael
    pituus: 96
    tuomaripisteet: [20, 19, 15, 13, 18]
  Mika
    pituus: 61
    tuomaripisteet: [12, 11, 15, 17, 11]

Kirjoita "hyppaa" niin hypÃ¤tÃ¤Ã¤n, muuten lopetetaan: <font color="red">hyppaa</font>

3. kierros

HyppyjÃ¤rjestys:
  1. Mika (260 pistettÃ¤)
  2. Mikael (282 pistettÃ¤)

Kierroksen 3 tulokset
  Mika
    pituus: 88
    tuomaripisteet: [11, 19, 13, 10, 15]
  Mikael
    pituus: 63
    tuomaripisteet: [12, 19, 19, 12, 12]

Kirjoita "hyppaa" niin hypÃ¤tÃ¤Ã¤n, muuten lopetetaan: <font color="red">lopeta</font>

Kiitos!

Kilpailun lopputulokset:
Sija    Nimi
1       Mikael (388 pistettÃ¤)
          hyppyjen pituudet: 95 m, 96 m, 63 m
2       Mika (387 pistettÃ¤)
          hyppyjen pituudet: 112 m, 61 m, 88 m
</pre>



  <p><strong>Huom1:</strong> Testien kannalta on oleellista ettÃ¤ <em>kÃ¤yttÃ¶liittymÃ¤</em> toimii kuten yllÃ¤ kuvattu, esim. rivien alussa olevien vÃ¤lilyÃ¶ntien mÃ¤Ã¤rÃ¤n on oltava oikea. <strong>Rivien alussa oleva tyhjÃ¤ pitÃ¤Ã¤ tehdÃ¤ vÃ¤lilyÃ¶nneillÃ¤</strong>, testit eivÃ¤t toimi jos tyhjÃ¤ on tehty tabulaattoreilla. Ohjelman tulostamat tekstit kannattaneekin copypasteta ohjelmakoodiin joko tehtÃ¤vÃ¤nannosta tai testien virheilmoituksista. <em>TehtÃ¤vÃ¤ on neljÃ¤n yksittÃ¤isen tehtÃ¤vÃ¤pisteen arvoinen.</em></p>

<p><strong>Huom2:</strong> Ã¤lÃ¤ kÃ¤ytÃ¤ luokkein nimissÃ¤ skandeja, ne saattavat aiheuttaa ongelmia testeihin!</p>

  <p><strong>Ohjelman tulee kÃ¤ynnistyÃ¤ kun tehtÃ¤vÃ¤pohjassa oleva main-metodi suoritetaan, muistutuksena vieltÃ¤, ettÃ¤ tehtÃ¤vÃ¤ssÃ¤ saa luoda vain yhden Scanner-olion.</strong></p>

</div>

    <p>Screencast jossa tehdÃ¤Ã¤n viikon 1 ja 2 ydinasioita hyÃ¶dyntÃ¤vÃ¤ hieman isompi sovellus:</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=LFxtwce8chM" height="300" target="_blank"><img src="img/youtube.jpg"/></a>

<!--
    <p><iframe allowfullscreen="" frameborder="0"  height="450" width="700" src="http://www.youtube.com/embed/LFxtwce8chM"></iframe></p>
-->



<div class="tyhja"></div>

<div class="viikkoraja">Viikko 3</div>

<h2>Single responsibility principle</h2>

    <p>Isompia ohjelmia suunniteltaessa pohditaan usein mille luokalle minkÃ¤kin asian toteuttaminen kuuluu. Jos kaikki ohjelmaan kuuluva toiminnallisuus asetetaan samaan luokkaan, on tuloksena vÃ¤istÃ¤mÃ¤ttÃ¤ kaaos. Ohjelmistojen suunnittelun osa-alue <em>oliosuunnittelu</em> sisÃ¤ltÃ¤Ã¤ periaatteen <em>Single responsibility principle</em>, jota meidÃ¤n kannattaa seurata.</p>

    <p>Single responsibility principle sanoo ettÃ¤ jokaisella luokalla tulee olla vain yksi vastuu ja selkeÃ¤ tehtÃ¤vÃ¤. Jos luokalla on yksi selkeÃ¤ tehtÃ¤vÃ¤, on tehtÃ¤vÃ¤ssÃ¤ tapahtuvien muutosten toteuttaminen helppoa, muutos tulee tehdÃ¤ vain yhteen luokkaan. <em>Jokaisella luokalla tulisi olla vain yksi syy muuttua</em>.</p>

    <p>Tutkitaan seuraavaa luokkaa <code>Tyontekija</code>, jolla on metodit palkan laskemiseen ja tuntien raportointiin.</p>

<pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // tyÃ¶ntekijÃ¤Ã¤n liittyvÃ¤t konstruktorit ja metodit

    public double laskePalkka() {
        // palkan laskemiseen liittyvÃ¤ logiikka
    }

    public String raportoiTunnit() {
        // tyÃ¶tuntien raportointiin liittyvÃ¤ logiikka
    }
}
</pre>

    <p>Vaikka yllÃ¤ olevasta esimerkistÃ¤ puuttuvat konkreettiset toteutukset, tulisi hÃ¤lytyskellojen soida. Luokalla <code>Tyontekija</code> on ainakin kolme eri vastuualuetta. Se kuvaa sovelluksessa tyÃ¶ntekijÃ¤Ã¤, se toteuttaa palkanlaskennan tehtÃ¤vÃ¤Ã¤ palkan laskemisesta, ja tuntiraportointijÃ¤rjestelmÃ¤n tehtÃ¤vÃ¤Ã¤ tyÃ¶tuntien raportoinnista. YllÃ¤ oleva luokka pilkkoa kolmeen osaan: yksi osa kuvaa tyÃ¶ntekijÃ¤Ã¤, toinen osa palkanlaskentaa ja kolmas osa tuntikirjanpitoa.</p>

<pre class="sh_java">
public class Tyontekija {
    // oliomuuttujat

    // tyÃ¶ntekijÃ¤Ã¤n liittyvÃ¤t konstruktorit ja metodit
}
</pre>

<pre class="sh_java">
public class Palkanlaskenta {
    // oliomuuttujat

    // palkanlaskentaan liittyvÃ¤t metodit

    public double laskePalkka(Person henkilo) {
        // palkan laskemiseen liittyvÃ¤ logiikka
    }
}
</pre>


<pre class="sh_java">
public class Tuntikirjanpito {
    // oliomuuttujat

    // tuntikirjanpitoon liittyvÃ¤t metodit

    public String luoTuntiraportti(Person henkilo) {
        // tyÃ¶tuntien raportointiin liittyvÃ¤ logiikka
    }
}
</pre>

    <p><em>Jokainen muuttuja, jokainen koodirivi, jokainen metodi, jokainen luokka, ja jokainen ohjelma pitÃ¤isi olla vain yhtÃ¤ tarkoitusta varten. Usein ohjelman "parempi" rakenne on ohjelmoijalle selkeÃ¤Ã¤ vasta kun ohjelma on toteutettu jo kertaalleen. TÃ¤mÃ¤ on tÃ¤ysin hyvÃ¤ksyttÃ¤vÃ¤Ã¤: vielÃ¤ tÃ¤rkeÃ¤mpÃ¤Ã¤ on se, ettÃ¤ ohjelmaa pyritÃ¤Ã¤n muuttamaan aina selkeÃ¤mpÃ¤Ã¤n suuntaan. <strong>Refaktoroi eli muokkaa ohjelmaasi aina tarpeen tullen!</strong></em></p>


<h2>Luokkien organisointi pakkauksiin</h2>

    <p>Suurempia ohjelmia suunniteltaessa ja toteutettaessa luokkamÃ¤Ã¤rÃ¤ kasvaa helposti suureksi. Luokkien mÃ¤Ã¤rÃ¤n kasvaessa niiden tarjoamien toiminnallisuuksien ja metodien muistaminen vaikeutuu. JÃ¤rkevÃ¤ luokkien nimentÃ¤ helpottaa toiminnallisuuksien muistamista. JÃ¤rkevÃ¤n nimennÃ¤n lisÃ¤ksi lÃ¤hdekooditiedostot kannattaa jakaa toiminnallisuutta, kÃ¤yttÃ¶tarkoitusta tai jotain muuta loogista kokonaisuutta kuvaaviin pakkauksiin. Pakkaukset (<em>package</em>) ovat kÃ¤ytÃ¤nnÃ¶ssÃ¤ hakemistoja, joihin lÃ¤hdekooditiedostot organisoidaan. Windowsissa ja puhekielessÃ¤ hakemistoja (engl. directory) kutsutaan usein kansioiksi. Me kÃ¤ytÃ¤mme kuitenkin termiÃ¤ hakemisto.</p>

    <p>OhjelmointiympÃ¤ristÃ¶t tarjoavat valmiit tyÃ¶kalut pakkausten hallintaan. Olemme tÃ¤hÃ¤n mennessÃ¤ luoneet luokkia ja rajapintoja vain projektiin liittyvÃ¤n lÃ¤hdekoodipakkaukset-osion (<code>Source Packages</code>) oletuspakkaukseen (<code>default package</code>). Uuden pakkauksen voi luoda NetBeansissa projektin pakkauksiin liittyvÃ¤ssÃ¤ <code>Source Packages</code> -osiossa oikeaa hiirennappia painamalla ja valitsemalla <code>New -&gt; Java Package...</code>. Luodun pakkauksen sisÃ¤lle voidaan luoda luokkia aivan kuten oletuspakkaukseenkin (<code>default package</code>).</p>

  <p>Pakkaus, jossa luokka sijaitsee, nÃ¤kyy lÃ¤hdekooditiedoston alussa ennen muita komentoja olevasta lauseesta <code>package <em>pakkaus</em></code>. Esimerkiksi alla oleva luokka <code>Sovellus</code> sijaitsee pakkauksessa <code>kirjasto</code>.</p>

<pre class="sh_java">
package kirjasto;

public class Sovellus {

    public static void main(String[] args) {
        System.out.println("Hello packageworld!");
    }
}
</pre>

  <p>Pakkaukset voivat sisÃ¤ltÃ¤Ã¤ pakkauksia. Esimerkiksi pakkausmÃ¤Ã¤rittelyssÃ¤ <code>package kirjasto.domain</code> pakkaus <code>domain</code> on pakkauksen <code>kirjasto</code> sisÃ¤llÃ¤. Asettamalla pakkauksia pakkausten sisÃ¤Ã¤n rakennetaan sovelluksen luokille ja rajapinnoille hierarkiaa. Esimerkiksi kaikki Javan luokat sijaitsevat pakkauksen <code>java</code> alla olevissa pakkauksissa. PakkausnimeÃ¤ <code>domain</code> kÃ¤ytetÃ¤Ã¤n usein kuvaamaan sovellusalueen kÃ¤sitteisiin liittyvien luokkien sÃ¤ilytyspaikkaa. Esimerkiksi luokka <code>Book</code> voisi hyvin olla pakkauksen <code>kirjasto.domain</code> sisÃ¤llÃ¤ sillÃ¤ se kuvaa kirjastosovellukseen liittyvÃ¤Ã¤ kÃ¤sitettÃ¤.</p>

<pre class="sh_java">
package kirjasto.domain;

public class Book {
    private String name;

    public Book(String name) {
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }
}
</pre>

  <p>Pakkauksissa olevia luokkia tuodaan luokan kÃ¤yttÃ¶Ã¶n <code>import</code>-lauseen avulla. Esimerkiksi <code>kirjasto</code>-pakkauksessa oleva luokka <code>Sovellus</code> saisi kÃ¤yttÃ¶Ã¶nsÃ¤ pakkauksessa <code>kirjasto.domain</code> olevan luokan mÃ¤Ã¤rittelyllÃ¤ <code>import kirjasto.domain.Book</code>.</p>


<pre class="sh_java">
package kirjasto;

import kirjasto.domain.Book;

public class Sovellus {

    public static void main(String[] args) {
        Book kirja = new Book("pakkausten ABC!");
        System.out.println("Hello packageworld: " + kirja.getName());
    }
}
</pre>

<pre>
Hello packageworld: pakkausten ABC!
</pre>

    <p>Import-lauseet asetetaan lÃ¤hdekooditiedostossa pakkausmÃ¤Ã¤rittelyn jÃ¤lkeen mutta ennen luokkamÃ¤Ã¤rittelyÃ¤. NiitÃ¤ voi olla myÃ¶s useita -- esimerkiksi kun haluamme kÃ¤yttÃ¤Ã¤ useita luokkia. Javan valmiit luokat sijaitsevat yleensÃ¤ ottaen pakkauksen <code>java</code> alipakkauksissa. Luokkiemme alussa usein esiintyvÃ¤t lauseet <code>import java.util.ArrayList</code> ja <code>import java.util.Scanner;</code> alkavat nyt toivottavasti vaikuttaa merkityksellisimmiltÃ¤.</p>

    <p>Jatkossa <em>kaikissa</em> tehtÃ¤vissÃ¤mme kÃ¤ytetÃ¤Ã¤n pakkauksia. Luodaan seuraavaksi ensimmÃ¤iset pakkaukset itse.</p>

<div class="tehtavat" id="viikko9">

<NEXTWEEK></NEXTWEEK>

  <h3>EnsimmÃ¤isiÃ¤ pakkauksia</h3>

  <h4>KÃ¤yttÃ¶liittymÃ¤-rajapinta</h4>

  <p>Luo projektipohjaan pakkaus <code>mooc</code>. Rakennetaan tÃ¤mÃ¤n pakkauksen sisÃ¤lle sovelluksen toiminta. LisÃ¤Ã¤ sovellukseen pakkaus <code>ui</code> (tÃ¤mÃ¤n jÃ¤lkeen pitÃ¤isi olla kÃ¤ytÃ¶ssÃ¤ pakkaus <code>mooc.ui</code>), ja lisÃ¤Ã¤ sinne rajapinta <code>Kayttoliittyma</code>.</p>

  <p>Rajapinnan <code>Kayttoliittyma</code> tulee mÃ¤Ã¤ritellÃ¤ metodi <code>void paivita()</code>. </p>

 <h4>TekstikÃ¤yttÃ¶liittymÃ¤</h4>

<p>
Luo samaan pakkaukseen luokka <code>Tekstikayttoliittyma</code>, joka toteuttaa rajapinnan <code>Kayttoliittyma</code>. Toteuta luokassa <code>Tekstikayttoliittyma</code> rajapinnan <code>Kayttoliittyma</code> vaatima metodi <code>public void paivita()</code> siten, ettÃ¤ sen ainut tehtÃ¤vÃ¤ on characterStringn "<code>PÃ¤ivitetÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤Ã¤</code>"-tulostaminen <code>System.out.println</code>-metodikutsulla.</p>

  <h4>Sovelluslogiikka</h4>

  <p>Luo tÃ¤mÃ¤n jÃ¤lkeen pakkaus <code>mooc.logiikka</code>, ja lisÃ¤Ã¤ sinne luokka <code>Sovelluslogiikka</code>. Sovelluslogiikan APIn tulee olla seuraavanlainen.</p>

<p>
  <ul>
    <li><code>public Sovelluslogiikka(Kayttoliittyma kayttoliittyma)</code></li>Sovelluslogiikka-luokan konstruktori. Saa parametrina Kayttoliittyma-rajapinnan toteuttavan luokan. Huom: jotta sovelluslogiikka nÃ¤kisi rajapinnan, on sen "importoitava" se, eli tarvitset tiedoston alkuun rivin <code>import mooc.ui.Kayttoliittyma;</code> <br/>
    <li><code>public void suorita(int montaKertaa)</code></li> Tulostaa <code>montaKertaa</code>-muuttujan mÃ¤Ã¤rittelemÃ¤n mÃ¤Ã¤rÃ¤n characterStringa "Sovelluslogiikka toimii". Jokaisen "Sovelluslogiikka toimii"-tulostuksen jÃ¤lkeen tulee kutsua konstruktorin parametrina saadun rajapinnan <code>Kayttoliittyma</code>-toteuttaman olion mÃ¤Ã¤rittelemÃ¤Ã¤ <code>paivita()</code>-metodia.<br/>
  </ul>
</p>

  <p>Voit testata sovelluksen toimintaa seuraavalla pÃ¤Ã¤ohjelmaluokalla.</p>

<pre class="sh_java">
import mooc.logiikka.Sovelluslogiikka;
import mooc.ui.Kayttoliittyma;
import mooc.ui.Tekstikayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Tekstikayttoliittyma();
        new Sovelluslogiikka(kayttoliittyma).suorita(3);
    }
}
</pre>

  <p>Ohjelman tulostuksen tulee olla seuraava:</p>

<pre>
Sovelluslogiikka toimii
PÃ¤ivitetÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤Ã¤
Sovelluslogiikka toimii
PÃ¤ivitetÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤Ã¤
Sovelluslogiikka toimii
PÃ¤ivitetÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤Ã¤
</pre>

</div>

    <h3>Konkreettinen hakemistorakenne</h3>

    <p>Kaikki NetBeansissa nÃ¤kyvÃ¤t projektit ovat tietokoneesi <em><a href="http://fi.wikipedia.org/wiki/Tiedostoj%C3%A4rjestelm%C3%A4" target="_blank">tiedostojÃ¤rjestelmÃ¤ssÃ¤</a></em>. Jokaiselle projektille on olemassa oma hakemisto (eli kansio), jonka sisÃ¤llÃ¤ on projektiin liittyvÃ¤t tiedostot ja hakemistot.</p>

    <p>Projektin hakemistossa <code>src</code> on ohjelmaan liittyvÃ¤t lÃ¤hdekoodit. Jos luokan pakkauksena on kirjasto, sijaitsee se projektin lÃ¤hdekoodihakemistoon <code>src</code> sisÃ¤llÃ¤ olevassa hakemistossa <code>kirjasto</code>. Jos olet kiinnostunut, NetBeansissa voi kÃ¤ydÃ¤ katsomassa projektien konkreettista rakennetta <em>Files</em>-vÃ¤lilehdeltÃ¤ joka on normaalisti <em>Projects</em>-vÃ¤lilehden vieressÃ¤. Jos et nÃ¤e vÃ¤lilehteÃ¤ <em>Files</em>, saa sen nÃ¤kyville valitsemalla vaihtoehdon <em>Files</em> valikosta <em>Window</em>.</p>

    <p>SovelluskehitystÃ¤ tehdÃ¤Ã¤n normaalisti <em>Projects</em>-vÃ¤lilehdeltÃ¤, jossa NetBeans on piilottanut projektiin liittyviÃ¤ tiedostoja joista ohjelmoijan ei tarvitse vÃ¤littÃ¤Ã¤.</p>

    <h3>NÃ¤kyvyysmÃ¤Ã¤reet ja pakkaukset</h3>

    <p>Olemme aiemmin tutustuneet kahteen nÃ¤kyvyysmÃ¤Ã¤reeseen. NÃ¤kyvyysmÃ¤Ã¤reellÃ¤ <code>private</code> varustetut metodit ja muuttujat ovat nÃ¤kyvissÃ¤ vain sen luokan sisÃ¤llÃ¤ joka mÃ¤Ã¤rittelee ne. NiitÃ¤ ei voi kÃ¤yttÃ¤Ã¤ luokan ulkopuolelta. NÃ¤kyvyysmÃ¤Ã¤reellÃ¤ <code>public</code> varustetut metodit ja muuttujat ovat taas kaikkien kÃ¤ytettÃ¤vissÃ¤.</p>

<pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void start() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    private void tulostaOtsikko() {
        System.out.println("************");
        System.out.println("* KIRJASTO *");
        System.out.println("************");
    }
}
</pre>

    <p>YllÃ¤ olevasta <code>Kayttoliittyma</code>-luokasta tehdyn olion konstruktori ja <code>start</code>-metodi on kutsuttavissa mistÃ¤ tahansa ohjelmasta. Metodi <code>tulostaOtsikko</code> ja <code>lukija</code>-muuttuja on kÃ¤ytÃ¶ssÃ¤ vain luokan sisÃ¤llÃ¤.</p>

    <p>PakkausnÃ¤kyvyyttÃ¤ kÃ¤ytettÃ¤essÃ¤ muuttujille tai metodeille ei aseteta mitÃ¤Ã¤n nÃ¤kyvyyteen liittyvÃ¤Ã¤ etuliitettÃ¤. Muutetaan yllÃ¤ olevaa esimerkkiÃ¤ siten, ettÃ¤ metodilla <code>tulostaOtsikko</code> on pakkausnÃ¤kyvyys.</p>

<pre class="sh_java">
package kirjasto.ui;

public class Kayttoliittyma {
    private Scanner lukija;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
    }

    public void start() {
        tulostaOtsikko();

        // muu toiminnallisuus
    }

    void tulostaOtsikko() {
        System.out.println("************");
        System.out.println("* KIRJASTO *");
        System.out.println("************");
    }
}
</pre>

    <p>Nyt <em>saman pakkauksen sisÃ¤llÃ¤</em> olevat luokat voivat kÃ¤yttÃ¤Ã¤ metodia <code>tulostaOtsikko</code>.

<pre class="sh_java">
package kirjasto.ui;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // onnistuu!
    }
}
</pre>

    <p>Jos luokka on eri pakkauksessa, ei metodia <code>tulostaOtsikko</code> pysty kÃ¤yttÃ¤mÃ¤Ã¤n.</p>

<pre class="sh_java">
package kirjasto;

import java.util.Scanner;
import kirjasto.ui.Kayttoliittyma;

public class Main {

    public static void main(String[] args) {
        Scanner lukija = new Scanner(System.in);
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);

        kayttoliittyma.tulostaOtsikko(); // ei onnistu!
    }
}
</pre>

<h2>Monta rajapintaa ja rajapintojen tarjoamasta joustavuudesta</h2>

    <p>Viime viikolla tutustuimme rajapintoihin. Rajapinta siis mÃ¤Ã¤rittelee yhden tai useamman metodin, jotka sen toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>, ja mÃ¤Ã¤rittelee ettÃ¤ <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public interface Tunnistettava {
    String getTunnus();
}
</pre>

    <p>Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Toteutetaan luokka <code>Person</code>, joka toteuttaa rajapinnan tunnistettava. Person-luokan metodi <code>getTunnus</code> palauttaa aina henkilÃ¶n henkilÃ¶tunnuksen.</p>

<pre class="sh_java">
package sovellus.domain;

public class Person implements Tunnistettava {
    private String name;
    private String henkilotunnus;

    public Person(String name, String henkilotunnus) {
        this.name = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getName() {
        return this.name;
    }

    public String getPersontunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getPersontunnus();
    }

    @Override
    pulic toString(){
        return this.name + " hetu: " +this.henkilotunnus; 
    }
}
</pre>


    <p>Rajapintojen vahvuus on se, ettÃ¤ rajapinta on myÃ¶s <em>tyyppi</em>. Kaikki rajapinnan toteuttavista luokista tehdyt oliot ovat myÃ¶s rajapinnan tyyppisiÃ¤. TÃ¤mÃ¤ helpottaa sovellusten rakentamista huomattavasti.</p>

    <p>TehdÃ¤Ã¤n luokka <code>Rekisteri</code>, josta voimme hakea henkilÃ¶itÃ¤ tunnisteen perusteella. YksittÃ¤isten henkilÃ¶iden hakemisen lisÃ¤ksi <code>Rekisteri</code> tarjoaa metodin kaikkien henkilÃ¶iden hakemiseen listana.</p>

<pre class="sh_java">
public class Rekisteri {
    private HashMap&lt;String, Tunnistettava&gt; rekisteroidyt;

    public Rekisteri() {
        this.rekisteroidyt = new HashMap&lt;String, Tunnistettava&gt;();
    }

    public void lisaa(Tunnistettava lisattava) {
        this.rekisteroidyt.put(lisattava.getTunnus(), lisattava);
    }

    public Tunnistettava hae(String tunnus) {
        return this.rekisteroidyt.get(tunnus);
    }

    public List&lt;Tunnistettava&gt; haeKaikki() {
        return new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
    }
}
</pre>

<p>Rekisterin kÃ¤yttÃ¶ on helppoa</p>

<pre class="sh_java">
Rekisteri henkilokunta = new Rekisteri();
henkilokunta.lisaa( new Person("Pekka", "221078-123X") );
henkilokunta.lisaa( new Person("Jukka", "110956-326B") );

System.out.println( rekisteri.hae("280283-111A") );

Person loydetty = (Person)rekisteri.hae("110956-326B");
System.out.println( loydetty.getName() );
</pre>

<p>Koska henkilÃ¶t on talletettu rekisteriin <code>Tunnistettava</code>-tyyppisinÃ¤, joudumme muuntanaan ne takaisin oikeaan tyyppiin jos haluamme kÃ¤sitellÃ¤ henkilÃ¶itÃ¤ sellaisten metodien kautta, joita ei rajapinnassa ole mÃ¤Ã¤ritelty. NÃ¤in tapahtuu yllÃ¤ olevan esimerkin kahdella viimeisellÃ¤ rivillÃ¤.</p>

    <p>EntÃ¤ jos haluaisimme operaation, joka palauttaa rekisteriin talletetut henkilÃ¶t tunnisteen mukaan jÃ¤rjestettynÃ¤?</p>

    <p>Yksi luokka voi toteuttaa useamman rajapinnan, eli voimme toteuttaa <code>Person</code>-luokalla rajapinnan <code>Tunnistettava</code> lisÃ¤ksi viime viikolta tutun rajapinnan <code>Comparable</code>. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidÃ¤n toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalla <code>Person</code> rajapinta <code>Comparable</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Person implements Tunnistettava, Comparable&lt;Person&gt; {
    private String name;
    private String henkilotunnus;

    public Person(String name, String henkilotunnus) {
        this.name = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getName() {
        return this.name;
    }

    public String getPersontunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getPersontunnus();
    }

    @Override
    public int compareTo(Person toinen) {
        return this.getTunniste().compareTo(toinen.getTunniste());
    }
}
</pre>

    <p>Nyt voimme lisÃ¤tÃ¤ rekisterille metodin haeKaikkiJarjestyksessa:</p>

<pre class="sh_java">
    public List&lt;Tunnistettava&gt; haeKaikkiJarjestyksessa() {
        ArrayList&lt;Tunnistettava&gt; kaikki = new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());;
        Collections.sort(kaikki);
        return kaikki;
    }
</pre>

<p>Huomaamme kuitenkin, ettÃ¤ ratkaisumme ei toimi. Koska henkilÃ¶t on talletettu rekisteriin <code>Tunnitettava</code>-tyyppisinÃ¤, onkin HenkilÃ¶n toteutettava rajapinta <code>Comparable&lt;Tunnistettava&gt;</code> jotta rekisteri osaisi jÃ¤rjestÃ¤Ã¤ henkilÃ¶t metodin <code>Collections.sort()</code> avulla. Eli muutamme henkilÃ¶n toteuttamaa rajapintaa:</p>

<pre class="sh_java">
public class Person implements Tunnistettava, Comparable&lt;Tunnistettava&gt; {
    // ... 

    @Override
    public int compareTo(Tunnistettava toinen) {
        return this.getTunniste().compareTo(toinen.getTunniste());
    }
}
</pre>

<p>Nyt ratkaisu toimii!</p>

<p>Rekisteri on tÃ¤ysin tietÃ¤mÃ¤tÃ¶n sinne talletettavien olioiden todellisesta tyypistÃ¤. Voimmekin kÃ¤yttÃ¤Ã¤ luokkaa rekisteri myÃ¶s muuntyyppisten olioiden kuin henkilÃ¶iden rekisterÃ¶intiin, kunhan olioiden luokka vaan toteuttaa rajapinnan <code>Tunnistettava</code>. Esim. seuraavassa kÃ¤ytetÃ¤Ã¤n rekisteriÃ¤ kaupassa myytÃ¤vien tuotteiden hallintaan:</p>

<pre class="sh_java">
public class Tuote implements Tunnistettava {
    private String name;
    private String viivakoodi;
    private int varastosaldo;
    private int hinta;

    public Tuote(String name, String viivakoodi) {
        this.name = nimi;
        this.viivakoodi = viivakoodi;
    }

    public String getTunniste() {
        return viivakoodi;
    }

    // ...
}

Rekisteri tuotteet = new Rekisteri();
tuotteet.lisaa( new Tuote("maito", "11111111") );
tuotteet.lisaa( new Tuote("piimÃ¤", "11111112") );
tuotteet.lisaa( new Tuote("juusto", "11111113") );

System.out.println( tuotteet.hae("99999999") );

Tuote tuote = (Tuote)tuotteet.hae("11111112");
tuote.kasvataSaldoa(100);
tuote.muutaHinta(23);
</pre>

<p>Eli olemme tehneet luokasta <code>Rekisteri</code> melko yleiskÃ¤yttÃ¶isen pitÃ¤mÃ¤llÃ¤ sen riippumattomana konkreettisista luokista. MikÃ¤ tÃ¤hÃ¤nsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code> on rekisterin kanssa kÃ¤yttÃ¶kelpoinen. Metodin <code>haeKaikkiJarjestyksessÃ¤</code> toimiminen tosin edellyttÃ¤Ã¤ luokalta myÃ¶s vertailtavuuden eli Comparable&lt;Tunnistettava&gt;-rajapinnan toteuttamisen.</p>

<!--

    <p>TehdÃ¤Ã¤n luokka <code>Personrekisteri</code>, josta voimme hakea henkilÃ¶itÃ¤ <code>Tunnistettava</code>-rajapinnan avulla. YksittÃ¤isten henkilÃ¶iden hakemisen lisÃ¤ksi <code>Personrekisteri</code> tarjoaa metodin kaikkien henkilÃ¶iden hakemiseen listana.</p>

<pre class="sh_java">
public class Personrekisteri {
    private HashMap&lt;String, Person&gt; henkilot;

    public Personrekisteri(HashMap&lt;String, Person&gt; henkilot) {
        this.henkilot = henkilot;
    }

    public void lisaaPerson(Person henkilo) {
        this.henkilot.put(henkilo.getTunnus(), henkilo);
    }

    public void haePersonTunnuksella(Tunnistettava tunnistettava) {
        this.henkilot.get(tunnistettava.getTunnus());
    }

    public List&lt;Person&gt; getPersont() {
        return new ArrayList&lt;Person&gt;(henkilot.values());
    }
}
</pre>

    <p>EntÃ¤ jos haluaisimme jÃ¤rjestÃ¤Ã¤ henkilÃ¶listan aakkosjÃ¤rjestykseen?</p>


    <p>Yksi luokka voi toteuttaa useamman rajapinnan, eli voimme toteuttaa <code>Person</code>-luokalla rajapinnan <code>Tunnistettava</code> lisÃ¤ksi viime viikolta tutun rajapinnan <code>Comparable</code>. Useamman rajapinnan toteuttaminen tapahtuu erottamalla toteutettavat rajapinnat toisistaan pilkuilla (<code>public class ... implements <em>RajapintaEka</em>, <em>RajapintaToka</em> ...</code>). Toteuttaessamme useampaa rajapintaa, tulee meidÃ¤n toteuttaa kaikki rajapintojen vaatimat metodit. Toteutetaan seuraavaksi luokalla <code>Person</code> rajapinta <code>Comparable</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Person implements Tunnistettava, Comparable&lt;Person&gt; {
    private String name;
    private String henkilotunnus;

    public Person(String name, String henkilotunnus) {
        this.name = nimi;
        this.henkilotunnus = henkilotunnus;
    }

    public String getName() {
        return this.name;
    }

    public String getPersontunnus() {
        return this.henkilotunnus;
    }

    @Override
    public String getTunnus() {
        return getPersontunnus();
    }

    @Override
    public int compareTo(Person toinen) {
        return this.name.compareTo(toinen.getName());
    }
}
</pre>

    <p>Nyt henkilÃ¶stÃ¶rekisterin listaa-metodia voidaan laajentaa seuraavaan tapaan:</p>

<pre class="sh_java">
    public List&lt;Person&gt; getPersont() {
        ArrayList&lt;Person&gt; henkilot = new ArrayList&lt;Person&gt;(henkilot.values());
        Collections.sort(henkilot);
        return henkilot;
    }
</pre>

-->

<!--

    <h3>Kassaesimerkki</h3>

    <p>Pohditaan seuraavaksi kauppojen kassalaitteessa olevaan lukijalaitteeseen liittyvÃ¤Ã¤ tuotteen tunnistamistoimintoa. Oletetaan ettÃ¤ tuotteet sisÃ¤ltÃ¤vÃ¤t niihin liittyvÃ¤n viivakoodin, nimen ja hinnan. Tuotteita kuvastava <code>Tuote</code>-olio toteuttaa aiemmin mÃ¤Ã¤ritellyn rajapinnan <code>Tunnistettava</code>.</p>

<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava {
    private String viivakoodi;
    private String name;
    private int hinta;

    public Tuote(String viivakoodi, String name, int hinta) {
        this.viivakoodi = viivakoodi;
        this.name = nimi;
        this.hinta = hinta;
    }

    public String getName() {
        return this.name;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }
}
</pre>

    <p>Toteutetaan seuraavaksi <code>Lukijalaite</code>, joka osaa muuntaa tunnistettavat oliot tuotteiksi. Lukijalaitteen tulee lukea ja tunnistaa tuotteet rajapinnan <code>Tunnistettava</code>-avulla. Toteutetaan luokka <code>Lukijalaite</code> siten, ettÃ¤ se sisÃ¤ltÃ¤Ã¤ hajautustaulun, josta tuotteet lÃ¶ytyvÃ¤t tunnisteen perusteella. Lukijalaite on osa sovelluksen logiikkaa, joten lisÃ¤tÃ¤Ã¤n se pakkaukseen <code>sovellus.logiikka</code>.</p>

<pre class="sh_java">
package sovellus.logiikka;

public class Lukijalaite {
    private HashMap&lt;String, Tuote&gt; tuotteet;

    public Lukijalaite(HashMap&lt;String, Tuote&gt; tuotteet) {
        this.tuotteet = tuotteet;
    }

    public Tuote tunnista(Tunnistettava tunnistettava) {
        return this.tuotteet.get(tunnistettava.getTunnus());
    }
}
</pre>

    <p>Lukijalaite-olio palauttaa <code>Tuote</code>-olion jos sen tunnus lÃ¶ytyy lukijalaitteen sisÃ¤ltÃ¤mÃ¤stÃ¤ hajautustaulusta. Luodaan seuraavaksi kassa, joka kÃ¤yttÃ¤Ã¤ lukijalaitetta tuotteiden lisÃ¤Ã¤miseen ostettujen tuotteiden listalle. Kassalla on metodi <code>public void osta</code>, jolle annetaan luokan <code>Tunnistettava</code>-ilmentymÃ¤ parametrina. Ostaminen lisÃ¤Ã¤ lukijalaitteella tunnistetun tuotteen ostettujen listalle. Jos tuotetta ei tunnisteta, ei tehdÃ¤ mitÃ¤Ã¤n. Metodi <code>tulostaOstokset</code> tulostaa ostettujen tuotteiden nimet.</p>

<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getName());
        }
    }
}
</pre>

    <p>Huomaamme tÃ¤ssÃ¤ vaiheessa ettÃ¤ tuotteiden lukeminen listalta, joka on tulostettu tuotteiden lisÃ¤ysjÃ¤rjestyksessÃ¤, on hyvin kuormittavaa asiakkaalle. Muokataan tulostusta siten, ettÃ¤ tuotteet listataan aakkosjÃ¤rjestyksessÃ¤. LisÃ¤tÃ¤Ã¤n <code>Tuote</code>-luokalle rajapinta <code>Comparable</code>, jonka avulla tuotteet voidaan jÃ¤rjestÃ¤Ã¤ aakkosjÃ¤rjestyksessÃ¤.</p>

<pre class="sh_java">
package sovellus.domain;

public class Tuote implements Tunnistettava, Comparable&lt;Tuote&gt; {
    private String viivakoodi;
    private String name;
    private int hinta;

    public Tuote(String viivakoodi, String name, int hinta) {
        this.viivakoodi = viivakoodi;
        this.name = nimi;
        this.hinta = hinta;
    }

    public String getName() {
        return this.name;
    }

    public int getHinta() {
        return this.hinta;
    }

    @Override
    public String getTunnus() {
        return this.viivakoodi;
    }

    @Override
    public int compareTo(Tuote tuote) {
        return this.name.compareTo(tuote.getName());
    }
}
</pre>

    <p>Muokataan vielÃ¤ kassaan liittyvÃ¤Ã¤ toiminnallisuutta siten, ettÃ¤ tuotteet jÃ¤rjestetÃ¤Ã¤n tarvittaessa. Huomaa ettÃ¤ tuotteita tarvitsee jÃ¤rjestÃ¤Ã¤ vain silloin kun tuotteita <em>ostetaan</em>. Ostaminen on ainut tilanne, jossa tuotteita sisÃ¤ltÃ¤vÃ¤n listan jÃ¤rjestys mahdollisesti muuttuu. TÃ¤llÃ¶in ostokset ovat aina jÃ¤rjestyksessÃ¤ metodia <code>tulostaOstokset</code> kutsuttaessa.</p>

<pre class="sh_java">
package sovellus.domain;

public class Kassa {
    private Lukijalaite laite;
    private List&lt;Tuote&gt; tuotteet;

    public Kassa(Lukijalaite lukijalaite) {
        this.laite = lukijalaite;
        this.tuotteet = new ArrayList&lt;Tuote&gt;();
    }

    public void osta(Tunnistettava tunnistettava) {
        Tuote tunnistettu = this.laite.tunnista(tunnistettava);
        if (tunnistettu == null) {
            return;
        }

        this.tuotteet.add(tunnistettu);
        Collections.sort(this.tuotteet);
    }

    public void tulostaOstokset() {
        for(Tuote tuote: this.tuotteet) {
            System.out.println(tuote.getName());
        }
    }
}
</pre>

-->

<div>
<big><big><b>Muutama NetBeans-vihje</b></big></big>	

<ul>
<li> Kaikki NetBeans-vihjeet lÃ¶ytyvÃ¤t <a href="../ohpe/netbeans.html">tÃ¤Ã¤ltÃ¤</a> </li>
<p></p>

<li> <b>Implement all abstract methods</b>

<p>
Oletetaan ettÃ¤ ohjelmassasi on rajapinta <code>Rajapinta</code>, ja olet tekemÃ¤ssÃ¤ rajapinnan toteuttavaa luokkaa <code>Luokka</code>. Joudut nÃ¤kemÃ¤Ã¤n hieman vaivaa kirjoittaessasi toteuttavaan luokkaan rajapinnan mÃ¤Ã¤rittelemien metodien esittelyrivit.
</p>

<p>On kuitenkin mahdollista pyytÃ¤Ã¤ NetBeansia tÃ¤ydentÃ¤mÃ¤Ã¤n automaattisesti metodirungot toteuttavalle luokalle. Kun olet mÃ¤Ã¤ritellyt luokan toteuttavan rajapinnan, eli kirjoittanut</p>

<pre class="sh_java">
public class Luokka implements Rajapinta {
}
</pre>

<p>NetBeans vÃ¤rjÃ¤Ã¤ luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvÃ¤t koodiin!</p>

</li>

<li> <b>Clean and Build</b>

<p>
TietyissÃ¤ tilanteissa NetBeans saattaa mennÃ¤ sekaisin ja yrittÃ¤Ã¤ ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. YleensÃ¤ huomaat tilanteen siten, ettÃ¤ jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio lÃ¶ytyy Run-valikosta ja sen voi suorittaa myÃ¶s painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat kÃ¤Ã¤nnetyt versiot ja tekee uuden kÃ¤Ã¤nnÃ¶ksen.
</p>

</li>
</ul>
</div>

<div class="tehtavat">

  <h3>Muuttaminen</h3>

  <p>Muuttokuormaa pakattaessa esineitÃ¤ lisÃ¤tÃ¤Ã¤n muuttolaatikoihin siten, ettÃ¤ tarvittujen muuttolaatikoiden mÃ¤Ã¤rÃ¤ on mahdollisimman pieni. TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ simuloidaan esineiden pakkaamista muuttolaatikoihin. Jokaisella esineellÃ¤ on tilavuus, ja muuttolaatikoilla on maksimitilavuus.</p>


  <h4>Tavara ja Esine</h4>

  <p>Muuttomiehet siirtÃ¤vÃ¤t tavarat myÃ¶hemmin rekka-autoon (ei toteuteta tÃ¤ssÃ¤), joten toteutetaan ensin kaikkia esineitÃ¤ ja laatikoita kuvaava <code>Tavara</code>-rajapinta.</p>

  <p>Tavara-rajapinnan tulee mÃ¤Ã¤ritellÃ¤ metodi <code>int getTilavuus()</code>, jonka avulla tavaroita kÃ¤sittelevÃ¤t saavat selville kyseisen tavaran tilavuuden. Toteuta rajapinta <code>Tavara</code> pakkaukseen <code>muuttaminen.domain</code>.</p>

  <p>Toteuta seuraavaksi pakkaukseen <code>muuttaminen.domain</code> luokka <code>Esine</code>, joka saa konstruktorin parametrina esineen nimen (String) ja esineen tilavuuden (int). Luokan tulee toteuttaa rajapinta <code>Tavara</code>.</p>

  <p>LisÃ¤Ã¤ luokalle <code>Esine</code> myÃ¶s metodit <code>public String getName()</code> ja korvaa metodi <code>public String toString()</code> siten ettÃ¤ se tuotta characterStringja muotoa "<code>nimi (tilavuus dm^3)</code>". Esineen pitÃ¤isi toimia nyt jotakuinkin seuraavasti</p>

<pre class="sh_java">
    Tavara esine = new Esine("hammasharja", 2);
    System.out.println(esine);
</pre>

<pre>
hammasharja (2 dm^3)
</pre>

  <h4>Esine vertailtavaksi</h4>

  <p>Pakatessamme esineitÃ¤ muuttolaatikkoon haluamme aloittaa pakkaamisen jÃ¤rjestyksessÃ¤ olevista esineistÃ¤. Toteuta <code>Esine</code>-luokalla rajapinta <code>Comparable</code> siten, ettÃ¤ esineiden <em>luonnollinen jÃ¤rjestys</em> on tilavuuden mukaan nouseva. Kun olet toteuttanut esineellÃ¤ rajapinnan <code>Comparable</code>, tulee niiden toimia <code>Collections</code>-luokan <code>sort</code>-metodin kanssa seuraavasti.</p>


<pre class="sh_java">
    List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
    esineet.add(new Esine("passi", 2));
    esineet.add(new Esine("hammasharja", 1));
    esineet.add(new Esine("sirkkeli", 100));

    Collections.sort(esineet);
    System.out.println(esineet);
</pre>

<pre>
[hammasharja (1 dm^3), passi (2 dm^3), sirkkeli (100 dm^3)]
</pre>

  <h4>Muuttolaatikko</h4>

  <p>Toteuta tÃ¤mÃ¤n jÃ¤lkeen pakkaukseen <code>muuttaminen.domain</code> luokka <code>Muuttolaatikko</code>. Tee aluksi muuttolaatikolle seuraavat:</p>

<p>
  <ul>
    <li><code>public Muuttolaatikko(int maksimitilavuus)</code></li>Muuttolaatikko-luokan konstruktori. Saa parametrina muuttolaatikon maksimitilavuuden.<br/>
    <li><code>public boolean lisaaTavara(Tavara tavara)</code></li> LisÃ¤Ã¤ muuttolaatikkoon <code>Tavara</code>-rajapinnan toteuttaman esineen. Jos laatikkoon ei mahdu, metodi palauttaa arvon <code>false</code>. Jos tavara mahtuu laatikkoon, metodi palauttaa arvon <code>true</code>. Muuttolaatikon tulee tallettaa tavarat listaan.<br/>
  </ul>
</p>

  <p>Laita vielÃ¤  <code>Muuttolaatikko</code> toteuttamaan rajapinta <code>Tavara</code>. Metodilla <code>getTilavuus</code> tulee saada selville muuttolaatikossa olevien tavaroiden tÃ¤mÃ¤nhetkinen yhteistilavuus.</p>

  <h4>Esineiden pakkaaminen</h4>

  <p>Toteuta luokka <code>Pakkaaja</code> pakkaukseen <code>muuttaminen.logiikka</code>. Luokan <code>Pakkaaja</code> konstruktorille annetaan parametrina <code>int laatikoidenTilavuus</code>, joka mÃ¤Ã¤rittelee minkÃ¤ kokoisia muuttolaatikoita pakkaaja kÃ¤yttÃ¤Ã¤.</p>

  <p>Toteuta tÃ¤mÃ¤n jÃ¤lkeen luokalle metodi <code>public List&lt;Muuttolaatikko&gt; pakkaaTavarat(List&lt;Tavara&gt; tavarat)</code>, joka pakkaa tavarat muuttolaatikoihin.</p>

  <p>Tee metodista sellainen, ettÃ¤ kaikki parametrina annetussa listassa olevat tavarat pÃ¤Ã¤tyvÃ¤t palautetussa listassa oleviin muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin, joissa tavarat ovat suurempia kuin pakkaajan kÃ¤yttÃ¤mÃ¤ muuttolaatikon koko. Testit eivÃ¤t vÃ¤litÃ¤ siitÃ¤ kuinka tÃ¤yteen pakkaaja tÃ¤yttÃ¤Ã¤ muuttolaatikot.</p>

<p>Seuraavassa pakkaajan toimintaa demonstroiva esimerkki:</p>

<pre class="sh_java">
    // tavarat jotka haluamme pakata
    List&lt;Tavara&gt; tavarat = new ArrayList&lt;Tavara&gt;();
    tavarat.add(new Esine("passi", 2));
    tavarat.add(new Esine("hammasharja", 1));
    tavarat.add(new Esine("kirja", 4));
    tavarat.add(new Esine("sirkkeli", 8));

    // luodaan pakkaaja, joka kÃ¤yttÃ¤Ã¤ tilavuudeltaan 10:n kokoisia muuttolaatikoita
    Pakkaaja pakkaaja = new Pakkaaja(10);

    // pyydetÃ¤Ã¤n pakkaajaa pakkaamaan tavarat laatikoihin
    List&lt;Muuttolaatikko&gt; laatikot = pakkaaja.pakkaaTavarat( tavarat );

    System.out.println("laatikoita: "+laatikot.size());

    for (Muuttolaatikko laatikko : laatikot) {
        System.out.println("  laatikossa tavaraa: "+laatikko.getTilavuus()+" dm^3");
    }
</pre>

<p>Tulostuu:</p>

<pre>
laatikoita: 2
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
</pre>

<p>Pakkaaja on siis pakannut tavarat kahteen laatikkoon, ensimmÃ¤iseen laatikkoon on mennyt 3 ensimmÃ¤istÃ¤ tavaraa, yhteistilavuudeltaan 7, ja listan viimeinen tavara eli sirkkeli jonka tilavuus on 8 on mennyt toiseen laatikkoon. Testit eivÃ¤t aseta rajoitusta pakkaajan kÃ¤yttÃ¤vien muuttolaatioiden mÃ¤Ã¤rÃ¤lle, tavarat olisi siis voitu pakata vaikka jokainen eri laatikkoon, eli tuloste olisi ollut:</p>

<p>Tulostuu:</p>

<pre>
laatikoita: 4
  laatikossa tavaraa: 2 dm^3
  laatikossa tavaraa: 1 dm^3
  laatikossa tavaraa: 7 dm^3
  laatikossa tavaraa: 8 dm^3
</pre>

<p><strong>Huom:</strong> tehtÃ¤vÃ¤n testaamista helpottamaan kannatanee tehdÃ¤ luokalle <code>Muuttolaatikko</code> esim. toString-metodi, jonka avulla voi printata laatikon sisÃ¤llÃ¶n.</p>

<!--

  <h4>Tehokkaampi pakkaaminen</h4>

  <p>Alla on kuvattu erÃ¤s hieman tehokkaampi pakkaustapa <em>pseudokoodina</em>, eli ohjelmointikielen tapaisena koodina. Pseudokoodia kÃ¤ytetÃ¤Ã¤n muun muassa ohjelmointikieliriippumattomaan algoritmien eli ohjelmien kuvaamiseen.</p>

<pre>
pakkaaEsineet( esineet ):
    jarjesta( esineet )

    laatikot = [] // huom, kannattaa kÃ¤yttÃ¤Ã¤ ArrayListiÃ¤

    while esineet is not empty:
        Muuttolaatikko pakattu = pakkaaLaatikko( esineet )
        laatikot.add( pakattu )

    return laatikot

pakkaaLaatikko( esineet ):
    Muuttolaatikko laatikko = new Muuttolaatikko

    lisaaSuuria( esineet, laatikko )
    lisaaPienia( esineet, laatikko )

    return laatikko

lisaaSuuria( esineet, laatikko ):
    while esineet is not empty:
        esine = suurin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return

lisaaPienia(List esineet, Muuttolaatikko laatikko):
    while esineet is not empty:
        esine = pienin( esineet )

        if lisaa ( laatikko, esine ) == false:
            return
</pre>

  <p>Muokkaa luokkaa <code>Pakkaaja</code> siten, ettÃ¤ se toimii samoin tai paremmin kuin yllÃ¤ kuvattu lÃ¤hestymistapa.</p>

  <p>Metodissa <code>pakkaaEsineet</code> pakataan muuttolaatikoita niin pitkÃ¤Ã¤n kun <code>esineet</code>-listalla on esineitÃ¤. Muuttolaatikkoa pakattaessa algoritmi lisÃ¤Ã¤ laukkuun ensiksi niin paljon suurimpia esineitÃ¤ kuin laatikkoon mahtuu. Kun laatikkoon ei enÃ¤Ã¤ mahdu suurimpia esineitÃ¤, aletaan tÃ¤yttÃ¤mÃ¤Ã¤n sitÃ¤ pienimmillÃ¤ esineillÃ¤.</p>

  <p>Toteutuksesta: Kun esineesi ovat jÃ¤rjestyksessÃ¤, suurin tavara lÃ¶ytyy indeksistÃ¤ <code>esinelistan koko - 1</code>, pienin tavara lÃ¶ytyy indeksistÃ¤ <code>0</code>. ÃlÃ¤ kÃ¤ytÃ¤ tÃ¤ssÃ¤ <code>Collections.min</code> ja <code>Collections.max</code>-metodeja, sillÃ¤ ne eivÃ¤t osaa arvata ettÃ¤ <code>ArrayList</code>-lista on jo jÃ¤rjestyksessÃ¤.</p>

  <p>Poista esineitÃ¤ <code>esineet</code>-listalta sitÃ¤ mukaa kun niitÃ¤ on lisÃ¤tty muuttolaatikoihin. Sinun ei tarvitse varautua tilanteisiin joissa esineet ovat suurempia kuin muuttolaatikko.</p>

  <p><em>Huom!</em> Saadaksesi pisteen tÃ¤stÃ¤ viimeisestÃ¤ tehtÃ¤vÃ¤stÃ¤ algoritmisi tulee toimia <em>vÃ¤hintÃ¤Ã¤n</em> yhtÃ¤ hyvin kuin yllÃ¤ kuvattu algoritmi. HyvyydellÃ¤ tarkoitetaan sitÃ¤, ettÃ¤ pakkaukseen kulunut aika tulee olla vÃ¤hintÃ¤Ã¤n yhtÃ¤ pieni kuin pseudokoodiratkaisun. Muuttolaatikkojen mÃ¤Ã¤rÃ¤n tulee myÃ¶s olla vÃ¤hintÃ¤Ã¤n yhtÃ¤ pieni.</p>

  <p>Voit kÃ¤yttÃ¤Ã¤ seuraavaa metodia satunnaisten esineiden luomiseen.</p>

<pre class="sh_java">
    public static List&lt;Esine&gt; luoEsineet(int kpl, int maxTilavuus) {
        Random rand = new Random();

        List&lt;Esine&gt; esineet = new ArrayList&lt;Esine&gt;();
        for (int i = 0; i &lt; kpl; i++) {
            esineet.add(new Esine("hammasharja", 1 + rand.nextInt(maxTilavuus)));
        }

        return esineet;
    }
</pre>

  <p>YllÃ¤ kuvatulla algoritmilla pakkaamisen pitÃ¤isi toimia nopeasti jopa 100000 esinettÃ¤ sisÃ¤ltÃ¤villÃ¤ listoilla. Voit testata pakkaajasi nopeutta esimerkiksi seuraavasti:</p>

<pre class="sh_java">
        List&lt;Esine&gt esineet = luoEsineet(100000, 10);
        Pakkaaja pakkaaja = new Pakkaaja(50);

        long start = System.nanoTime();
        List&lt;Muuttolaatikko&gt laatikot = pakkaaja.pakkaaEsineet(esineet);
        long kulunutAika = ((System.nanoTime() - start) / 1000000);

        System.out.println("Pakkaukseen kului " + kulunutAika + " ms.");
        System.out.println("Tarvittiin " + laatikot.size() + " laatikkoa.");
</pre>

-->
</div>

<h2>Poikkeustilanteet</h2>

    <p>Poikkeustilanteet ovat tilanteita joissa ohjelman suoritus ei ole edennyt toivotusti. Ohjelma on saattanut esimerkiksi kutsua <em>null</em>-viitteeseen liittyvÃ¤Ã¤ metodia, jolloin kÃ¤yttÃ¤jÃ¤lle <em>heitetÃ¤Ã¤n</em> poikkeus <code>NullPointerException</code>. Jos yritÃ¤mme hakea taulukon ulkopuolella olevaa indeksiÃ¤, kÃ¤yttÃ¤jÃ¤lle heitetÃ¤Ã¤n poikkeus <code>IndexOutOfBoundsException</code>. Kaikki poikkeukset ovat tyyppiÃ¤ <code>Exception</code>.</p>

    <p>Poikkeukset kÃ¤sitellÃ¤Ã¤n <code>try { } catch (Exception e) { }</code> -lohkorakenteella. Avainsanan <code>try</code> aloittaman lohkon sisÃ¤llÃ¤ on <em>mahdollisesti</em> poikkeuksen heittÃ¤vÃ¤ ohjelmakoodi. Avainsanan <code>catch</code> aloittaman lohkon sisÃ¤llÃ¤ taas mÃ¤Ã¤ritellÃ¤Ã¤n mitÃ¤ tehdÃ¤Ã¤n jos try-lohkossa suoritettavassa koodissa tapahtuu poikkeus. Catch-lauseelle mÃ¤Ã¤ritellÃ¤Ã¤n kiinniotettavan poikkeuksen tyyppi (<code>catch (Exception e)</code>).</p>

<pre class="sh_java">
    try {
        // poikkeuksen mahdollisesti heittÃ¤vÃ¤ ohjelmakoodi
    } catch (Exception e) {
        // lohko johon pÃ¤Ã¤dytÃ¤Ã¤n poikkeustilanteessa
    }
</pre>

    <p>characterStringn numeroksi muuttava <code>Integer</code>-luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#parseInt(java.lang.String)" target="_blank">parseInt</a></code>-metodi heittÃ¤Ã¤ poikkeuksen <code>NumberFormatException</code> jos sille parametrina annettu characterString ei ole muunnettavissa numeroksi. Toteutetaan ohjelma, joka yrittÃ¤Ã¤ muuntaa kÃ¤yttÃ¤jÃ¤n syÃ¶ttÃ¤mÃ¤n characterStringn numeroksi.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);
    System.out.print("SyÃ¶tÃ¤ numero: ");

    int numero = Integer.parseInt(reader.nextLine());
</pre>

<pre>
SyÃ¶tÃ¤ numero: <font color="red">tatti</font>
<font color="red">Exception in thread "..." java.lang.NumberFormatException: For input string: "tatti"</font>
</pre>

    <p>YllÃ¤ oleva ohjelma heittÃ¤Ã¤ poikkeuksen kun kÃ¤yttÃ¤jÃ¤ syÃ¶ttÃ¤Ã¤ virheellisen numeron. Ohjelman suoritus pÃ¤Ã¤ttyy virhetilanteeseen, eikÃ¤ suoritusta voi enÃ¤Ã¤ jatkaa. LisÃ¤tÃ¤Ã¤n ohjelmaan poikkeuskÃ¤sittely. Kutsu, joka saattaa heittÃ¤Ã¤ poikkeuksen asetetaan <code>try</code>-lohkon sisÃ¤Ã¤n, ja virhetilanteessa tapahtuva toiminta <code>catch</code>-lohkon sisÃ¤Ã¤n. </p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("SyÃ¶tÃ¤ numero: ");

    try {
        int numero = Integer.parseInt(reader.nextLine());
    } catch (Exception e) {
        System.out.println("Et syÃ¶ttÃ¤nyt kunnollista numeroa.");
    }
</pre>

<pre>
SyÃ¶tÃ¤ numero: <font color="red">5</font>
</pre>

<pre>
SyÃ¶tÃ¤ numero: <font color="red">enpÃ¤s!</font>
Et syÃ¶ttÃ¤nyt kunnollista numeroa.
</pre>

    <p>Avainsanan <code>try</code> mÃ¤Ã¤rittelemÃ¤n lohkon sisÃ¤ltÃ¤ siirrytÃ¤Ã¤n <code>catch</code>-lohkoon heti poikkeuksen tapahtuessa.  Visualisoidaan tÃ¤tÃ¤ lisÃ¤Ã¤mÃ¤llÃ¤ tulostuslause <code>try</code>-lohkossa metodia <code>Integer.parseInt</code> kutsuvan rivin jÃ¤lkeen.</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    System.out.print("SyÃ¶tÃ¤ numero: ");

    try {
        int numero = Integer.parseInt(reader.nextLine());
        System.out.println("Hienosti syÃ¶tetty!");
    } catch (Exception e) {
        System.out.println("Et syÃ¶ttÃ¤nyt kunnollista numeroa.");
    }
</pre>


<pre>
SyÃ¶tÃ¤ numero: <font color="red">5</font>
Hienosti syÃ¶tetty!
</pre>

<pre>
SyÃ¶tÃ¤ numero: <font color="red">enpÃ¤s!</font>
Et syÃ¶ttÃ¤nyt kunnollista numeroa.
</pre>

    <p>Ohjelmalle syÃ¶tetty characterString <code>enpÃ¤s!</code> annetaan parametrina <code>Integer.parseInt</code>-metodille, joka heittÃ¤Ã¤ poikkeuksen jos parametrina saadun characterStringn muuntaminen luvuksi epÃ¤onnistuu. Huomaa ettÃ¤ <code>catch</code>-lohkossa oleva koodi suoritetaan <em>vain</em> poikkeustapauksissa -- muulloin ohjelma ei pÃ¤Ã¤se sinne.</p>

    <p>TehdÃ¤Ã¤n luvun muuntajasta hieman hyÃ¶dyllisempi: TehdÃ¤Ã¤n siitÃ¤ metodi, joka kysyy numeroa yhÃ¤ uudestaan kunnes kÃ¤yttÃ¤jÃ¤ syÃ¶ttÃ¤Ã¤ oikean numeron. Metodista pÃ¤Ã¤see pois <em>vain</em> jos kÃ¤yttÃ¤jÃ¤ syÃ¶ttÃ¤Ã¤ oikean luvun.</p>

<pre class="sh_java">
public int lueLuku(Scanner lukija) {
    while (true) {
        System.out.print("SyÃ¶tÃ¤ numero: ");

        try {
            int numero = Integer.parseInt(reader.nextLine());
            return numero;
        } catch (Exception e) {
            System.out.println("Et syÃ¶ttÃ¤nyt kunnollista numeroa.");
        }
    }
}
</pre>

    <p>Metodin <code>lueLuku</code> kutsuminen voisi toimia esimerkiksi seuraavasti</p>

<pre>
SyÃ¶tÃ¤ numero: <font color="red">enpÃ¤s!</font>
Et syÃ¶ttÃ¤nyt kunnollista numeroa.
SyÃ¶tÃ¤ numero: <font color="red">Matilla on ovessa tatti.</font>
Et syÃ¶ttÃ¤nyt kunnollista numeroa.
SyÃ¶tÃ¤ numero: <font color="red">43</font>

</pre>


<h3>Poikkeusten heittÃ¤minen</h3>

    <p>Metodit ja konstruktorit voivat <em>heittÃ¤Ã¤</em> poikkeuksia. HeitettÃ¤viÃ¤ poikkeuksia on karkeasti ottaen kahdenlaisia. On poikkeuksia jotka on pakko kÃ¤sitellÃ¤, ja on poikkeuksia joita ei ole pakko kÃ¤sitellÃ¤. Pakosti kÃ¤siteltÃ¤vÃ¤t poikkeukset kÃ¤sitellÃ¤Ã¤n joko <code>try-catch</code> -lohkossa, tai <em>heittÃ¤mÃ¤llÃ¤ ne ulos metodista</em>. </p>

<p>
Ohjelmoinnin perusteiden tehtÃ¤vÃ¤n <em>kellosta olio</em> bonusversiossa kerrottiin, ettÃ¤ ohjelma saadaan viivyttÃ¤mÃ¤Ã¤n itseÃ¤Ã¤n sekunnin verran kutsumalla komentoa <code>Thread.sleep(1000)</code>. Komento saattaa heittÃ¤Ã¤ poikkeuksen, joka on <em>pakko</em> kÃ¤sitellÃ¤. Poikkeuksen kÃ¤sittely siis tapahtuu  <code>try-catch</code> -lauseella, seuraavassa esimerkissÃ¤ olemme vÃ¤littÃ¤mÃ¤ttÃ¤ mahdollisista poikkeustilanteista ja jÃ¤timme <code>catch</code>-lohkon tyhjÃ¤ksi:</p>

<pre class="sh_java">
    try {
        // nukutaan 1000 millisekuntia
        Thread.sleep(1000);
    } catch (Exception e) {
        // ei tehdÃ¤ mitÃ¤Ã¤n poikkeustilanteessa
    }
</pre>

    <p>Metodeissa on myÃ¶s mahdollista jÃ¤ttÃ¤Ã¤ poikkeus itse kÃ¤sittelemÃ¤ttÃ¤ ja <em>siirtÃ¤Ã¤ vastuu</em> poikkeuksen kÃ¤sittelystÃ¤ metodin kutsujalle. Vastuun siirto tapahtuu heittÃ¤mÃ¤llÃ¤ poikkeus metodista eteenpÃ¤in sanomalla <code>throws Exception</code>.</p>

<pre class="sh_java">
    public void nuku(int sekuntia) <strong>throws Exception</strong> {
        Thread.sleep(sekuntia * 1000);   // nyt try-catchia ei tarvita!
    }
</pre>

    <p>Nyt metodia <code>nuku</code>-kutsuvan metodin tulee joko kÃ¤sitellÃ¤ poikkeus <code>try-catch</code> -lohkossa, tai siirtÃ¤Ã¤ poikkeuksen kÃ¤sittelyn vastuuta eteenpÃ¤in heittÃ¤Ã¤ poikkeus eteenpÃ¤in. Joskus poikkeuksen kÃ¤sittelyÃ¤ pakoillaan viimeiseen asti, ja <code>main</code>-metodikin heittÃ¤Ã¤ poikkeuksen kÃ¤siteltÃ¤vÃ¤ksi eteenpÃ¤in:</p> 
<pre class="sh_java">
public class MainProgram {
   public static void main(String[] args) throws Exception {
       // ...
   }
}
</pre>

<p>TÃ¤llÃ¶in poikkeus pÃ¤Ã¤tyy Javan virtuaalikoneelle, joka keskeyttÃ¤Ã¤ ohjelman suorituksen poikkeukseen johtavan virheen tapahtuessa.</p>

    <p>Osa poikkeuksista, kuten <code>Integer.parseInt</code>-metodin heittÃ¤mÃ¤ <code>NumberFormatException</code>, on sellaisia joihin ohjelmoijan ei ole pakko varautua. Poikkeukset, joihin kÃ¤yttÃ¤jÃ¤n ei tarvitse varautua ovat aina myÃ¶s tyyppiÃ¤ tyyppiÃ¤ <code>RuntimeException</code>, palaamme siihen <em>miksi</em> muuttujilla voi olla useita eri tyyppejÃ¤ tarkemmin ensi viikolla.</p>

    <p>Voimme itse heittÃ¤Ã¤ poikkeuksen lÃ¤hdekoodista <code>throw</code>-komennolla. Esimerkiksi <code>NumberFormatException</code>-luokasta luodun poikkeuksen heittÃ¤minen tapahtuisi komennolla <code>throw new NumberFormatException()</code>.</p>

    <p>ErÃ¤s poikkeus johon kÃ¤yttÃ¤jÃ¤n ei ole pakko varautua on <code>IllegalArgumentException</code>. Poikkeuksella <code>IllegalArgumentException</code> kerrotaan ettÃ¤ metodille tai konstruktorille annettujen parametrien arvot ovat <em>vÃ¤Ã¤rÃ¤nlaiset</em>. IllegalArgumentException-poikkeusta kÃ¤ytetÃ¤Ã¤n esimerkiksi silloin kun halutaan varmistaa ettÃ¤ parametreilla on tietyt arvot. Luodaan luokka <code>Arvosana</code>, joka saa konstruktorin parametrina kokonaislukutyyppisen arvosanan.</p>

<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>

    <p>Haluamme seuraavaksi <em>validoida</em> Arvosana-luokan konstruktorin parametrina saadun arvon. Arvosanan tulee olla aina vÃ¤lillÃ¤ 0-5. Jos arvosana on jotain muuta, haluamme <em>heittÃ¤Ã¤ poikkeuksen</em>. LisÃ¤tÃ¤Ã¤n <code>Arvosana</code>-luokan konstruktoriin ehtolause, joka tarkistaa onko arvosana arvovÃ¤lin 0-5 ulkopuolella. Jos on, heitetÃ¤Ã¤n poikkeus <code>IllegalArgumentException</code> sanomalla <code>throw new IllegalArgumentException("Arvosanan tulee olla vÃ¤lillÃ¤ 0-5");</code>.</p>

<pre class="sh_java">
public class Arvosana {
    private int arvosana;

    public Arvosana(int arvosana) {
        if (arvosana &lt; 0 || arvosana &gt; 5) {
            throw new IllegalArgumentException("Arvosanan tulee olla vÃ¤lillÃ¤ 0-5");
        }
        this.arvosana = arvosana;
    }

    public int getArvosana() {
        return this.arvosana;
    }
}
</pre>

<pre class="sh_java">
    Arvosana arvosana = new Arvosana(3);
    System.out.println(arvosana.getArvosana());

    Arvosana virheellinenArvo = new Arvosana(22);
    // tapahtuu poikkeus, tÃ¤stÃ¤ ei jatketa eteenpÃ¤in
</pre>

<pre>
3
Exception in thread "..." java.lang.IllegalArgumentException: Arvosanan tulee olla vÃ¤lillÃ¤ 0-5
</pre>


<div class="tehtavat">
  <h3>Parametrien validointi</h3>

  <p>Harjoitellaan hieman parametrien validointia <code>IllegalArgumentException</code>-poikkeuksen avulla. TehtÃ¤vÃ¤pohjassa tulee kaksi luokkaa, <code>Person</code> ja <code>Calculator</code>. Muuta luokkia seuraavasti:</p>

  <h4>HenkilÃ¶n validointi</h4>

  <p>Luokan <code>Person</code> konstruktorin tulee varmistaa ettÃ¤ parametrina annettu nimi ei ole null, tyhjÃ¤ tai yli 40 merkkiÃ¤ pitkÃ¤. MyÃ¶s iÃ¤n tulee olla vÃ¤liltÃ¤ 0-120. Jos joku edellÃ¤olevista ehdoista ei pÃ¤de, tulee konstruktorin heittÃ¤Ã¤ <code>IllegalArgumentException</code>-poikkeus.</p>

  <h4>Laskimen validointi</h4>

  <p>Luokan <code>Calculator</code> metodeja tulee muuttaa seuraavasti: Metodin <code>kertoma</code> tulee toimia vain jos parametrina annetaan ei-negatiivinen luku (0 tai suurempi). Metodin <code>binomikerroin</code> tulee toimia vain jos parametrit ovat ei-negatiivisia ja osajoukon koko on pienempi kuin joukon koko. Jos jompikumpi metodeista saa epÃ¤kelpoja arvoja metodikutsujen yhteydessÃ¤, tulee metodien heittÃ¤Ã¤ poikkeus <code>IllegalArgumentException</code>.</p>

<h3>Sensorit ja lÃ¤mpÃ¶tilan mittausta</h3>

<p>Kakki sovelluksessa oleva koodi tulee sijoittaa pakkaukseen <code>sovellus</code>.</p>

<p>KÃ¤ytÃ¶ssÃ¤mme on seuraava rajapinta:</p>

<pre class="sh_java">
public interface Sensori {
    boolean onPaalla();  // palauttaa true jos sensori on pÃ¤Ã¤llÃ¤
    void paalle();       // kÃ¤ynnistÃ¤ sensorin
    void poisPaalta();   // sulkee sensorin
    int mittaa();        // palauttaa sensorin lukeman jos sensori on pÃ¤Ã¤llÃ¤
                         // jos sensori ei pÃ¤Ã¤llÃ¤ heittÃ¤Ã¤ poikkeuksen IllegalStateException
}
</pre>

<h4>Vakiosensori</h4>

<p>Tee luokka <code>Vakiosensori</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

<p>Vakiosensori on koko ajan pÃ¤Ã¤llÃ¤. Metodien paalle ja poisPaalta kutsuminen ei tee mitÃ¤Ã¤n. Vakiosensorilla tulee olla konstruktori, jonka parametrina on kokonaisluku. Metodikutsu <code>mittaa</code> palauttaa aina konstruktorille parametrina annetun luvun.
</p>

<p>Esimerkki:</p>

<pre class="sh_java">
public static void main(String[] args) {
  Vakiosensori kymppi = new Vakiosensori(10);
  Vakiosensori miinusViis = new Vakiosensori(-5);

  System.out.println( kymppi.mittaa() );
  System.out.println( miinusViis.mittaa() );

  System.out.println( kymppi.onPaalla() );
  kymppi.poisPaalta();
  System.out.println( kymppi.onPaalla() );
}
</pre>

<p>Tulostuu:</p>

<pre>
10
-5
true
true
</pre>

<h4>Lampomittari</h4>

<p>Tee luokka <code>Lampomittari</code> joka toteuttaa rajapinnan <code>Sensori</code>.</p>

<p>
Aluksi lÃ¤mpÃ¶mittari on poissa pÃ¤Ã¤ltÃ¤. Kutsuttaessa metodia <code>mittaa</code> kun mittari on pÃ¤Ã¤llÃ¤ mittari arpoo luvun vÃ¤liltÃ¤ -30...30 ja palauttaa sen kutsujalle. Jos mittari ei ole pÃ¤Ã¤llÃ¤, heitetÃ¤Ã¤n poikkeus </code>IllegalStateException</code>. 
</p>

<h4>Keskiarvosensori</h4>

<p>Tee luokka <code>Keskiarvosensori</code> joka toteuttaa rajapinnan </code>Sensori</code>.</p>

<p>
Keskiarvosensori sisÃ¤ltÃ¤Ã¤ useita sensoreita. Rajapinnan <code>Sensori</code> mÃ¤Ã¤rittelemien metodien lisÃ¤ksi keskiarvosensorilla on metodi 
<code>public void lisaaSensori(Sensori lisattava)</code> jonka avulla keskiarvosensorin hallintaan lisÃ¤tÃ¤Ã¤n uusi sensori.
</p>

<p>
Keskiarvosensori on pÃ¤Ã¤llÃ¤ silloin kuin <em>kaikki</em> sen sisÃ¤ltÃ¤vÃ¤t sensorit ovat pÃ¤Ã¤llÃ¤. Kun keskiarvosensori kÃ¤ynnistetÃ¤Ã¤n, tÃ¤ytyy kaikkien sen sisÃ¤ltÃ¤vien sensorien kÃ¤ynnistyÃ¤ jos ne eivÃ¤t ole kÃ¤ynnissÃ¤. Kun keskiarvosensori suljetaan, tÃ¤ytyy ainakin yhden sen sisÃ¤ltÃ¤vÃ¤n sensorin mennÃ¤ pois pÃ¤Ã¤ltÃ¤. Saa myÃ¶s kÃ¤ydÃ¤ niin ettÃ¤ kaikki sen sisÃ¤ltÃ¤vÃ¤t sensorit menevÃ¤t pois pÃ¤Ã¤ltÃ¤.
</p>

<p>
Keskiarvosensorin metodi <code>mittaa</code> palauttaa sen sisÃ¤ltÃ¤mien sensoreiden lukemien keskiarvon (koska paluuarvo on <code>int</code>, pyÃ¶ristyy lukema alaspÃ¤in kuten kokonaisluvuilla tehdyissÃ¤ jakolaskuissa). Jos keskiarvosensorin metodia <code>mittaa</code> kutsutaan sensorin ollessa poissa pÃ¤Ã¤ltÃ¤, tai jos keskiarvosensorille ei vielÃ¤ ole lisÃ¤tty yhtÃ¤Ã¤n sensoria heitetÃ¤Ã¤n poikkeus <code>IllegalStateException</code>.
</p>

<p>Seuraavassa sensoreja kÃ¤yttÃ¤vÃ¤ esimerkkiohjelma (huomaa, ettÃ¤ sekÃ¤ LÃ¤mpÃ¶mittarin ettÃ¤ Keskiarvosensorin konstruktorit ovat parametrittomia):</p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();         
    kumpula.paalle();
    System.out.println("lÃ¤mpÃ¶tila Kumpulassa "+kumpula.mittaa() + " astetta");
    
    Sensori kaisaniemi = new Lampomittari();        
    Sensori helsinkiVantaa = new Lampomittari();
        
    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);
        
    paakaupunki.paalle();
    System.out.println("lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla "+paakaupunki.mittaa() + " astetta");     
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat tietenkin arvotuista lÃ¤mpÃ¶tiloista):</p>

<pre class="sh_java">
lÃ¤mpÃ¶tila Kumpulassa -7 astetta
lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla -10 astetta
</pre>

<p><b>Huom:</b> kannatata kÃ¤yttÃ¤Ã¤ Vakiosensori-oliota keskiarvosensorin testaamiseen!</p>

<h4>Kaikki mittaukset</h4>

<p>LisÃ¤Ã¤ luokalle Keskiarvosensori metodi <code>public List&lt;Integer&gt; mittaukset()</code>, joka palauttaa listana kaikkien keskiarvosensorin avulla suoritettujen mittausten tulokset. Seuraavassa esimerkki metodin toiminnasta: </p>

<pre class="sh_java">
public static void main(String[] args) {
    Sensori kumpula = new Lampomittari();         
    Sensori kaisaniemi = new Lampomittari();        
    Sensori helsinkiVantaa = new Lampomittari();
        
    Keskiarvosensori paakaupunki = new Keskiarvosensori();
    paakaupunki.lisaaSensori(kumpula);
    paakaupunki.lisaaSensori(kaisaniemi);
    paakaupunki.lisaaSensori(helsinkiVantaa);
        
    paakaupunki.paalle();
    System.out.println("lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla "+paakaupunki.mittaa() + " astetta");     
    System.out.println("lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla "+paakaupunki.mittaa() + " astetta");    
    System.out.println("lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla "+paakaupunki.mittaa() + " astetta");    

    System.out.println("mittaukset: "+paakaupunki.mittaukset());
}
</pre>

<p>tulostuu (tulostetut lukuarvot riippuvat jÃ¤lleen arvotuista lÃ¤mpÃ¶tiloista):</p>

<pre class="sh_java">
lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla -10 astetta
lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla -4 astetta
lÃ¤mpÃ¶tila PÃ¤Ã¤kaupunkiseudulla 5 astetta

mittaukset: [-10, -4, 5]
</pre>

</div>




<h3>Poikkeukset ja rajapinnat</h3>

    <p>Rajapintaluokilla ei ole metodirunkoa, mutta metodimÃ¤Ã¤rittely on vapaasti rajapinnan suunnittelijan toteutettavissa. Rajapintaluokat voivat mÃ¤Ã¤ritellÃ¤ myÃ¶s poikkeusten heiton. Esimerkiksi seuraavan rajapinnan <code>Tiedostopalvelin</code> toteuttavat luokat heittÃ¤vÃ¤t <em>mahdollisesti</em> poikkeuksen <code>lataa</code>- ja <code>tallenna</code>-metodissa.</p>

<pre class="sh_java">
public interface Tiedostopalvelin {
    String lataa(String tiedosto) throws Exception;
    void tallenna(String tiedosto, String characterString) throws Exception;
}
</pre>

    <p>Jos rajapinta mÃ¤Ã¤rittelee metodeille <code>throws Exception</code>-mÃ¤Ã¤reet, eli ettÃ¤ metodit heittÃ¤vÃ¤t mahdollisesti poikkeuksen, tulee samat mÃ¤Ã¤reet olla myÃ¶s rajapinnan toteuttavassa luokassa. Luokan ei kuitenkaan ole pakko heittÃ¤Ã¤ poikkeusta kuten alla olevasta esimerkistÃ¤ nÃ¤kee.</p>

<pre class="sh_java">
public class Tekstipalvelin implements Tiedostopalvelin {

    private Map&lt;String, String&gt; data;

    public Tekstipalvelin() {
        this.data = new HashMap&lt;String, String&gt;();
    }

    @Override
    public String lataa(String tiedosto) throws Exception {
        return this.data.get(tiedosto);
    }

    @Override
    public void tallenna(String tiedosto, String characterString) throws Exception {
        this.data.put(tiedosto, characterString);
    }
}
</pre>

<h3>Poikkeuksen tiedot</h3>

    <p>Poikkeusten kÃ¤sittelytoiminnallisuuden sisÃ¤ltÃ¤mÃ¤ <code>catch</code>-lohko mÃ¤Ã¤rittelee catch-osion sisÃ¤llÃ¤ poikkeuksen johon varaudutaan <code>catch (<em>Exception e</em>)</code>. Poikkeuksen tiedot tallennetaan <code>e</code>-muuttujaan.</p>

<pre class="sh_java">
    try {
        // ohjelmakoodi, joka saattaa heittÃ¤Ã¤ poikkeuksen
    } catch (Exception e) {
        // poikkeuksen tiedot ovat tallessa muuttujassa e
    }
</pre>

    <p>Luokka <code>Exception</code> tarjoaa hyÃ¶dyllisiÃ¤ metodeja. Esimerkiksi metodi <code>printStackTrace()</code> tulostaa <em>polun</em>, joka kertoo mistÃ¤ pÃ¤Ã¤dyttiin poikkeukseen. Tutkitaan seuraavaa metodin <code>printStackTrace()</code> tulostamaa virhettÃ¤.</p>

<pre>
Exception in thread "main" java.lang.NullPointerException
  at pakkaus.Luokka.tulosta(Luokka.java:43)
  at pakkaus.Luokka.main(Luokka.java:29)
</pre>

    <p>Poikkeuspolun lukeminen tapahtuu alhaalta ylÃ¶spÃ¤in. Alimpana on ensimmÃ¤inen kutsu, eli ohjelman suoritus on alkanut luokan <code>Luokka</code> metodista <code>main()</code>. Luokan <code>Luokka</code> main-metodin rivillÃ¤ 29 on kutsuttu metodia <code>tulosta()</code>. Metodin <code>tulosta</code> rivillÃ¤ 43 on tapahtunut poikkeus <code>NullPointerException</code>. Poikkeuksen tiedot ovatkin hyvin hyÃ¶dyllisiÃ¤ virhekohdan selvittÃ¤misessÃ¤.</p>


<h2>Tiedoston lukeminen</h2>

    <p>Huomattava osa ohjelmista kÃ¤sittelee jollain tavalla tallennettua tietoa. Otetaan ensiaskeleet tiedostojen kÃ¤sittelyyn Javassa. Javan API tarjoaa luokan <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">File</a>, jonka sisÃ¤ltÃ¶ voidaan lukea kurssilla jo tutuksi tulleen <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html" target="_blank">Scanner</a>-luokan avulla.</p>

    <p>Luokan <code>File</code> <a href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_blank">API-kuvausta</a> lukiessamme huomaamme <code>File</code>-luokalla on konstruktori <code>File(String pathname)</code> (<em>Creates a new File instance by converting the given pathname string into an abstract pathname</em>). Voimme siis antaa avattavan tiedoston polun <code>File</code>-luokan konstruktorille.</p>

    <p><em>NetBeans-ohjelmointiympÃ¤ristÃ¶ssÃ¤ tiedostoille on oma vÃ¤lilehti nimeltÃ¤ <em>Files</em>. Files-vÃ¤lilehdellÃ¤ on mÃ¤Ã¤ritelty kaikki projektiin liittyvÃ¤t tiedostot. Jos projektin <em>juureen</em>, eli ei yhdenkÃ¤Ã¤n hakemiston sisÃ¤lle, lisÃ¤tÃ¤Ã¤n tiedosto, voidaan siihen viitata projektin sisÃ¤ltÃ¤ suoraan tiedoston nimellÃ¤. Tiedosto-olion luominen tapahtuu antamalla sille parametrina polku tiedostoon, esimerkiksi seuraavasti</em></p>

<pre class="sh_java">
    File tiedosto = new File("tiedoston-nimi.txt");
</pre>

    <p>Scanner-luokan konstruktorille voi antaa myÃ¶s muita lukemislÃ¤hteitÃ¤ kuin <code>System.in</code>-syÃ¶ttÃ¶virran. LukemislÃ¤hteenÃ¤ voi olla nÃ¤ppÃ¤imistÃ¶n lisÃ¤ksi muun muassa tiedosto. Scanner tarjoaa tiedoston lukemiseen samat metodit kuin nÃ¤ppÃ¤imistÃ¶ltÃ¤ syÃ¶tetyn syÃ¶tteen lukemiseen. Seuraavassa esimerkissÃ¤ avataan tiedosto ja tulostetaan kaikki tiedoston sisÃ¤ltÃ¤mÃ¤n tekstit <code>System.out.println</code>-komennolla Lopuksi tiedosto suljetaa komennolla <code>close</code>.</p>

<pre class="sh_java">
        // tiedosto mistÃ¤ luetaan
        File tiedosto = new File("tiedosto.txt");

        Scanner lukija = new Scanner(tiedosto);
        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
</pre>

    <p>Scanner-luokan konstruktori <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Scanner.html#Scanner(java.io.File)" target="_blank">public Scanner(File source)</a></code> (<em>Constructs a new Scanner that produces values scanned from the specified file.</em>) heittÃ¤Ã¤ <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileNotFoundException.html" target="_blank">FileNotFoundException</a></code>-poikkeuksen jos luettavaa tiedostoa ei lÃ¶ydy. Poikkeus <code>FileNotFoundException</code> ei ole tyyppiÃ¤ <code>RuntimeException</code>, joten se tulee joko kÃ¤sitellÃ¤ tai heittÃ¤Ã¤ eteenpÃ¤in. TÃ¤ssÃ¤ vaiheessa riittÃ¤Ã¤ tietÃ¤Ã¤ ettÃ¤ ohjelmointiympÃ¤ristÃ¶ kertoo jos sinun tulee kÃ¤sitellÃ¤ poikkeus erikseen. Luodaan ensin vaihtoehto, jossa poikkeus kÃ¤sitellÃ¤Ã¤n tiedostoa avattaessa.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) {
        // tiedosto mistÃ¤ luetaan
        Scanner lukija = null;

        try {
            lukija = new Scanner(tiedosto);
        } catch (Exception e) {
            System.out.println("Tiedoston lukeminen epÃ¤onnistui. Virhe: " + e.getMessage());
            return; // poistutaan metodista
        }

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
    }
</pre>

    <p>Toinen vaihtoehto poikkeuksen kÃ¤sittelyyn on poikkeuksen kÃ¤sittelyvastuun siirtÃ¤minen metodin kutsujalle. Poikkeuksen kÃ¤sittelyvastuu siirretÃ¤Ã¤n metodin kutsujalle lisÃ¤Ã¤mÃ¤llÃ¤ metodiin mÃ¤Ã¤re <code>throws <em>PoikkeuksenTyyppi</em></code>, eli esimerkiksi <code>throws Exception</code> sillÃ¤ kaikki poikkeukset ovat tyyppiÃ¤ <code>Exception</code>. Kun metodilla on mÃ¤Ã¤re <code>throws Exception</code>, tietÃ¤vÃ¤t kaikki sitÃ¤ kutsuvat ettÃ¤ se saattaa heittÃ¤Ã¤ poikkeuksen johon tulee varautua.</p>

<pre class="sh_java">
    public void lueTiedosto(File tiedosto) throws Exception {
        // tiedosto mistÃ¤ luetaan
        Scanner lukija = new Scanner(tiedosto);

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            System.out.println(rivi);
        }

        reader.close();
    }
</pre>

    <p>Esimerkki avaa tiedoston <code>tiedosto.txt</code> projektin juuripolusta ja tulostaa sen rivi riviltÃ¤ kÃ¤yttÃ¤jÃ¤lle nÃ¤kyville. Lopuksi lukija suljetaan, jolloin tiedosto myÃ¶s suljetaan. MÃ¤Ã¤re <code>throws Exception</code> kertoo ettÃ¤ metodi saattaa heittÃ¤Ã¤ poikkeuksen. Samanlaisen mÃ¤Ã¤reen voi laittaa kaikkiin metodeihin jotka kÃ¤sittelevÃ¤t tiedostoja.</p>

    <p>Huomaa ettÃ¤ <code>Scanner</code>-olio ei liitÃ¤ rivinvaihtomerkkejÃ¤ osaksi <code>nextLine</code>-metodin palauttamaa characterStringa. Yksi vaihtoehto tiedoston lukemiseen siten, ettÃ¤ rivinvaihdot sÃ¤ilyvÃ¤t, on lisÃ¤tÃ¤ jokaisen rivin jÃ¤lkeen rivinvaihtomerkki:</p>

<pre class="sh_java">
    public String lueTiedostocharacterStringon(File tiedosto) throws Exception {
        // tiedosto mistÃ¤ luetaan
        Scanner lukija = new Scanner(tiedosto);

        String characterString = "";

        while (reader.hasNextLine()) {
            String rivi = reader.nextLine();
            characterString += rivi;
            characterString += "\n";
        }

        reader.close();
        return characterString;
    }
</pre>

    <p>Koska kÃ¤ytÃ¤mme tiedoston lukemiseen <code>Scanner</code>-luokkaa, kÃ¤ytÃ¶ssÃ¤mme on kaikki Scanner-luokan tarjoamat metodit. Esimerkiksi metodi <code>hasNext()</code> palauttaa totuusarvon <code>true</code>, jos luettavassa tiedostossa on vielÃ¤ luettavaa jÃ¤ljellÃ¤, ja metodi <code>next()</code> lukee seuraavan sanan metodin palauttamaan <code>String</code>-olioon. </p>

    <p>Seuraava ohjelma luo <code>Scanner</code>-olion, joka avaa tiedoston <code>tiedosto.txt</code>. Sen jÃ¤lkeen se tulostaa joka viidennen sanan tiedostosta.</p>

<pre class="sh_java">
        File tiedosto = new File("tiedosto.txt");
        Scanner lukija = new Scanner(tiedosto);

        int monesko = 0;
        while (reader.hasNext()) {
            monesko++;
            String sana = reader.next();

            if (monesko % 5 == 0) {
                System.out.println(sana);
            }
        }
</pre>

    <p>Alla on ensin luetun tiedoston sisÃ¤ltÃ¤mÃ¤ teksti ja sitten ohjelman tulostus</p>

<pre>
Poikkeukset (exceptions) ovat &quot;poikkeuksellisia tilanteita&quot; kesken normaalin ohjelmansuorituksen:
tiedosto loppuu, characterString ei kelpaa kokonaisluvuksi, odotetun olion tilalla onkin null-arvo,
taulukon indeksi menee ohjelmointivirheen takia sopimattomaksi, ...
</pre>

<pre>
tilanteita&quot;
loppuu,
odotetun
taulukon
sopimattomaksi,
</pre>

<h3>MerkistÃ¶ongelmista</h3>

    <p>TekstiÃ¤ tiedostosta luettaessa (tai tiedostoon tallennettaessa) Java joutuu pÃ¤Ã¤ttelemÃ¤Ã¤n kÃ¤yttÃ¶jÃ¤rjestelmÃ¤n kÃ¤yttÃ¤mÃ¤n merkistÃ¶n. MerkistÃ¶n tuntemusta tarvitaan sekÃ¤ tekstin tallentamiseen tietokoneen kovalevylle binÃ¤Ã¤rimuotoiseksi ettÃ¤ binÃ¤Ã¤rimuotoisen datan tekstiksi kÃ¤Ã¤ntÃ¤miseksi.</p>

    <p>MerkistÃ¶ihin on kehitetty standardeja, joista "UTF-8" on nykyÃ¤Ã¤n yleisin. UTF-8 -merkistÃ¶ sisÃ¤ltÃ¤Ã¤ sekÃ¤ jokapÃ¤ivÃ¤isessÃ¤ kÃ¤ytÃ¶ssÃ¤ olevien aakkosten ettÃ¤ erikoisempien merkkien kuten Japanin kanji-merkistÃ¶n tai shakkipelin nappuloiden tallentamiseen ja lukemiseen tarvittavat tiedot. OhjelmointimielessÃ¤ merkistÃ¶Ã¤ voi hieman yksinkertaistaen ajatella hajautustauluna merkistÃ¤ numeroon ja numerosta merkkiin. MerkistÃ¤ numeroon oleva hajautustaulu kuvaa minkÃ¤laisena binÃ¤Ã¤rilukuna kukin merkki tallennetaan tiedostoon. Numerosta merkkiin oleva hajautustaulu taas kuvaa miten tiedostoa luettaessa saadut values muunnetaan merkeiksi.</p>

    <p>LÃ¤hes jokaisella kÃ¤yttÃ¶jÃ¤rjestelmÃ¤valmistajalla on myÃ¶s omat standardinsa. Osa tukee ja haluaa osallistua avoimien standardien kÃ¤yttÃ¶Ã¶n, osa ei. MikÃ¤li sinulla on ongelmia Ã¤Ã¤kkÃ¶sellisten sanojen kanssa (eritoten mac ja windows kÃ¤yttÃ¤jÃ¤t) voit kertoa <code>Scanner</code>-oliota luodessa kÃ¤ytettÃ¤vÃ¤n merkistÃ¶n. TÃ¤llÃ¤ kurssilla kÃ¤ytÃ¤mme aina merkistÃ¶Ã¤ "UTF-8".</p>

    <p>UTF-8 -merkistÃ¶Ã¤ kÃ¤yttÃ¤vÃ¤n tiedostoa lukevan Scanner-olion voi luoda seuraavasti:</p>

<pre class="sh_java">
    File tiedosto = new File("esimerkkitiedosto.txt");
    Scanner lukija = new Scanner(tiedosto, "UTF-8");
</pre>

    <p>Toinen vaihtoehto merkistÃ¶n asettamiseksi on ympÃ¤ristÃ¶muuttujan kÃ¤yttÃ¤minen. Macintosh ja Windows-kÃ¤yttÃ¤jÃ¤t voivat asettaa ympÃ¤ristÃ¶muuttujan <code>JAVA_TOOL_OPTIONS</code> arvoksi characterStringn <code>-Dfile.encoding=UTF8</code>. TÃ¤llÃ¶in Java kÃ¤yttÃ¤Ã¤ oletuksena aina UTF-8-merkistÃ¶Ã¤.</p>

<div class="tehtavat">
  <h3>Rivit joilla sana</h3>

<p>Tee luokka <code>Tulostaja</code> ja sille konstruktori <code>public Tulostaja(String tiedostonNimi)</code>, joka saa parametrinaan tiedoston nimeÃ¤ vastaavan characterStringn sekÃ¤ metodi <code>public void tulostaRivitJoilla(String sana)</code> tulostaa tiedostosta ne rivit, joilla esiintyy parametrina oleva sana (<em>pienet ja isot kirjaimet erotellaan tehtÃ¤vÃ¤ssÃ¤, eli esim. "koe" ja "Koe" eivÃ¤t ole sama sana</em>), rivit tulostetaan samassa jÃ¤rjestyksessÃ¤ missÃ¤ ne ovat tiedostossa. </p>

<p>Jos parametri on tyhjÃ¤ characterString, tulostuu koko tiedosto.</p> 

<p>Jos tiedostoa ei ole olemassa, heittÃ¤Ã¤ konstruktori aiheutuvan poikkeuksen eteenpÃ¤in, eli try-catch-komentoa ei tarvita, riittÃ¤Ã¤ mÃ¤Ã¤ritellÃ¤ konstruktori seuraavasti:</p>

<pre class="sh_java">
public Tulostaja {

   public Tulostaja(String tiedostonNimi) throws Exception {
      // ...
   }

   // ...
}
</pre>

<p>Projektisi default-pakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>src/testitiedosto.txt</code>. Tiedoston sisÃ¤ltÃ¶ on seuraava:</p> 

<pre>
SiinÃ¤ vanha VÃ¤inÃ¤mÃ¶inen
katseleikse kÃ¤Ã¤nteleikse 
Niin tuli kevÃ¤tkÃ¤kÃ¶nen
nÃ¤ki koivun kasvavaksi 
MiksipÃ¤ on tuo jÃ¤tetty
koivahainen kaatamatta  
Sanoi vanha VÃ¤inÃ¤mÃ¶inen 
</pre>

<p>Seuraavassa esimerkki ohjelman toiminnasta testitiedostolla:</p>

<pre class="sh_java">
    Tulostaja tulostaja = new Tulostaja("src/testitiedosto.txt");

    tulostaja.tulostaRivitJoilla("VÃ¤inÃ¤mÃ¶inen");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("Frank Zappa");
    System.out.println("-----");
    tulostaja.tulostaRivitJoilla("");
    System.out.println("-----");
</pre>

<p>Tulostuu:</p>

<pre>
SiinÃ¤ vanha VÃ¤inÃ¤mÃ¶inen
Sanoi vanha VÃ¤inÃ¤mÃ¶inen 
-----
-----
SiinÃ¤ vanha VÃ¤inÃ¤mÃ¶inen
katseleikse kÃ¤Ã¤nteleikse 
Niin tuli kevÃ¤tkÃ¤kÃ¶nen
nÃ¤ki koivun kasvavaksi 
MiksipÃ¤ on tuo jÃ¤tetty
koivahainen kaatamatta  
Sanoi vanha VÃ¤inÃ¤mÃ¶inen 
</pre>

<p>Projektipohjasta lÃ¶ytyy myÃ¶s koko Kalevala, tiedoston nimi on <code>src/kalevala.txt</code></p>


  <h3>Tiedoston analyysi</h3>

  <p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ tehdÃ¤Ã¤n sovellus tiedoston rivi- ja merkkimÃ¤Ã¤rÃ¤n laskemiseen.</p>

  <h4>Rivien laskeminen</h4>


  <p>Tee pakkaukseen <code>tiedosto</code> luokka <code>Analyysi</code>, jolla on konstruktori <code>public Analyysi(File tiedosto)</code>. Toteuta luokalle metodi <code>public int rivimaara()</code>, joka palauttaa konstruktorille annetun tiedoston rivimÃ¤Ã¤rÃ¤n.</p>

<p>Metodi ei saa olla "kertakÃ¤yttÃ¶inen", eli sen pitÃ¤Ã¤ tuottaa oikea tulos myÃ¶s usealla perÃ¤kkÃ¤isellÃ¤ kutsulla. Huomaa, ettÃ¤ kun teet tiedostoa vastaavan Scanner-olion, ja luet tiedoston koko sisÃ¤llÃ¶n <code>nextLine</code>-komennoilla, et voi kÃ¤yttÃ¤Ã¤ enÃ¤Ã¤ <em>samaa</em> skanneria tiedoston uudelleenlukemiseen!</p>

<p><strong>Huom:</strong> jos testit sanovat <em>timeout</em>, et todennÃ¤kÃ¶isesti muista lukea tiedostoa ollenkaan, eli <code>nextLine</code>-kutsut puuttuvat!</p>

  <h4>Merkkien laskeminen</h4>

  <p>Toteuta luokkaan <code>Analyysi</code> metodi <code>public int merkkeja()</code>, joka palauttaa luokan konstruktorille annetun tiedoston merkkien mÃ¤Ã¤rÃ¤n.</p>

<p>Metodi ei saa olla "kertakÃ¤yttÃ¶inen", eli sen pitÃ¤Ã¤ tuottaa oikea tulos myÃ¶s usealla perÃ¤kkÃ¤isellÃ¤ kutsulla.</p>

  <p>Voit itse pÃ¤Ã¤ttÃ¤Ã¤ miten reagoidaan jos konstruktorin parametrina saatua tiedostoa ei ole olemassa.</p>

<p>Projektisi testipakkauksessa on testausta varten tiedosto <em>testitiedosto.txt</em>. Ohjelmasta avatessa tiedoston nimeksi tulee antaa <code>test/testitiedosto.txt</code>. Tiedoston sisÃ¤ltÃ¶ on seuraava:</p> 

<pre>
rivejÃ¤ tÃ¤ssÃ¤ on 3 ja merkkejÃ¤ 
koska rivinvaihdotkin ovat
merkkejÃ¤
</pre>

<p>Ohjelman toiminta testaustiedostolla:</p>

<pre class="sh_java">
    File tiedosto = new File("src/testitiedosto.txt");
    Analyysi analyysi = new Analyysi(tiedosto);
    System.out.println("RivejÃ¤: " + analyysi.rivimaara());
    System.out.println("MerkkejÃ¤: " + analyysi.merkkeja());
</pre>

<pre>
RivejÃ¤: 3
MerkkejÃ¤: 67
</pre>

  <h3>Sanatutkimus</h3>

  <p>Tee luokka Sanatutkimus, jolla voi tehdÃ¤ erilaisia tutkimuksia tiedoston sisÃ¤ltÃ¤mille sanoille. Toteuta luokka pakkaukseen <code>sanatutkimus</code>.</p>

  <p>Kotimaisten kielten tutkimuskeskus (Kotus) on julkaissut netissÃ¤ suomen kielen sanalistan. TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ kÃ¤ytetÃ¤Ã¤n listan muokattua versiota, joka lÃ¶ytyy tehtÃ¤vÃ¤pohjasta <code>src</code>-hakemistosta nimellÃ¤ <code>sanalista.txt</code>, eli suhteellisesta polusta <code>"src/sanalista.txt"</code>.
Koska sanalista on varsin pitkÃ¤, on projektissa testausta varten myÃ¶s <code>pienilista.txt</code> joka lÃ¶ytyy polusta <code>"src/pienilista.txt"</code>.
</p>

  <p><strong>MikÃ¤li sinulla on ongelmia Ã¤Ã¤kkÃ¶sellisten sanojen kanssa</strong> (mac ja windows kÃ¤yttÃ¤jÃ¤t) luo <code>Scanner</code>-olio antaen sille parametrina merkistÃ¶ "UTF-8" seuraavasti: <code> Scanner lukija = new Scanner(tiedosto, "UTF-8");</code> Ongelmat liittyvÃ¤t erityisesti testien suoritukseen.</p>

  <h4 class="req">Sanojen mÃ¤Ã¤rÃ¤</h4>

  <p>Luo Sanatutkimus-luokalle konstruktori <code>public Sanatutkimus(File tiedosto)</code> joka luo uuden Sanatutkimus-olion, joka tutkii parametrina annettavaa tiedostoa.</p>

  <p>Tee luokkaan metodi <code>public int sanojenMaara()</code>, joka lukee tiedostossa olevat sanat ja tulostaa niiden mÃ¤Ã¤rÃ¤n. TÃ¤ssÃ¤ vaiheessa sanoilla ei tarvitse tehdÃ¤ mitÃ¤Ã¤n, riittÃ¤Ã¤ laskea niiden mÃ¤Ã¤rÃ¤. Voit olettaa tÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤, ettÃ¤ tiedostossa on vain yksi sana riviÃ¤ kohti.</p>


  <h4 class="req">z-kirjain</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimenZSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, joissa on z-kirjain. TÃ¤llaisia sanoja ovat esimerkiksi jazz ja zombi.</p>

  <h4 class="req">l-pÃ¤Ã¤te</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kirjaimeenLPaattyvatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka pÃ¤Ã¤ttyvÃ¤t l-kirjaimeen. TÃ¤llaisia sanoja ovat esimerkiksi kannel ja sammal.</p>

  <p><em>Huom! Jos luet tiedoston uudestaan ja uudestaan jokaisessa metodissa huomaat viimeistÃ¤Ã¤n tÃ¤ssÃ¤ vaiheessa copy-paste koodia. Kannattaa miettiÃ¤ olisiko tiedoston lukeminen helpompi tehdÃ¤ osana konstruktoria tai metodina, jota konstruktori kutsuu. Metodeissa voitaisiin kÃ¤yttÃ¤Ã¤ tÃ¤llÃ¶in jo luettua listaa ja luoda siitÃ¤ aina uusi, hakuehtoihin sopiva lista. Viikolle 6 on tulossa oikeaoppinen tapa copypasten eliminointiin.</em></p>

  <h4>Palindromit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; palindromit()</code>, joka palauttaa tiedoston kaikki sanat, jotka ovat palindromeja. TÃ¤llaisia sanoja ovat esimerkiksi ala ja enne.</p>

  <h4 class="req">Kaikki vokaalit</h4>

  <p>Tee luokkaan metodi <code>public List&lt;String&gt; kaikkiVokaalitSisaltavatSanat()</code>, joka palauttaa tiedoston kaikki sanat, jotka sisÃ¤ltÃ¤vÃ¤t kaikki suomen kielen vokaalit (aeiouyÃ¤Ã¶). TÃ¤llaisia sanoja ovat esimerkiksi myÃ¶hÃ¤iselokuva ja ympÃ¤ristÃ¶nsuojelija.</p>
</div>







<h2>Hajautustauluista ja joukoista</h2>

<h3>Monta arvoa yhtÃ¤ avainta kohti</h3>

<p>Kuten muistamme, voi HashMapiin tallettaa tiettyÃ¤ avainta kohti vaan yhden arvon. Seuraavassa esimerkissÃ¤ tallennamme henkilÃ¶iden puhelinnumeroita HashMap:iin.</p>

<pre class="sh_java">
  Map&lt;String, String&gt; puhelinnumerot = new HashMap&lt;String, String&gt;();

  puhelinnumerot.put("Pekka", "040-12348765");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );

  puhelinnumerot.put("Pekka", "09-111333");

  System.out.println( "Pekan numero: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Kuten odotettua, tulostus kertoo, ettÃ¤</p>

<pre>
Pekan numero: 040-12348765
Pekan numero: 09-111333
</pre>

<p>EntÃ¤ jos haluaisimmekin tallettaa yhtÃ¤ avainta kohti useita arvoja, eli esim yhtÃ¤ henkilÃ¶Ã¤ kohti monta puhelinnumeroa? Onnistuuko se HashMap:in avulla? KyllÃ¤, esim. tallettamalla HashMap:iin Stringien sijaan esim. ArrayList:eja arvoiksi, voidaan yhteen avaimeen "liittÃ¤Ã¤" useampia oliota. Muutetaan puhelinnumeroiden talletustapaa seuraavasti:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();
</pre>

<p>Nyt siis HashMapissa jokaiseen avaimeen littyy lista. Vaikka new-komento luokin HashMapin, on mapin sisÃ¤lle talletettavat listatu luotava erikseen. Seuraavassa lisÃ¤tÃ¤Ã¤n HashMapiin Pekalle kaksi numeroa ja tulostataan ne:</p>

<pre class="sh_java">
  Map&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();

  // liitetÃ¤Ã¤n Pekka-nimeen ensin tyhjÃ¤ ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );
  
  // ja lisÃ¤tÃ¤Ã¤n Pekkaa vastaavalle listalle puhelinnumero
  puhelinnumerot.get("Pekka").add("040-12348765");
 
  // ja lisÃ¤tÃ¤Ã¤n toinenkin puhelinnumero
  puhelinnumerot.get("Pekka").add("09-111333");

  System.out.println( "Pekan numerot: "+ puhelinnumerot.get("Pekka") );
</pre>

<p>Tulostuu</p>

<pre>
Pekan numero: [040-12348765, 09-111333]
</pre>

<p>MÃ¤Ã¤rittelimme muuttujan puhelinnumero tyypiksi <code>Map&lt;String, ArrayList&lt;String&gt;&gt;</code> eli Map jonka avaimena on characterString ja arvona characterStringja sisÃ¤ltÃ¤vÃ¤ lista. Konkreettinen toteutus, eli luotu olio oli HasMap. Olisimme voineet mÃ¤Ã¤ritellÃ¤ muuttujan myÃ¶s seuraavasti:
</p>

<pre class="sh_java">
Map&lt;String, List&lt;String&gt;&gt; puhelinnumero = new HashMap&lt;String, List&lt;String&gt;&gt;();
</pre>

<p>
Eli nyt muuttujan tyyppi on Map, jonka avaimena on characterString ja arvona characterStringja sisÃ¤ltÃ¤vÃ¤ <code>List</code>, joka siis on rajapinta joka mÃ¤Ã¤rittelee listatoiminnallisuuden, esim. ArrayList toteuttaa tÃ¤mÃ¤n rajapinnan. Konkreettinen olio on HashMap.
</p>

<p>HashMap:iin talletettavat arvot siis ovat <code>List&lt;String&gt;</code>-rajapinnan toteuttavia konkreettisia olioita, esim. ArrayListeja. Eli lisÃ¤ys HashMapiin tapahtuu edelleen seuraavasti:</p>

<pre class="sh_java">
  // liitetÃ¤Ã¤n Pekka-nimeen ensin tyhjÃ¤ ArrayList
  puhelinnumerot.put( "Pekka", new  ArrayList&lt;String&gt;() );

  // ...
</pre>

<p>Jatkossa pyrkimyksemme on kÃ¤yttÃ¤Ã¤ tyyppimÃ¤Ã¤rittelyissÃ¤ konkreettisten luokkien, esim. <code>HashMap</code> ja <code>ArrayList</code> sijaan niitÃ¤ vastaavia rajapintoja <code>Map</code> ja <code>List</code>.</p>

<h3>Joukoista</h3>

    <p>Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/Set.html" target="_blank">Set</a></code> kuvaa joukon toiminnallisuutta. Toisin kuin listalla, on joukossa kutakin alkioita korkeintaan yksi kappale, eli yhtÃ¤n samanlaista oliota ei ole kahdesti. Olioiden samankaltaisuuden tarkistaminen toteutetaan <code>equals</code> ja <code>hashCode</code> -metodeja kÃ¤yttÃ¤mÃ¤llÃ¤. </p>

<p>Yksi rajapinnan <code>Set</code> toteuttava luokka on  <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html" target="_blank">HashSet</a></code>. Toteutetaan sen avulla luokka <code>Tehtavakirjanpito</code>, joka tarjoaa mahdollisuuden tehtÃ¤vien kirjanpitoon ja tehtyjen tehtÃ¤vien tulostamiseen. Oletetaan ettÃ¤ tehtÃ¤vÃ¤t ovat aina kokonaislukuja.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Set&lt;Integer&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashSet&lt;Integer&gt;();
    }

    public void lisaa(int tehtava) {
        this.tehdytTehtavat.add(tehtava);
    }

    public void tulosta() {
        for (int tehtava: this.tehdytTehtavat) {
            System.out.println(tehtava);
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(1);
        kirjanpito.lisaa(2);
        kirjanpito.lisaa(3);

        kirjanpito.tulosta();
</pre>

<pre>
1
2
3
</pre>

    <p>YllÃ¤ oleva ratkaisu toimii tilanteessa, jossa emme tarvitse tietoa kÃ¤yttÃ¤jistÃ¤ eri kÃ¤yttÃ¤jien tekemistÃ¤ tehtÃ¤vistÃ¤. Muutetaan tehtÃ¤vien tallennuslogiikkaa siten, ettÃ¤ tehtÃ¤vÃ¤t tallennetaan <em>kÃ¤yttÃ¤jÃ¤kohtaisesti</em> hajautustaulua hyÃ¶dyntÃ¤en. KÃ¤yttÃ¤jÃ¤t tunnistetaan kÃ¤yttÃ¤jÃ¤n yksilÃ¶ivÃ¤llÃ¤ characterStringlla (esimerkiksi opiskelijanumero), ja jokaiselle kÃ¤yttÃ¤jÃ¤lle on oma joukko tehdyistÃ¤ tehtÃ¤vistÃ¤.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new HashMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        // huomaa miten uudelle kÃ¤yttÃ¤jÃ¤lle on lisÃ¤ttÃ¤vÃ¤ HashMapiin ensin tyhjÃ¤ tehtÃ¤vÃ¤joukko
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new HashSet&lt;Integer&gt;());
        }

        // haetaan ensin kÃ¤yttÃ¤jÃ¤n tehtÃ¤vÃ¤t sisÃ¤ltÃ¤vÃ¤ joukko ja tehdÃ¤Ã¤n siihen lisÃ¤ys
        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);

        // edellinen olisi onnitunut myÃ¶s ilman apumuuttujaa seuraavasti
        //  this.tehdytTehtavat.get(kayttaja).add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Pekka: [4]
Mikael: [3, 4]
</pre>


    <p>Huomaamme ettÃ¤ kÃ¤yttÃ¤jien nimet eivÃ¤t tulostu esimerkissÃ¤	 jÃ¤rjestyksessÃ¤. TÃ¤mÃ¤ selittyy sillÃ¤ ettÃ¤ <code>HashMap</code>-tyyppisessÃ¤ hajautustaulussa alkioiden tallennus tapahtuu <code>hashCode</code>-metodin palauttaman hajautusarvon perusteella, eikÃ¤ se liity millÃ¤Ã¤n tavalla alkioiden jÃ¤rjestykseen.</p>
 
<div class="tehtavat">

<h3>Sanakirja usealle kÃ¤Ã¤nnÃ¶kselle</h3>

<p>TehdÃ¤Ã¤n hieman laajennettu versio viikolla 1 tehdystÃ¤ sanakirjasta. TehtÃ¤vÃ¤nÃ¤si on toteuttaa pakkaukseen <code>sanakirja</code> luokka <code>OmaUseanKaannoksenSanakirja</code>, joka voi tallettaa yhden tai useamman kÃ¤Ã¤nnÃ¶ksen jokaiselle sanalle. Luokan tulee toteuttaa tehtÃ¤vÃ¤pohjassa annettu rajapinta <code>UseanKaannoksenSanakirja</code>, jossa on seuraavat toiminnot:</p>

<p>
  <ul>
    <li><code>public void lisaa(String sana, String kaannos)</code></li>lisÃ¤Ã¤ kÃ¤Ã¤nnÃ¶ksen sanalle sÃ¤ilyttÃ¤en vanhat kÃ¤Ã¤nnÃ¶kset<br/>
    <li><code>public Set&lt;String&gt; kaanna(String sana)</code></li>palauttaa <code>Set</code>-olion, jossa on kaikki kÃ¤Ã¤nnÃ¶kset sanalle, tai <code>null</code>-viitteen, jos sanaa ei ole sanakirjassa<br/>
    <li><code>public void poista(String sana)</code></li>poistaa sanan ja sen kaikki kÃ¤Ã¤nnÃ¶kset sanakirjasta<br/>
  </ul>
</p>

<p>KÃ¤Ã¤nnÃ¶kset kannattanee tallentaa yllÃ¤ olevan esimerkin Tehtavakirjanpito tapaan <code>Map&lt;String, Set&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package sanakirja;

import java.util.Set;

public interface UseanKaannoksenSanakirja {
    void lisaa(String sana, String kaannos);
    Set&lt;String&gt; kaanna(String sana);
    void poista(String sana);
}
</pre>

<p>Esimerkkiohjelma:</p>

<pre class="sh_java">
    UseanKaannoksenSanakirja sanakirja = new OmaUseanKaannoksenSanakirja();
    sanakirja.lisaa("kuusi", "six");
    sanakirja.lisaa("kuusi", "spruce");

    sanakirja.lisaa("pii", "silicon");
    sanakirja.lisaa("pii", "pi");

    System.out.println(sanakirja.kaanna("kuusi"));
    sanakirja.poista("pii");
    System.out.println(sanakirja.kaanna("pii"));
</pre>

<p>Tulostuu:</p>

<pre>
[six, spruce]
null
</pre>

</div>



<div class="tehtavat">
  <h3>Duplikaattien poistaja</h3>

  <p>TehtÃ¤vÃ¤nÃ¤si on toteuttaa pakkaukseen <code>tyokalut</code> luokka <code>OmaDuplikaattienPoistaja</code>, joka tallettaa annetut characterStringt siten, ettÃ¤ annetuista characterStringista poistetaan samanlaiset characterStringt (eli duplikaatit). LisÃ¤ksi luokka pitÃ¤Ã¤ kirjaa duplikaattien mÃ¤Ã¤rÃ¤stÃ¤. Luokan tulee toteuttaa tehtÃ¤vÃ¤pohjassa annettu rajapinta <code>DuplikaattienPoistaja</code>, jossa on seuraavat toiminnot:</p>

  <p>
    <ul>
      <li><code>public void lisaa(String characterString)</code></li> tallettaa characterStringn, jos se ei ole duplikaatti<br/>
      <li><code>public int getHavaittujenDuplikaattienMaara()</code></li> palauttaa tÃ¤hÃ¤n mennessÃ¤ havaittujen duplikaattien mÃ¤Ã¤rÃ¤n<br/>
      <li><code>public Set&lt;String&gt; getUniikitcharacterStringt()</code></li> palauttaa <code>Set&lt;String&gt;</code>-rajapinnan toteuttavan olion, jossa on kaikki uniikit lisÃ¤tyt characterStringt (ei siis duplikaatteja!). Jos characterStringja ei ole, palautetaan tyhjÃ¤ joukko-olio.<br/>
      <li><code>public void tyhjenna()</code></li> poistaa talletetut characterStringt ja nollaa havaittujen duplikaattien mÃ¤Ã¤rÃ¤n<br/>
    </ul>
  </p>

  <p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tyokalut;

import java.util.Set;

public interface DuplikaattienPoistaja {
    void lisaa(String characterString);
    int getHavaittujenDuplikaattienMaara();
    Set&lt;String&gt; getUniikitcharacterStringt();
    void tyhjenna();
}
</pre>

  <p>Rajapintaa voi kÃ¤yttÃ¤Ã¤ esimerkiksi nÃ¤in:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        DuplikaattienPoistaja poistaja = new OmaDuplikaattienPoistaja();
        poistaja.lisaa("eka");
        poistaja.lisaa("toka");
        poistaja.lisaa("eka");

        System.out.println("Duplikaattien mÃ¤Ã¤rÃ¤ nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        poistaja.lisaa("vika");
        poistaja.lisaa("vika");
        poistaja.lisaa("uusi");

        System.out.println("Duplikaattien mÃ¤Ã¤rÃ¤ nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit characterStringt: " +
            poistaja.getUniikitcharacterStringt());

        poistaja.tyhjenna();

        System.out.println("Duplikaattien mÃ¤Ã¤rÃ¤ nyt: " +
            poistaja.getHavaittujenDuplikaattienMaara());

        System.out.println("Uniikit characterStringt: " +
            poistaja.getUniikitcharacterStringt());
    }
</pre>

  <p>YllÃ¤ oleva ohjelma tulostaisi: (characterStringjen jÃ¤rjestys saa vaihdella, sillÃ¤ ei ole merkitystÃ¤)</p>

<pre>
Duplikaattien mÃ¤Ã¤rÃ¤ nyt: 1
Duplikaattien mÃ¤Ã¤rÃ¤ nyt: 2
Uniikit characterStringt: [eka, toka, vika, uusi]
Duplikaattien mÃ¤Ã¤rÃ¤ nyt: 0
Uniikit characterStringt: []
</pre>

</div>

<h3>Yksi olio useammassa eri listassa, Map-rakenteessa tai joukossa</h3>

<p>Kuten muistamme, oliomuuttujat ovat viitetyyppisiÃ¤, eli muuttuja ei tallenna olioa itseÃ¤Ã¤n vaan viitteen olioon. Vastaavasti jos olio laitetaan esim. ArrayListaan, ei listalle talleteta olioa itseÃ¤Ã¤n vaan <em>viite</em> olioon. MikÃ¤Ã¤n ei estÃ¤kÃ¤Ã¤n tallentamasta samaan olioon viitettÃ¤ esim. useaan listaan tai HashMapiin. </p>

<p>Tarkastellaan esimerkkinÃ¤ kirjastoa joka tallettaa kirjat hashMapeihin sekÃ¤ kirjailijan ettÃ¤ kirjan isbn-numeron perusteella. TÃ¤mÃ¤n lisÃ¤ksi kirjasto pitÃ¤Ã¤ kaikkia lainassa olevia sekÃ¤ hyllyssÃ¤ olevia kirjoja omalla listallaan.</p>

<pre class="sh_java">
public class Book {
    private String ISBN;
    private String kirjailija;
    private String name;
    private int vuosi;
    // ...
}

public class Booksto {
    private Map&lt String, Book&gt kirjaIsbnNumeronPerusteella;
    private Map&lt String, List&ltString&gt&gt kirjatBookilijanPerusteella;
    private List&ltBook&gt lainassaOlevatBookt;
    private List&ltBook&gt hyllyssaOlevatBookt;

    public void lisaaBookKokoelmaan(Book uusiBook){
        kirjaIsbnNumeronPerusteella.put(uusiBook.getIsbn(), uusiBook);
        kirjatBookilijanPerusteella.get(uusikirja.getBookilija()).add(uusiBook);
        hyllyssaOlevatBookt.add(uusiBook);
    }

    public Book haeBookIsbnNumeronPerusteella(String isbn){
        return kirjaIsbnNumeronPerusteella.get(isbn);
    }

    // ...
}
</pre>

<p>Jos olio on yhtÃ¤aikaa useassa kokoelmassa (listalla, joukossa tai map-rakenteessa), on kiinnitettÃ¤vÃ¤ erityistÃ¤ huomiota, ettÃ¤ kokoelmien tila on konsistentti. Jos esim. kirja pÃ¤Ã¤tetÃ¤Ã¤n poistaa, on se poistettava molemmista mapeista sekÃ¤ lainassa/hyllyssÃ¤ olevia kuvaavalta listalta.</p>

<div class="tehtavat">

  <h3>Numerotiedustelu</h3>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. ÃlÃ¤ myÃ¶skÃ¤Ã¤n kÃ¤ytÃ¤ staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillÃ¤ suorituskerroilla jÃ¤Ã¤neet arvot todennÃ¤kÃ¶isesti hÃ¤iritsevÃ¤t testien toimintaa!</b></p>


<p>TehdÃ¤Ã¤n sovellus jonka avulla on mahdollista hallinnoida ihmisten puhelinnumeroita ja osoitteita.</p>

<p>TehtÃ¤vÃ¤n voi suorittaa 1-5 pisteen laajuisena. Yhden pisteen laajuuteen on toteutettava seuraavat toiminnot:</p>

<ul>
  <li>1 puhelinnumeron lisÃ¤ys henkilÃ¶lle</li>
  <li>2 henkilÃ¶n puhelinnumeroiden haku</li>
</ul>

<p>kahteen pisteeseen vaadittaan edellisten lisÃ¤ksi</p>

<ul>
  <li>3 numeroa vastaavan henkilÃ¶n nimen haku</li>
</ul>

<p>kolmeen pisteeseen vaadittaan edellisten lisÃ¤ksi</p>

<ul>
  <li>4 osoitteen lisÃ¤ys henkilÃ¶lle</li>
  <li>5 henkilÃ¶n tietojen (osoite ja puhelinnumero) haku</li>
</ul>

<p>neljÃ¤Ã¤n pisteeseen vaadittaan toiminto</p>

<ul>
  <li>6 henkilÃ¶n tietojen poisto</li>
</ul>

<p>ja tÃ¤ysiin pisteeseen vaaditaan vielÃ¤</p>

<ul>
  <li>7 hakusanalla filtterÃ¶ity listaus (nimen mukaan aakkostettuna), hakusana voi esiintyÃ¤ henkilÃ¶n nimessÃ¤ tai osoitteessa</li>
</ul>

<p>Esimerkki ohjelman toiminnasta:</p>

<pre>
numerotiedustelu
kÃ¤ytettÃ¤vissÃ¤ olevat komennot:
 1 lisÃ¤Ã¤ numero
 2 hae numerot
 3 hae puhelinnumeroa vastaava henkilÃ¶
 4 lisÃ¤Ã¤ osoite
 5 hae henkilÃ¶n tiedot
 6 poista henkilÃ¶n tiedot
 7 filtterÃ¶ity listaus
 x lopeta

command: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">040-123456</font>

command: <font color="red">2</font>
kenen: <font color="red">jukka</font>
  ei lÃ¶ytynyt

command: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 <font color="red">040-123456</font>

command: <font color="red">1</font>
kenelle: <font color="red">pekka</font>
numero: <font color="red">09-222333</font>

command: <font color="red">2</font>
kenen: <font color="red">pekka</font>
 040-123456
 09-222333

command: <font color="red">3</font>
numero: <font color="red">02-444123</font>
 ei lÃ¶ytynyt

command: <font color="red">3</font>
numero: <font color="red">09-222333</font>
 pekka

command: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite ei tiedossa
  puhelinnumerot:
   040-123456
   09-222333

command: <font color="red">4</font>
kenelle: <font color="red">pekka</font>
katu: <font color="red">ida ekmanintie</font>
kaupunki: <font color="red">helsinki</font>

command: <font color="red">5</font>
kenen: <font color="red">pekka</font>
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

command: <font color="red">4</font>
kenelle: <font color="red">jukka</font>
katu: <font color="red">korsontie</font>
kaupunki: <font color="red">vantaa</font>

command: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  osoite: korsontie vantaa
  ei puhelinta

command: <font color="red">7</font>
hakusana (jos tyhjÃ¤, listataan kaikki): <font color="red">kk</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

 pekka
  osoite: ida ekmanintie helsinki
  puhelinnumerot:
   040-123456
   09-222333

command: <font color="red">7</font>
hakusana (jos tyhjÃ¤, listataan kaikki): <font color="red">vantaa</font>

 jukka
  osoite: korsontie vantaa
  ei puhelinta

command: <font color="red">7</font>
hakusana (jos tyhjÃ¤, listataan kaikki): <font color="red">seppo</font>
 ei lÃ¶ytynyt

command: <font color="red">6</font>
kenet: <font color="red">jukka</font>

command: <font color="red">5</font>
kenen: <font color="red">jukka</font>
  ei lÃ¶ytynyt

command: <font color="red">x</font>
</pre>

<p>Huomioita:</p>
<ul>
  <li> Testien kannalta on oleellista ettÃ¤ <em>kÃ¤yttÃ¶liittymÃ¤</em> toimii kuten yllÃ¤ olevassa esimerkissÃ¤. Sovellus voi itse pÃ¤Ã¤ttÃ¤Ã¤ kuinka epÃ¤kelvot syÃ¶tteet kÃ¤sitellÃ¤Ã¤n. Testit sisÃ¤ltÃ¤vÃ¤t vaan kelvollisia syÃ¶tteitÃ¤.</li>
  <li><em><strong>Ohjelman tulee kÃ¤ynnistyÃ¤ kun tehtÃ¤vÃ¤pohjassa oleva main-metodi suoritetaan, tehtÃ¤vÃ¤ssÃ¤ saa luoda vain yhden Scanner-olion.</strong></em></li>
<li> ÃlÃ¤ kÃ¤ytÃ¤ staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillÃ¤ suorituskerroilla jÃ¤Ã¤neet arvot todennÃ¤kÃ¶isesti hÃ¤iritsevÃ¤t testien toimintaa!</li>
<li>ÃlÃ¤ kÃ¤ytÃ¤ luokkein nimissÃ¤ skandeja, ne saattavat aiheuttaa ongelmia testeihin!</li>
  <li>Yksinkertaisuuden vuoksi oletetaan ettÃ¤ nimi on yksittÃ¤inen characterString, eli jos halutaan sukunimen mukaan aakkostetun tulostus viimeiseen toimintoon , nimi on annettava muodossa <em>mikkola pekka</em>.</li>
  <li>HenkilÃ¶llÃ¤ voi olla useita puhelinnumeroja sekÃ¤ osoite. HenkilÃ¶llÃ¤ ei kuitenkaan ole vÃ¤lttÃ¤mÃ¤ttÃ¤ yhtÃ¤Ã¤n puhelinnumeroa tai osoite ei ole tiedossa.</li>
  <li>Jos henkilÃ¶ poistetaan, ei mikÃ¤Ã¤n haku saa enÃ¤Ã¤ palauttaa henkilÃ¶n tietoja.</li>
</ul>
</div>

<div class="tyhja"></div>



<div class="viikkoraja">Viikko 4</div>

<div class="tehtavat">


<NEXTWEEK></NEXTWEEK>
<h3>Rengastustoimisto</h3>

<p>Ohjelmoinnin perusteiden kuudennella viikolla teimme lintubongaria varten havaintotietokannan. Jatkamme hieman samasta teemasta, tÃ¤llÃ¤ kertaa teemme rengastustoimistolle ohjelman, jonka avulla pidetÃ¤Ã¤n kirjaa tiettynÃ¤ vuotena rengastettujen lintujen havaintopaikoista.</p>

<big>
<p><strong>HUOM:</strong> saatat tÃ¶rmÃ¤tÃ¤ tehtÃ¤vÃ¤ssÃ¤ kummalliseen virheilmoitukseen <code>NoSuchMethodError: Lintu.equals(LLintu;)Z</code>, jos nÃ¤in kÃ¤y suorita <strong>clean and build</strong> eli paina harja ja vasara -kuvakkeesta.</p>
</big>

<h4>Linnun equals ja toString</h4>

<p>Rengastustoimisto tallettaa tiettynÃ¤ vuotena rengastettettujen lintujen tiedot <code>Lintu</code>-olioihin:</p>

<pre class="sh_java">
public class Lintu {

    private String name;
    private String latinankielinenNimi;
    private int rengastusvuosi;

    public Lintu(String name, String latinankielinenNimi, int rengastusvuosi) {
        this.name = nimi;
        this.latinankielinenNimi = latinankielinenNimi;
        this.rengastusvuosi = rengastusvuosi;
    }

    @Override
    public String toString() {
        return this.latinankielinenNimi + "(" + this.rengastusvuosi + ")";
    }
}

</pre>

<p>Ideana on toteuttaa rengastustoimistoon toiminnallisuus jonka avulla voidaan pitÃ¤Ã¤ kirjaa tiettynÃ¤ vuotena rengastettujen lintujen havaintojen lukumÃ¤Ã¤ristÃ¤ ja havaintopaikoista. HavaintomÃ¤Ã¤riÃ¤ ja -paikkoja ei kuitenkaan talleteta Lintu-olioihin, vaan erilliseen HashMap:iin jonka avaimena kÃ¤ytetÃ¤Ã¤n Lintu-olioita. Kuten muistamme viikolta 2, on tÃ¤llÃ¤isessÃ¤ tapauksessa toteutettava luokalle <code>Lintu</code> metodit <code>equals(Object t)</code> ja <code>hashCode()</code>.</p>

<p>Joillain linnuilla on useita suomenkielisÃ¤ nimiÃ¤ (esim. punakottaraisesta kÃ¤ytetÃ¤Ã¤n edelleen joskus sen vanhaa nimitystÃ¤ rusokottarainen), latinankielinen nimi on kuitenkin aina yksikÃ¤sitteinen. Tee luokalle <code>Lintu</code> <code>equals-</code> ja <code>hashCode-</code>metodit jotka toimivat siten, ettÃ¤ lintu-oliot tulkitaan samoiksi jos niiden latinankielinen nimi ja rengastusvuosi ovat samat.</p>

<p>Esimerkki:</code>

<pre>
    Lintu lintu1 = new Lintu("punakottarainen", "Sturnus roseus", 2012);
    Lintu lintu2 = new Lintu("rusokottarainen", "Sturnus roseus", 2012);
    Lintu lintu3 = new Lintu("varis", "Corvus corone cornix", 2012);
    Lintu lintu4 = new Lintu("punakottarainen", "Sturnus roseus", 2000);

    System.out.println( lintu1.equals(lintu2));   // ovat sama koska sama latinankielinen nimi ja rengastusvuosi
    System.out.println( lintu1.equals(lintu3));   // eivÃ¤t ole sama koska eri rengastusvuosi
    System.out.println( lintu1.equals(lintu4));   // eivÃ¤t ole sama koska latinankielinen nimi eri
    System.out.println( lintu1.hashCode()==lintu2.hashCode() );
</pre>

<p>tulostuu:</p>

<pre>
true
false
false
true
</pre>

<h4>Rengastustoimisto</h4>

<p>Rengastustoimistolla on kaksi metodia: <code>public void havaitse(Lintu lintu, String paikka)</code> lisÃ¤Ã¤ linnulle havainnon ja havaintopaikan ja metodi <code>public void havainnot(Lintu lintu)</code> tulostaa alla olevan esimerkin mukaisesti parametrina olevan linnun havaintojen mÃ¤Ã¤rÃ¤n ja havaintopaikat. Havaintopaikkojen tulostusjÃ¤rjestyksellÃ¤ ei ole testien lÃ¤pimenon kannalta merkitystÃ¤.</p>

<p>Rengastustoimisto tallettaa havaintopaikat <code>Map&lt;Lintu, List&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan. Havaintojen lukumÃ¤Ã¤rÃ¤ selviÃ¤Ã¤ havaintopaikkojen listan pituudesta. Tarvittaessa voit ottaa tehtÃ¤vÃ¤Ã¤n mallia luvusta 16.</p>

<p>Esimerkki rengastustoimiston kÃ¤ytÃ¶stÃ¤:</p>

<pre class="sh_java">
    Rengastustoimisto kumpulanRengas = new Rengastustoimisto();
  
    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2012), "Arabia" );
    kumpulanRengas.havaitse( new Lintu("rusokottarainen", "Sturnus roseus", 2012), "Vallila" );
    kumpulanRengas.havaitse( new Lintu("harmaalokki", "Larus argentatus", 2008), "KumpulanmÃ¤ki" );
    kumpulanRengas.havaitse( new Lintu("punakottarainen", "Sturnus roseus", 2008), "Mannerheimintie" );

    kumpulanRengas.havainnot( new Lintu("rusokottarainen", "Sturnus roseus", 2012 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 2008 ) );
    System.out.println("--");
    kumpulanRengas.havainnot( new Lintu("harmaalokki", "Larus argentatus", 1980 ) );
</pre>

<p>tulostuu:</p>

<pre>
Sturnus roseus (2012) havaintoja: 2
Arabia
Vallila
--
Larus argentatus (2008) havaintoja: 1
KumpulanmÃ¤ki
--
Larus argentatus (1980) havaintoja: 0
</pre>

</div>


<h2>Olioiden monimuotoisuus</h2>

    <p>Olemme aiemmissa kappaleissa tÃ¶rmÃ¤nneet tilanteisiin, joissa muuttujilla on oman tyyppinsÃ¤ lisÃ¤ksi muita tyyppejÃ¤. Esimerkiksi kappaleessa <a href="#45">45</a> huomasimme ettÃ¤ <em>kaikki</em> oliot ovat tyyppiÃ¤ <code>Object</code>. Jos olio on jotain tiettyÃ¤ tyyppiÃ¤, voidaan se myÃ¶s esittÃ¤Ã¤ <code>Object</code>-tyyppisenÃ¤ muuttujana. Esimerkiksi <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" target="_blank">String</a></code> on myÃ¶s tyyppiÃ¤ <code>Object</code>, joten kaikki <code>String</code>-tyyppiset muuttujat voidaan esitellÃ¤ <code>Object</code> tyypin avulla.</p>

<pre class="sh_java">
    String characterString = "characterString";
    Object characterStringString = "toinen characterString";
</pre>

    <p>characterString-olion asettaminen <code>Object</code>-tyyppiseen viitteeseen onnistuu.</p>

<pre class="sh_java">
    String characterString = "characterString";
    Object characterStringString = characterString;
</pre>

    <p>Toiseen suuntaan asettaminen ei onnistu. Koska <code>Object</code>-tyyppiset muuttujat eivÃ¤t ole tyyppiÃ¤ <code>String</code>, ei object-tyyppistÃ¤ muuttujaa voi asettaa <code>String</code>-tyyppiseen muuttujaan.</p>

<pre class="sh_java">
    Object characterStringString = "toinen characterString";
    String characterString = characterStringString; // EI ONNISTU!
</pre>

    <p>MistÃ¤ tÃ¤ssÃ¤ oikein on kyse?</p>

    <p>Muuttujilla on oman tyyppinsÃ¤ lisÃ¤ksi aina perimiensÃ¤ luokkien ja toteuttamiensa rajapintojen tyypit. Luokka <code>String</code> perii <code>Object</code>-luokan, joten <code>String</code>-oliot ovat aina myÃ¶s tyyppiÃ¤ <code>Object</code>. Luokka <code>Object</code> ei peri <code>String</code>-luokkaa, joten <code>Object</code>-tyyppiset muuttujat eivÃ¤t ole automaattisesti tyyppiÃ¤ <code>String</code>. Tutustutaan tarkemmin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html">String</a></code>-luokan API-dokumentaatioon, erityisesti HTML-sivun ylÃ¤osaan.</p>

    <p><img src="img-ohja/perinta/string-api.png"/></p>

    <p>String-luokan API-dokumentaatio alkaa yleisellÃ¤ otsakkeella jota seuraa luokan pakkaus (<code>java.lang</code>). Pakkauksen jÃ¤lkeen tulee luokan nimi (<code>Class String</code>), jota seuraa luokan <em>perintÃ¤hierarkia</em>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html">java.lang.Object</a>
  <img src="img-ohja/perinta/perinta.gif"/><strong>java.lang.String</strong>
</pre>

    <p>PerintÃ¤hierarkia listaa luokat, jotka luokka on perinyt. Perityt luokat listataan perimisjÃ¤rjestyksessÃ¤, tarkasteltava luokka aina alimpana. String-luokan perintÃ¤hierarkiasta nÃ¤emme, ettÃ¤ <code>String</code>-luokka perii luokan <code>Object</code>. <em>Javassa jokainen luokka voi periÃ¤ korkeintaan yhden luokan</em>, mutta vÃ¤lillisesti niitÃ¤ voi periÃ¤ useampia.</p>
    <p>PerintÃ¤hierarkiaa voi ajatella myÃ¶s listana tyypeistÃ¤, joita olio toteuttaa.</p>

    <p>Se, ettÃ¤ kaikki oliot ovat tyyppiÃ¤ <code>Object</code> helpottaa ohjelmointia. Jos tarvitsemme metodissa vain <code>Object</code>-luokassa mÃ¤Ã¤riteltyjÃ¤ toimintoja, voimme kÃ¤yttÃ¤Ã¤ metodin parametrina tyyppiÃ¤ <code>Object</code>. Koska kaikki oliot ovat myÃ¶s tyyppiÃ¤ object, voi metodille antaa <em>minkÃ¤ tahansa</em> olion parametrina. Luodaan metodi <code>tulostaMonesti</code>, joka saa parametrinaan <code>Object</code>-tyyppisen muuttujan ja tulostusten lukumÃ¤Ã¤rÃ¤n.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int times) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMonesti</code> voi antaa parametrina minkÃ¤ tahansa olion. Metodin <code>tulostaMonesti</code> sisÃ¤ssÃ¤ oliolla on kÃ¤ytÃ¶ssÃ¤Ã¤n vain <code>Object</code>-luokassa mÃ¤Ã¤ritellyt metodit koska olio <em>esitellÃ¤Ã¤n</em> metodissa <code>Object</code>-tyyppisenÃ¤.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String characterString = " o ";
    List&lt;String&gt; sanat = new ArrayList&lt;String&gt;();
    sanat.add("polymorfismi");
    sanat.add("perintÃ¤");
    sanat.add("kapselointi");
    sanat.add("abstrahointi");

    tulostin.tulostaMonesti(characterString, 2);
    tulostin.tulostaMonesti(sanat, 3);
</pre>

<pre>
 o
 o
[polymorfismi, perintÃ¤, kapselointi, abstrahointi]
[polymorfismi, perintÃ¤, kapselointi, abstrahointi]
[polymorfismi, perintÃ¤, kapselointi, abstrahointi]
</pre>


    <p>Jatketaan <code>String</code>-luokan API-kuvauksen tarkastelua. Kuvauksessa olevaa perintÃ¤hierarkiaa seuraa listaus luokan toteuttamista rajapinnoista.</p>

<pre>
<strong>All Implemented Interfaces:</strong>
  <A HREF="http://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html" title="interface in java.io">Serializable</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/CharSequence.html" title="interface in java.lang">CharSequence</A>, <A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html" title="interface in java.lang">Comparable</A>&lt;<A HREF="http://docs.oracle.com/javase/6/docs/api/java/lang/String.html" title="class in java.lang">String</A>&gt;
</pre>

    <p>Luokka <code>String</code> toteuttaa rajapinnat <code>Serializable</code>, <code>CharSequence</code>, ja <code>Comparable&lt;String&gt;</code>. MyÃ¶s rajapinta on tyyppi. Luokan String API-kuvauksen mukaan String-olion tyypiksi voi asettaa seuraavat rajapinnat.</p>

<pre class="sh_java">
    Serializable serializableString = "characterString";
    CharSequence charSequenceString = "characterString";
    Comparable&lt;String&gt; comparableString = "characterString";
</pre>

    <p>Koska metodeille voidaan mÃ¤Ã¤ritellÃ¤ metodin parametrin tyyppi, voimme mÃ¤Ã¤ritellÃ¤ metodeja jotka vastaanottavat <em>tietyn rajapinnan toteuttavan</em> olion. Kun metodille mÃ¤Ã¤ritellÃ¤Ã¤n parametrina rajapinta, sille voidaan antaa parametrina mikÃ¤ tahansa olio joka toteuttaa kyseisen rajapinnan, metodi ei vÃ¤litÃ¤ olion oikeasta tyypistÃ¤.</p>

    <p>TÃ¤ydennetÃ¤Ã¤n <code>Tulostin</code>-luokkaa siten, ettÃ¤ sillÃ¤ on metodi <code>CharSequence</code>-rajapinnan toteuttavien olioiden merkkien tulostamiseen. Rajapinta <code>CharSequence</code> tarjoaa muunmuassa metodit <code>int length()</code>, jolla saa characterStringn pituuden, ja <code>char charAt(int index)</code>, jolla saa merkin tietyssÃ¤ indeksissÃ¤.</p>

<pre class="sh_java">
public class Tulostin {
    ...
    public void tulostaMonesti(Object object, int times) {
        for (int i = 0; i &lt; kertaa; i++) {
            System.out.println(object.toString());
        }
    }

    public void tulostaMerkit(CharSequence charSequence) {
        for (int i = 0; i &lt; charSequence.length(); i++) {
            System.out.println(charSequence.charAt(i);
        }
    }
    ...
}
</pre>

    <p>Metodille <code>tulostaMerkit</code> voi antaa minkÃ¤ tahansa <code>CharSequence</code>-rajapinnan toteuttavan olion. NÃ¤itÃ¤ on muunmuassa <code>String</code> ja characterStringjen rakentamisessa usein StringiÃ¤ tehokkaampi <code>StringBuilder</code>. Metodi <code>tulostaMerkit</code> tulostaa annetun olion jokaisen merkin omalle rivilleen.</p>

<pre class="sh_java">
    Tulostin tulostin = new Tulostin();

    String mjono = "toimii";

    tulostin.tulostaMerkit(mjono);
</pre>

<pre>
t
o
i
m
i
i
</pre>

<div class="tehtavat">

<h3>Joukkoja</h3>

<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ teemme eliÃ¶ita ja eliÃ¶istÃ¤ koostuvia laumoja jotka liikkuvat ympÃ¤riinsÃ¤. EliÃ¶iden sijaintien ilmoittamiseen kÃ¤ytetÃ¤Ã¤n  <em>kaksiulotteista koordinaatistoa</em>. Jokaiseen sijaintiin liittyy kaksi lukua, <code>x</code>- ja <code>y</code>-koordinaatti. Koordinaatti <code>x</code> kertoo, kuinka pitkÃ¤llÃ¤ "nollapisteestÃ¤" mitattuna sijainti on vaakasuunnassa, ja koordinaatti <code>y</code> vastaavasti kuinka pitkÃ¤llÃ¤ sijainti on pystysuunnassa. Jos koordinaatiston kÃ¤site ei ole tuttu, voit lukea siitÃ¤ lisÃ¤Ã¤ esimerkiksi <a href="http://fi.wikipedia.org/wiki/Koordinaatisto">wikipediasta</a>.</p>

<p>TehtÃ¤vÃ¤n mukana tulee rajapinta <code>Siirrettava</code>, joka kuvaa asiaa jota voidaan siirtÃ¤Ã¤ paikasta toiseen. Rajapinta sisÃ¤ltÃ¤Ã¤ metodin <code>void siirra(int dx, int dy)</code>. Parametri <code>dx</code> kertoo, paljonko asia siirtyy x-akselilla ja <code>dy</code> y-akselilla.</p>

<p>TehtÃ¤vÃ¤ssÃ¤ toteutat luokat <code>Elio</code> ja <code>Lauma</code>, jotka molemmat ovat siirrettÃ¤viÃ¤. Toteuta kaikki toiminnallisuus pakkaukseen <code>siirrettava</code>.</p>

<h4>Elio-luokan toteuttaminen</h4>

<p>Luo pakkaukseen <code>siirrettava</code> luokka <code>Elio</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. EliÃ¶n tulee tietÃ¤Ã¤ oma sijaintinsa (x, y -koordinaatteina). Luokan <code>Elio</code> APIn tulee olla seuraava:</p>

  <ul>
    <li><strong>public Elio(int x, int y)</strong><br/>Luokan konstruktori, joka saa olion aloitussijainnin x- ja y-koordinaatit parametrina</li>
    <li><strong>public String toString()</strong><br/> Luo ja palauttaa oliosta characterStringesityksen. EliÃ¶n characterStringesityksen tulee olla seuraavanlainen <code>"x: 3; y: 6"</code>. Huomaa ettÃ¤ koordinaatit on erotettu puolipisteellÃ¤ (<code>;</code>)</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> SiirtÃ¤Ã¤ oliota parametrina saatujen arvojen verran. Muuttuja <code>dx</code> sisÃ¤ltÃ¤Ã¤ muutoksen koordinaattiin <code>x</code>, muuttuja <code>dy</code> sisÃ¤ltÃ¤Ã¤ muutoksen koordinaattiin <code>y</code>. Esimerkiksi jos muuttujan <code>dx</code> arvo on 5, tulee oliomuuttujan <code>x</code> arvoa kasvattaa viidellÃ¤</li>
  </ul>

<p>Kokeile luokan <code>Elio</code> toimintaa seuraavalla esimerkkikoodilla. </p>

<pre class="sh_java">
     Elio elio = new Elio(20, 30);
     System.out.println(elio);
     elio.siirra(-10, 5);
     System.out.println(elio);
     elio.siirra(50, 20);
     System.out.println(elio);
</pre>

<pre>
x: 20; y: 30
x: 10; y: 35
x: 60; y: 55
</pre>

<h4>Lauman toteutus</h4>

<p>Luo seuraavaksi pakkaukseen <code>siirrettava</code> luokka <code>Lauma</code>, joka toteuttaa rajapinnan <code>Siirrettava</code>. Lauma koostuu useasta <code>Siirrettava</code>-rajapinnan toteutavasta oliosta, jotka tulee tallettaa esimerkiksi listarakenteeseen.</p>

<p>Luokalla <code>Lauma</code> tulee olla seuraavanlainen API.</p>

  <ul>
    <li><strong>public String toString()</strong><br/> Palauttaa characterStringesityksen lauman jÃ¤senten sijainnista rivin vaihdolla erotettuna.</li>
    <li><strong>public void lisaaLaumaan(Siirrettava siirrettava)</strong><br/> LisÃ¤Ã¤ laumaan uuden <code>Siirrettava</code>-rajapinnan toteuttavan olion</li>
    <li><strong>public void siirra(int dx, int dy)</strong><br/> SiirtÃ¤Ã¤ laumaa parametrina saatujen arvojen verran. Huomaa ettÃ¤ tÃ¤ssÃ¤ sinun tulee siirtÃ¤Ã¤ jokaista lauman jÃ¤sentÃ¤.</li>
  </ul>

<p>Kokeile ohjelmasi toimintaa alla olevalla esimerkkikoodilla.</p>

<pre class="sh_java">
    Lauma lauma = new Lauma();
    lauma.lisaaLaumaan(new Elio(73, 56));
    lauma.lisaaLaumaan(new Elio(57, 66));
    lauma.lisaaLaumaan(new Elio(46, 52));
    lauma.lisaaLaumaan(new Elio(19, 107));
    System.out.println(lauma);
</pre>

<pre>
x: 73; y: 56
x: 57; y: 66
x: 46; y: 52
x: 19; y: 107
</pre>
</div>

<h2>Luokan ominaisuuksien periminen</h2>

    <p>Luokat ovat ohjelmoijan tapa ratkaistavan ongelma-alueen kÃ¤sitteiden selkeyttÃ¤miseen. LisÃ¤Ã¤mme jokaisella luomallamme luokalla uutta toiminnallisuutta ohjelmointikieleen. Toiminnallisuutta tarvitaan kohtaamiemme ongelmien ratkomiseen, ratkaisut syntyvÃ¤t luokista luotujen olioiden vÃ¤lisen interaktion avulla. Olio-ohjelmoinnissa olio on itsenÃ¤inen kokonaisuus, jolla on olion tarjoamien metodien avulla muutettava tila. Olioita kÃ¤ytetÃ¤Ã¤n yhteistyÃ¶ssÃ¤; jokaisella oliolla on oma vastuualue. Esimerkiksi kÃ¤yttÃ¶liittymÃ¤luokkamme ovat tÃ¤hÃ¤n mennessÃ¤ hyÃ¶dyntÃ¤neet <code>Scanner</code>-olioita.</p>

    <p>Jokainen Javan luokka perii luokan <code>Object</code>, eli jokainen luomamme luokka saa kÃ¤yttÃ¶Ã¶nsÃ¤ kaikki <code>Object</code>-luokassa mÃ¤Ã¤ritellyt metodit. Jos haluamme muuttaa <code>Object</code>-luokassa mÃ¤Ã¤riteltyjen metodien toiminnallisuutta tulee ne korvata (<code>Override</code>) mÃ¤Ã¤rittelemÃ¤llÃ¤ niille uusi toteutus luodussa luokassa.</p>

<p>Luokan <code>Object</code> perimisen lisÃ¤ksi myÃ¶s muiden luokkien periminen on mahdollista. Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/ArrayList.html" target="_blank">ArrayList</a></code>-luokan APIa tarkasteltaessa huomaamme ettÃ¤ <code>ArrayList</code> perii luokan <code>AbstractList</code>. Luokka <code>AbstractList</code> perii luokan <code>AbstractCollection</code>, joka perii luokan <code>Object</code>.</p>

<pre>
<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html" target="_blank">java.lang.Object</a>
  <img src="img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/util/AbstractCollection.html" target="_blank">java.util.AbstractCollection</a>&lt;E&gt;
      <img src="img-ohja/perinta/perinta.gif" /><a href="http://docs.oracle.com/javase/6/docs/api/java/AbstractList.html" target="_blank">java.util.AbstractList</a>&lt;E&gt;
          <img src="img-ohja/perinta/perinta.gif" /><strong>java.util.ArrayList&lt;E&gt;</strong>
</pre>

        <p>Kukin luokka voi periÃ¤ suoranaisesti yhden luokan. VÃ¤lillisesti luokka kuitenkin perii kaikki perimÃ¤nsÃ¤ luokan ominaisuudet. Luokka <code>ArrayList</code> perii suoranaisesti luokan <code>AbstractList</code>, ja vÃ¤lillisesti luokat <code>AbstractCollection</code> ja <code>Object</code>. Luokalla <code>ArrayList</code> on siis kÃ¤ytÃ¶ssÃ¤Ã¤n luokkien <code>AbstractList</code>, <code>AbstractCollection</code> ja <code>Object</code> muuttujat, metodit <em>ja</em> rajapinnat.</p>

        <p>Luokan ominaisuudet peritÃ¤Ã¤n avainsanalla <code>extends</code>. Luokan perivÃ¤Ã¤ luokkaa kutsutaan aliluokaksi (<em>subclass</em>), perittÃ¤vÃ¤Ã¤ luokkaa yliluokaksi (<em>superclass</em>). Tutustutaan erÃ¤Ã¤n autonvalmistajan jÃ¤rjestelmÃ¤Ã¤n, joka hallinnoi auton osia. Osien hallinan peruskomponentti on luokka <code>Osa</code>, joka mÃ¤Ã¤rittelee tunnuksen, valmistajan ja kuvauksen.</p>

<pre class="sh_java">
public class Osa {

    private String tunnus;
    private String valmistaja;
    private String kuvaus;

    public Osa(String tunnus, String valmistaja, String kuvaus) {
        this.tunnus = tunnus;
        this.valmistaja = valmistaja;
        this.kuvaus = kuvaus;
    }

    public String getTunnus() {
        return tunnus;
    }

    public String getKuvaus() {
        return kuvaus;
    }

    public String getValmistaja() {
        return valmistaja;
    }
}
</pre>

        <p>Yksi osa autoa on moottori. Kuten kaikilla osilla, myÃ¶s moottorilla on valmistaja, tunnus ja kuvaus. NÃ¤iden lisÃ¤ksi moottoriin liittyy moottorityyppi: esimerkiksi polttomoottori, sÃ¤hkÃ¶moottori tai hybridi. Luodaan luokan <code>Osa</code> perivÃ¤ luokka <code>Moottori</code>: moottori on osan erikoistapaus.</p>

<pre class="sh_java">
public class Moottori extends Osa {

    private String moottorityyppi;

    public Moottori(String moottorityyppi, String tunnus, String valmistaja, String kuvaus) {
        super(tunnus, valmistaja, kuvaus);
        this.moottorityyppi = moottorityyppi;
    }

    public String getMoottorityyppi() {
        return moottorityyppi;
    }
}
</pre>

        <p>LuokkamÃ¤Ã¤rittely <code>public class Moottori extends Osa</code> kertoo ettÃ¤ luokka <code>Moottori</code> perii luokan <code>Osa</code> toiminnallisuuden. Luokassa <code>Moottori</code> mÃ¤Ã¤ritellÃ¤Ã¤n oliomuuttuja <code>moottorityyppi</code>.</p>

        <p>Moottori-luokan konstruktori on mielenkiintoinen. Konstruktorin ensimmÃ¤isellÃ¤ rivillÃ¤ on avainsana <code>super</code>, jolla kutsutaan yliluokan konstruktoria. Kutsu <code>super(tunnus, valmistaja, kuaus)</code> kutsuu luokassa <code>Osa</code> mÃ¤Ã¤riteltyÃ¤ konstruktoria <code>public Osa(String tunnus, String valmistaja, String kuvaus</code>, jolloin yliluokassa mÃ¤Ã¤ritellyt oliomuuttujat saavat arvonsa. TÃ¤mÃ¤n jÃ¤lkeen oliomuuttujalle <code>moottorityyppi</code> asetetaan siihen liittyvÃ¤ arvo.</p>

        <p>Kun luokka <code>Moottori</code> perii luokan <code>Osa</code>, saa se kÃ¤yttÃ¶Ã¶nsÃ¤ kaikki luokan <code>Osa</code> tarjoamat metodit. Luokasta <code>Moottori</code> voi tehdÃ¤ ilmentymÃ¤n aivan kuten mistÃ¤ tahansa muustakin luokata.</p>

<pre class="sh_java">
        Moottori moottori = new Moottori("polttomoottori", "hz", "volkswagen", "VW GOLF 1L 86-91");
        System.out.println(moottori.getMoottorityyppi());
        System.out.println(moottori.getValmistaja());
</pre>

<pre>
polttomoottori
volkswagen
</pre>

        <p>Kuten huomaat, luokalla <code>Moottori</code> on kÃ¤ytÃ¶ssÃ¤ luokassa <code>Osa</code> mÃ¤Ã¤ritellyt metodit.</p> 

        <h3>Private, protected ja public</h3>

<p>Jos metodilla tai muuttujalla on nÃ¤kyvyysmÃ¤Ã¤re <code>private</code>, ei se nÃ¤y aliluokille eikÃ¤ aliluokalla ole mitÃ¤Ã¤n suoraa tapaa pÃ¤Ã¤stÃ¤ kÃ¤siksi yliluokan siihen. EdellisessÃ¤ esimerkissÃ¤ Moottori ei siis pÃ¤Ã¤se suoraan kÃ¤siksi yliluokassa Osa mÃ¤Ã¤riteltyihin ominaisuuksiinsa (tunnus, valmistaja, kuvaus). Aliluokka nÃ¤kee luonnollisesti kaiken yliluokan julkisen eli <code>public</code>-mÃ¤Ã¤reellÃ¤ varustetun kaluston. Jos halutaan mÃ¤Ã¤ritellÃ¤ yliluokkaan joitain muuttujia tai metodeja joiden nÃ¤keminen halutaan sallia aliluokille, mutta estÃ¤Ã¤ muilta voidaan kÃ¤yttÃ¤Ã¤ nÃ¤kyvyysmÃ¤Ã¤rettÃ¤ <code>protected</code>.</p>

        <h3>Yliluokka super</h3>

        <p>Yliluokan konstruktoria kutsutaan avainsanalla <code>super</code>. Kutsu <code>super</code> on kÃ¤ytÃ¤nnÃ¶ssÃ¤ samanlainen kuin <code>this</code>-konstruktorikutsu. Kutsulle annetaan parametrina yliluokan konstruktorin vaatiman tyyppiset arvot.</p>

        <p>Konstruktoria kutsuttaessa yliluokassa mÃ¤Ã¤ritellyt muuttujat alustetaan. Konstruktorikutsussa tapahtuu kÃ¤ytÃ¤nnÃ¶ssÃ¤ tÃ¤ysin samat asiat kuin normaalissa konstruktorikutsussa. Jos yliluokassa ei ole mÃ¤Ã¤ritelty parametritonta konstruktoria, tulee aliluokan konstruktorikutsuissa olla aina mukana yliluokan konstruktorikutsu.</p>

        <p>Huom! Kutsun <code>super</code> tulee olla aina konstruktorin ensimmÃ¤isellÃ¤ rivillÃ¤!</p>

<h3>Yliluokan metodin kutsuminen</h3>

        <p>Yliluokassa mÃ¤Ã¤riteltyjÃ¤ metodeja voi kutsua <code>super</code>-etuliitteen avulla, aivan kuten tÃ¤ssÃ¤ luokassa mÃ¤Ã¤riteltyjÃ¤ metodeja voi kutsua <code>this</code>-etuliitteellÃ¤. Esimerkiksi yliluokassa mÃ¤Ã¤riteltyÃ¤ <code>toString</code>-metodia voi hyÃ¶dyntÃ¤Ã¤ sen korvaavassa metodissa seuraavasti:</p>

<pre class="sh_java">
    @Override
    public String toString() {
        return super.toString() + "\n  Ja oma viestini vielÃ¤!";
    }
</pre>

<div class="tehtavat">
  <h3>HenkilÃ¶ ja sen perilliset</h3>

  <h4 class="req">Person</h4>

  <p>Tee pakkaus <code>henkilot</code> ja sinne luokka <code>Person</code>, joka toimii seuraavan pÃ¤Ã¤ohjelman yhteydessÃ¤</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Person pekka = new Person("Pekka Mikkola", "Korsontie 1 03100 Vantaa");
        Person esko = new Person("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki");
        System.out.println(pekka);
        System.out.println(esko);
    }
</pre>

  <p>siten ettÃ¤ tulostuu</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
</pre>

<h4 class="req">Opiskelija</h4>

  <p>Tee pakkaukseen luokka <code>Opiskelija</code> joka <i>perii</i> luokan <code>Person</code>.

  <p>Opiskelijalla on aluksi 0 opintopistettÃ¤. Aina kun opiskelija opiskelee, kasvaa opintopistemÃ¤Ã¤rÃ¤. Toteuta luokka siten, ettÃ¤ seuraava pÃ¤Ã¤ohjelma:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println(olli );
        System.out.println("opintopisteitÃ¤ " + olli.opintopisteita());
        olli.opiskele();
        System.out.println("opintopisteitÃ¤ "+ olli.opintopisteita());
    }
</pre>

  <p>tuottaa tulostuksen:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
opintopisteitÃ¤ 0
opintopisteitÃ¤ 1
</pre>

<h4 class="req">Opiskelijalle toString</h4>

  <p>EdellisessÃ¤ tehtÃ¤vÃ¤ssÃ¤ <code>Opiskelija</code> perii toString-metodin luokalta <code>Person</code>. Perityn metodin voi myÃ¶s ylikirjoittaa, eli korvata omalla versiolla. Tee nyt <code>Opiskelija</code>:lle oma versio toString:istÃ¤ joka toimii seuraavan esimerkin mukaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        System.out.println( olli );
        olli.opiskele();
        System.out.println( olli );
    }
</pre>

  <p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitÃ¤ 0
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitÃ¤ 1
</pre>

  <h4 class="req">Opettaja</h4>

  <p>Tee pakkaukseen luokka <code>Person</code>:n perivÃ¤ luokka <code>Opettaja</code>. Opettajalla on palkka joka tulostuu opettajan characterStringesityksessÃ¤. </p>

  <p>Testaa, ettÃ¤ seuraava pÃ¤Ã¤ohjelma</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Opettaja pekka = new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200);
        Opettaja esko = new Opettaja("Esko Ukkonen", "Mannerheimintie 15 00100 Helsinki", 5400);
        System.out.println( pekka );
        System.out.println( esko );

        Opiskelija olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
        for ( int i=0; i &lt; 25; i++ ) {
            olli.opiskele();
        }
        System.out.println( olli );
    }
</pre>

  <p>Aikaansaa tulostuksen</p>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Esko Ukkonen
  Mannerheimintie 15 00100 Helsinki
  palkka 5400 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitÃ¤ 25
</pre>

<h4 class="req">Kaikki Persont listalle</h4>

  <p>Toteuta oletuspakkauksessa olevaan <code>Main</code>-luokkaan luokkametodi <code>public static void tulostaLaitoksenPersont(List&lt;Person&gt; henkilot)</code>, joka tulostaa kaikki metodille parametrina annetussa listassa olevat henkilÃ¶t. Metodin tulee toimia seuraavasti <code>main</code>-metodista kutsuttaessa.</p>

<pre class="sh_java">
    public static void tulostaLaitoksenPersont(List&lt;Person&gt; henkilot) {
       // tulostetaan kaikki listan henkilÃ¶t
    }

    public static void main(String[] args) {
        List&lt;Person&gt; henkilot = new ArrayList&lt;Person&gt;();
        henkilot.add( new Opettaja("Pekka Mikkola", "Korsontie 1 03100 Vantaa", 1200) );
        henkilot.add( new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki") );

        tulostaLaitoksenPersont(henkilot);
    }
</pre>

<pre>
Pekka Mikkola
  Korsontie 1 03100 Vantaa
  palkka 1200 euroa/kk
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitÃ¤ 0
</pre>

</div>

   <h3>Olion tyyppi mÃ¤Ã¤rÃ¤Ã¤ kutsutun metodin: Polymorfismi</h3>

    <p>Olion kutsuttavissa olevat metodit mÃ¤Ã¤rittyvÃ¤t muuttujan tyypin kautta. Esimerkiksi jos <code>Opiskelija</code>-tyyppisen olion viite on talletettu  <code>Person</code>-tyyppiseen muuttujaan, on oliosta kÃ¤ytÃ¶ssÃ¤ vain <code>Person</code>-luokassa mÃ¤Ã¤ritellyt metodit:</p> 

<pre class="sh_java">
   Person olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   olli.opintopisteita();        // EI TOIMI!
   olli.opiskele();              // EI TOIMI!
   String.out.println( olli );   // olli.toString() TOIMII
</pre>

<p>Jos oliolla on monta eri tyyppiÃ¤, on sillÃ¤ kÃ¤ytÃ¶ssÃ¤ <em>jokaisen</em> tyypin mÃ¤Ã¤rittelemÃ¤t metodit. Esimerkiksi <code>Opiskelija</code>-tyyppisellÃ¤ oliolla on kÃ¤ytÃ¶ssÃ¤ <code>Person</code>-luokassa mÃ¤Ã¤ritellyt metodit sekÃ¤ <code>Object</code>-luokassa mÃ¤Ã¤ritellyt metodit.</p> 

<p>EdellisessÃ¤ tehtÃ¤vÃ¤ssÃ¤ korvasimme Opiskelijan luokalta HenkilÃ¶ perimÃ¤n <code>toString</code> uudella versiolla. MyÃ¶s luokka HenkilÃ¶ oli jo korvannut Object-luokalta perimÃ¤nsÃ¤ toStringin. Jos kÃ¤sittelemme olioa jonkin muun kuin sen todellisen tyypin omaavan muuttujan kautta, mitÃ¤ versiota olion metodista kutsutaa? Esim. seuraavassa on kaksi opiskelijaa joiden viitteet on talletettu Person- ja Object-tyyppisiin muuttujiin. Molemmille kutsutaan metodia <code>toString</code>. MikÃ¤ versio metodista suoritetaan, luokassa Object, Person vai Opiskelija mÃ¤Ã¤ritelty?</p>

<pre class="sh_java">
   Person olli = new Opiskelija("Olli", "Ida Albergintie 1 00400 Helsinki");
   String.out.println( olli );   

   Object liisa = new Opiskelija("Liisa", "VÃ¤inÃ¶ Auerin katu 20 00500 Helsinki");
   String.out.println( liisa );
</pre>

<p>Tulostuu:</p>

<pre>
Olli
  Ida Albergintie 1 00400 Helsinki
  opintopisteitÃ¤ 0
Liisa
  VÃ¤inÃ¶ Auerin katu 20 00500 Helsinki
  opintopisteitÃ¤ 0
</pre>

<p>Eli suoritettava metodi valitaan olion todellisen tyypin perusteella, ei viitteen tallettavan muuttujan tyypin perusteella!</p>

    <p>Hieman yleisemmin: <b>Suoritettava metodi valitaan aina olion todellisen tyypin perusteella riippumatta kÃ¤ytetyn muuttujan tyypistÃ¤. Oliot ovat monimuotoisia, eli olioita voi kÃ¤yttÃ¤Ã¤ usean eri muuttujatyypin kautta. Suoritettava metodi liittyy aina olion todelliseen tyyppiin.</b> TÃ¤tÃ¤ monimuotoisuutta kutsutaan polymorfismiksi.</p>

<h3>Toinen esimerkki: pisteitÃ¤</h3>

<p>Kaksiulotteisessa koordinaatiostossa sijaitsevaa pistettÃ¤ voisi kuvata seuraavan luokan avulla:</p>

<pre class="sh_java">
public class Piste {

    private int x;
    private int y;

    public Piste(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int manhattanEtaisyysOrigosta(){
        return Math.abs(x)+Math.abs(y);
    }
    
    protected String sijainti(){
        return x+", "+y;
    }

    @Override
    public String toString() {
        return "("+this.sijainti()+") etÃ¤isyys "+this.manhattanEtaisyysOrigosta();
    }    
}
</pre>

<p>Metodi <code>sijainti</code> ei ole tarkoitettu ulkoiseen kÃ¤yttÃ¶Ã¶n, joten se on nÃ¤kyvyysmÃ¤Ã¤reeltÃ¤Ã¤n protected, eli aliluokat pÃ¤Ã¤sevÃ¤t siihen kÃ¤siksi. Esim. <a href="http://wiki.gamegardens.com/Path_Finding_Tutorial">reitinhakualgoritmien</a> hyÃ¶dyntÃ¤mÃ¤ssÃ¤ <a href="http://en.wiktionary.org/wiki/Manhattan_distance">Manhattan-etÃ¤isyydellÃ¤</a> tarkoitetaan pisteiden etÃ¤isyyttÃ¤, jos niiden vÃ¤lin voi kulkea ainoastaan koordinaattiakselien suuntaisesti. </p> 

<p>VÃ¤rillinen piste on muuten samanlainen kuin piste, mutta se sisÃ¤ltÃ¤Ã¤ characterStringna ilmaistavan vÃ¤rin. Luokka voidaan siis tehdÃ¤ perimÃ¤llÃ¤ Piste:</p>

<pre class="sh_java">
public class VariPiste extends Piste {

    private String vari;

    public VariPiste(int x, int y, String vari) {
        super(x, y);
        this.vari = vari;
    }

    @Override
    public String toString() {
        return super.toString()+" vÃ¤ri: "+vari; 
    }
}
</pre>

<p>Luokka mÃ¤Ã¤rittelee oliomuuttujan vÃ¤rin talletusta varten. Koordinaatit talletetaan yliluokkaan. characterStringesityksestÃ¤ halutaan muuten samanlainen kuin pisteellÃ¤, mutta vÃ¤ri tulee myÃ¶s ilmaista. Ylikirjoitettu metodi <code>toString</code> kutsuukin yliluokan toStringiÃ¤ ja lisÃ¤Ã¤ sen tulokseen pisteen vÃ¤rin.</p>

<p>Seuraavassa esimerkki, jossa listalle laitetaan muutama piste, osa normaaleja ja osa vÃ¤ripisteitÃ¤ ja tulostetaan listalla olevat pisteet. Polymorfismin ansioista kaikille tulee kutsutuksi olion todellisen tyypin toString-metodi vaikka lista tuntee kaikki pisteet <code>Piste</code>-tyyppisinÃ¤:</p>

<pre class="sh_java">
public class Main {
    public static void main(String[] args) {
        List<Piste> pisteet = new ArrayList<Piste>(); 
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreÃ¤"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste(0, 0));
        
        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostuu:</p>

<pre>
(4, 8) etÃ¤isyys 12
(1, 1) etÃ¤isyys 2 vÃ¤ri: vihreÃ¤
(2, 5) etÃ¤isyys 7 vÃ¤ri: sininen
(0, 0) etÃ¤isyys 0
</pre>

<p>Haluamme ohjelmaamme myÃ¶s kolmeulotteisen pisteen. Koska kyseessÃ¤ ei ole vÃ¤rillinen versio, periytetÃ¤Ã¤n se pisteestÃ¤:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;    // tulos characterString muotoa "x, y, z"
    }    

    @Override
    public int manhattanEtaisyysOrigosta() {
        // kysytÃ¤Ã¤n ensin yliluokalta x:n ja y:n perusteella laskettua etÃ¤isyyttÃ¤ 
        // ja lisÃ¤tÃ¤Ã¤n tulokseen z-koordinaatin vaikutus
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);   
    }    
    
    @Override
    public String toString() {
        return "("+this.sijainti()+") etÃ¤isyys "+this.manhattanEtaisyysOrigosta();
    }    
}
</pre>

<p>Kolmiulotteinen piste siis mÃ¤Ã¤rittelee kolmatta koordinaattia vastaavan oliomuuttujan ja ylikirjoittaa metodit <code>sijainti</code>,
  <code>manhattanEtaisyysOrigosta</code> ja <code>toString</code> siten, ettÃ¤ ne huomioivat kolmannen ulottuvuuden. Voimme nyt laajentaa edellistÃ¤ esimerkkiÃ¤ ja lisÃ¤tÃ¤ listalle myÃ¶s kolmiulotteisia pisteitÃ¤:</p>

<pre class="sh_java">
public class Main {

    public static void main(String[] args) {
        List<Piste> pisteet = new ArrayList<Piste>(); 
        pisteet.add(new Piste(4, 8));
        pisteet.add(new VariPiste(1, 1, "vihreÃ¤"));
        pisteet.add(new VariPiste(2, 5, "sininen"));
        pisteet.add(new Piste3D(5, 2, 8));
        pisteet.add(new Piste(0, 0));
        
        for (Piste piste : pisteet) {
            System.out.println(piste);
        }
    }
}
</pre>

<p>Tulostus on odotusten mukainen</p>

<pre>
(4, 8) etÃ¤isyys 12
(1, 1) etÃ¤isyys 2 vÃ¤ri: vihreÃ¤
(2, 5) etÃ¤isyys 7 vÃ¤ri: sininen
(5, 2, 8) etÃ¤isyys 15
(0, 0) etÃ¤isyys 0
</pre>

<p>Huomamme, ettÃ¤ kolmiulotteisen pisteen metodi <code>toString</code> on tÃ¤smÃ¤lleen sama kuin pisteen toString. Voisimmeko jÃ¤ttÃ¤Ã¤ toStringin ylikirjoittamatta? Vastaus on kyllÃ¤! Kolmiulotteinen piste pelkistyy seuraavanlaiseksi:</p>

<pre class="sh_java">
public class Piste3D extends Piste {

    private int z;

    public Piste3D(int x, int y, int z) {
        super(x, y);
        this.z = z;
    }

    @Override
    protected String sijainti() {
        return super.sijainti()+", "+z;
    }    

    @Override
    public int manhattanEtaisyysOrigosta() {
        return super.manhattanEtaisyysOrigosta()+Math.abs(z);
    }      
}
</pre>

<p>MitÃ¤ tarkalleenottaen tapahtuu kuin kolmiulotteiselle pisteelle kutsutaan toString-metodia? Suoritus etenee seuraavasti:</p>
<ol>
<li>etsitÃ¤Ã¤n toString:in mÃ¤Ã¤rittelyÃ¤ luokasta Piste3D, sitÃ¤ ei lÃ¶ydy joten mennÃ¤Ã¤n yliluokkaan</li>
<li>etsitÃ¤Ã¤n toString:in mÃ¤Ã¤rittelyÃ¤ yliluokasta Piste, metodi lÃ¶ytyy, joten suoritetaan sen koodi</li>
<ul>
<li>suoritettava koodi siis on <code>return "("+this.sijainti()+") etÃ¤isyys "+this.manhattanEtaisyysOrigosta();</code></li>
<li>esimmÃ¤isenÃ¤ suoritetaan metodi sijainti</li>
<li>etsitÃ¤Ã¤n metodin sijainti mÃ¤Ã¤rittelyÃ¤ luokasta Piste3D, metodi lÃ¶ytyy ja suoritetaan sen koodi</li>
<li>metodin sijainti laskee oman tuloksensa kutsumalla yliluokassa olevaa metodia sijainti</li>
<li>seuraavaksi etsitÃ¤Ã¤n metodin manhattanEtaisyysOrigosta mÃ¤Ã¤rittelyÃ¤ luokasta Piste3D, metodi lÃ¶ytyy ja suoritetaan sen koodi</li>
<li>jÃ¤lleen metodi laskee tuloksensa kutsuen ensin yliluokassa olevaa samannimistÃ¤ metodia</li>
</ul>
</ol>

<p>Metodikutsun aikaansaama toimintoketju siis on varsin monivaiheinen. Periaate on kuitenkin selkeÃ¤: suoritettavan metodin mÃ¤Ã¤rittelyÃ¤ etsitÃ¤Ã¤n ensin olion todellisen tyypin mÃ¤Ã¤rittelystÃ¤ ja jos sitÃ¤ ei lÃ¶ydy edetÃ¤Ã¤n yliluokkaan. Ja jos yliluokastakaan ei lÃ¶ydy metodin toteutusta siirrytÃ¤Ã¤n etsimÃ¤Ã¤n yliluokan yliluokasta jne...</p>

          <h3>Milloin perintÃ¤Ã¤ tulee kÃ¤yttÃ¤Ã¤?</h3>

          <p>PerintÃ¤ on vÃ¤line kÃ¤sitehierarkioiden rakentamiseen ja erikoistamiseen; aliluokka on aina yliluokan erikoistapaus. Jos luotava luokka on olemassaolevan luokan erikoistapaus, voidaan uusi luokka luoda perimÃ¤llÃ¤ olemassaoleva luokka. Esimerkiksi auton osiin liittyvÃ¤ssÃ¤ esimerkissÃ¤ moottori <em>on</em> osa, mutta moottoriin liittyy lisÃ¤toiminnallisuutta mitÃ¤ jokaisella osalla ei ole.</p>

          <p>PerittÃ¤essÃ¤ aliluokka saa kÃ¤yttÃ¶Ã¶nsÃ¤ yliluokan toiminnallisuudet. Jos aliluokka ei tarvitse tai kÃ¤ytÃ¤ perittyÃ¤ toiminnallisuutta, ei perintÃ¤ ole perusteltua. Perityt luokat perivÃ¤t yliluokkiensa metodit ja rajapinnat, eli aliluokkia voidaan kÃ¤yttÃ¤Ã¤ missÃ¤ tahansa missÃ¤ yliluokkaa on kÃ¤ytetty. PerintÃ¤hierarkia kannattaa mitÃ¤Ã¤ matalana, sillÃ¤ hierarkian yllÃ¤pito ja jatkokehitys vaikeutuu perintÃ¶hierarkian kasvaessa. Yleisesti ottaen, jos perintÃ¤hierarkian korkeus on yli 2 tai 3, ohjelman rakenteessa on todennÃ¤kÃ¶isesti parannettavaa.</p>

          <p>PerinÃ¤n kÃ¤yttÃ¶Ã¤ tulee miettiÃ¤. Esimerkiksi luokan <code>Auto</code> periminen luokasta <code>Osa</code> (tai <code>Moottori</code>) on vÃ¤Ã¤rin. Auto <em>sisÃ¤ltÃ¤Ã¤</em> moottorin ja osia, mutta auto ei ole moottori tai osa. Voimme yleisemmin ajatella ettÃ¤ jos olio omistaa tai koostuu toisista olioista, ei perintÃ¤Ã¤ tule kÃ¤yttÃ¤Ã¤.</p>

          <p>PerintÃ¤Ã¤ kÃ¤ytettÃ¤essÃ¤ tulee varmistaa ettÃ¤ Single Responsibility Principle pÃ¤tee myÃ¶s perittÃ¤essÃ¤. Jokaisella luokalla tulee olla vain yksi syy muuttua. Jos huomaat ettÃ¤ perintÃ¤ lisÃ¤Ã¤ luokan vastuita, tulee luokka pilkkoa useammaksi luokaksi.</p>

          <h4>Esimerkki: perinnÃ¤n vÃ¤Ã¤rinkÃ¤yttÃ¶</h4>

          <p>Pohditaan postituspalveluun liittyviÃ¤ luokkia <code>Asiakas</code>, joka sisÃ¤ltÃ¤Ã¤ asiakkaan tiedot, ja <code>Tilaus</code>, joka perii asiakkaan tiedot ja sisÃ¤ltÃ¤Ã¤ tilattavan tavaran tiedot. Luokassa <code>Tilaus</code> on myÃ¶s metodi <code>postitusOsoite</code>, joka kertoo tilauksen postitusosoitteen.</p>

<pre class="sh_java">
public class Asiakas {

    private String name;
    private String osoite;

    public Asiakas(String name, String osoite) {
        this.name = nimi;
        this.osoite = osoite;
    }

    public String getName() {
        return nimi;
    }

    public String getOsoite() {
        return osoite;
    }

    public void setOsoite(String osoite) {
        this.osoite = osoite;
    }
}
</pre>

<pre class="sh_java">
public class Tilaus extends Asiakas {

    private String tuote;
    private String lukumaara;

    public Tilaus(String tuote, String lukumaara, String name, String osoite) {
        super(nimi, osoite);
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.getName() + "\n" + this.getOsoite();
    }
}
</pre>

  <p>YllÃ¤ perintÃ¤Ã¤ on kÃ¤ytetty vÃ¤Ã¤rin. Luokkaa perittÃ¤essÃ¤ aliluokan tulee olla yliluokan erikoistapaus; tilaus ei ole asiakkaan erikoistapaus. VÃ¤Ã¤rinkÃ¤yttÃ¶ ilmenee single responsibility principlen rikkomisena: luokalla <code>Tilaus</code> on vastuu sekÃ¤ asiakkaan tietojen yllÃ¤pidosta, ettÃ¤ tilauksen tietojen yllÃ¤pidosta.</p>

  <p>Ratkaisussa piilevÃ¤ ongelma tulee esiin kun mietimme mitÃ¤ kÃ¤y asiakkaan osoitteen muuttuessa.</p>

  <p>Osoitteen muuttuessa joudumme muuttamaan <em>jokaista</em> kyseiseen asiakkaaseen liittyvÃ¤Ã¤ tilausoliota, mikÃ¤ kertoo huonosta tilanteesta. Parempi ratkaisu olisi kapseloida <code>Asiakas</code> <code>Tilaus</code>-luokan oliomuuttujaksi. Jos ajattelemme tarkemmin tilauksen semantiikkaa, tÃ¤mÃ¤ on selvÃ¤Ã¤. <em>Tilauksella on asiakas</em>. Muutetaan luokkaa <code>Tilaus</code> siten, ettÃ¤ se sisÃ¤ltÃ¤Ã¤ <code>Asiakas</code>-viitteen.</p>

<pre class="sh_java">
public class Tilaus {

    private Asiakas asiakas;
    private String tuote;
    private String lukumaara;

    public Tilaus(Asiakas asiakas, String tuote, String lukumaara) {
        this.asiakas = asiakas;
        this.tuote = tuote;
        this.lukumaara = lukumaara;
    }

    public String getTuote() {
        return tuote;
    }

    public String getLukumaara() {
        return lukumaara;
    }

    public String postitusOsoite() {
        return this.asiakas.getName() + "\n" + this.asiakas.getOsoite();
    }
}
</pre>

    <p>YllÃ¤ oleva luokka <code>Tilaus</code> on nyt parempi. Metodi <code>postitusosoite</code> kÃ¤yttÃ¤Ã¤ <em>asiakas</em>-viitettÃ¤ postitusosoitteen saamiseen sen sijaan ettÃ¤ luokka perisi luokan <code>Asiakas</code>. TÃ¤mÃ¤ helpottaa sekÃ¤ ohjelman yllÃ¤pitoa, ettÃ¤ sen konkreettista toiminnallisuutta. </p>

    <p>Nyt asiakkaan muuttaessa tarvitsee muuttaa vain asiakkaan tietoja, tilauksiin ei tarvitse tehdÃ¤ muutoksia.</p>

<div class="tehtavat">

<h3>Varastointia</h3>

<p>TehtÃ¤vÃ¤pohjassa tulee mukana luokka <code>Varasto</code>, jonka tarjoamat konstruktorit ja metodit ovat seuraavat:</p>

<ul>

<li><b>public Varasto(double tilavuus)</b><br/>
     Luo tyhjÃ¤n varaston, jonka vetoisuus eli tilavuus annetaan parametrina;
     sopimaton tilavuus (&lt;=0) luo kÃ¤yttÃ¶kelvottoman varaston,
     jonka tilavuus on 0.</li>

<li><b>public double getSaldo()</b><br/>
     Palauttaa arvonaan varaston saldon, eli varastossa olevan tilavuuden.</li>


<li><b>public double getTilavuus()</b><br/>
     Palauttaa arvonaan varaston tilavuuden (eli sen, joka annettiin konstruktorille).</li>

<li><b>public double paljonkoMahtuu()</b><br/>
     Palauttaa arvonaan tiedon, paljonko varastoon vielÃ¤ mahtuu.</li>

<li><b>public void lisaaVarastoon(double maara)</b><br/>
     LisÃ¤Ã¤ varastoon pyydetyn mÃ¤Ã¤rÃ¤n; jos mÃ¤Ã¤rÃ¤ on negatiivinen, mikÃ¤Ã¤n ei muutu,
     jos kaikki pyydetty ei enÃ¤Ã¤ mahdu, varasto laitetaan
     tÃ¤ydeksi ja loput mÃ¤Ã¤rÃ¤sÃ¤tÃ¤ "heitetÃ¤Ã¤n menemÃ¤Ã¤n", "vuotaa yli".</li>

<li><b>public double otaVarastosta(double maara)</b><br/>
    Otetaan varastosta pyydetty mÃ¤Ã¤rÃ¤, metodi palauttaa paljonko <b>saadaan</b>.
    Jos pyydetty mÃ¤Ã¤rÃ¤ on negatiivinen, mikÃ¤Ã¤n ei muutu ja palautetaan nolla.
    Jos pyydetÃ¤Ã¤n enemmÃ¤n kuin varastossa on, annetaan mitÃ¤ voidaan ja varasto
    tyhjenee.</li>

<li><b>public String toString()</b><br/>
    Palauttaa olion tilan characterStringesityksenÃ¤ tyyliin <tt>saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>TehtÃ¤vÃ¤ssÃ¤ rakennetaan <code>Varasto</code>-luokasta useampia erilaisia varastoja. Huom! Toteuta kaikki luokat pakkaukseen <code>varastot</code>.</p>

        <h4 class="req">Tuotevarasto, vaihe 1</h4>

        <p>Luokka <code>Varasto</code> hallitsee tuotteen mÃ¤Ã¤rÃ¤Ã¤n liittyvÃ¤t toiminnot. Nyt tuotteelle halutaan lisÃ¤ksi tuotenimi ja nimen kÃ¤sittelyvÃ¤lineet. <i>  <b>Ohjelmoidaan Tuotevarasto Varaston aliluokaksi!</b></i> Toteutetaan ensin pelkkÃ¤ yksityinen oliomuuttuja tuotenimelle, konstruktori ja getteri nimikentÃ¤lle:</p>


<ul>
<li><b>public Tuotevarasto(String tuotenimi, double tilavuus)</b><br/>
     Luo tyhjÃ¤n tuotevaraston. Tuotenimi ja vetoisuus annetaan parametrina.</li>


<li><b>public String getName()</b><br/>
     Palauttaa arvonaan tuotteen nimen.</li>
</ul>


        <p><i>Muista millÃ¤ tavoin konstruktori voi ensi toimenaan suorittaa yliluokan konstruktorin!</i></p>

        <p>KÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getName()); // Juice
        System.out.println(mehu);           // saldo = 988.7, tilaa 11.3
</pre>

<pre>
Juice
saldo = 988.7, vielÃ¤ tilaa 11.3
</pre>


<h4 class="req">Tuotevarasto, vaihe 2</h4>


<p>Kuten edellisestÃ¤ esimerkistÃ¤ nÃ¤kee, Tuotevarasto-olion perimÃ¤ <code>toString()</code> ei tiedÃ¤ (tietenkÃ¤Ã¤n!) mitÃ¤Ã¤n tuotteen nimestÃ¤. <i>Asialle on tehtÃ¤vÃ¤ jotain!</i> LisÃ¤tÃ¤Ã¤n samalla myÃ¶s setteri tuotenimelle:</p>

<ul>
<li><b>public void setNimi(String uusiNimi)</b> asettaa tuotteelle
       uuden nimen.</li>

<li><b>public String toString()</b> palauttaa olion tilan characterStringesityksenÃ¤
       tyyliin <tt>Juice: saldo = 64.5, tilaa 123.5</tt></li>
</ul>

        <p>Uuden <code>toString()</code>-metodin voisi toki ohjelmoida kÃ¤yttÃ¤en yliluokalta perittyjÃ¤ gettereitÃ¤, joilla perittyjen, mutta piilossa pidettyjen kenttien arvoja saa kÃ¤yttÃ¶Ã¶nsÃ¤. Koska yliluokkaan on kuitenkin jo ohjelmoitu tarvittava taito varastotilanteen merkkiesityksen tuottamiseen, miksi nÃ¤hdÃ¤ vaivaa sen uudelleen ohjelmointiin. KÃ¤ytÃ¤ siis hyvÃ¤ksesi perittyÃ¤ <code>toString</code>iÃ¤.</p>

        <p><i>Muista miten korvattua metodia voi kutsua aliluokassa!</i></p>

        <p>KÃ¤yttÃ¶esimerkki:</p>

<pre class="sh_java">
        Tuotevarasto mehu = new Tuotevarasto("Juice", 1000.0);
        mehu.lisaaVarastoon(1000.0);
        mehu.otaVarastosta(11.3);
        System.out.println(mehu.getName()); // Juice
        mehu.lisaaVarastoon(1.0);
        System.out.println(mehu);           // Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>

<pre>
Juice
Juice: saldo = 989.7, tilaa 10.299999999999955
</pre>


<h4>Muutoshistoria</h4>

        <p>Toisinaan saattaa olla kiinostavaa tietÃ¤Ã¤, millÃ¤ tavoin jonkin tuotteen varastotilanne muuttuu: onko varasto usein hyvin vajaa, ollaanko usein ylÃ¤rajalla, onko vaihelu suurta vai pientÃ¤, jne. Varustetaan siksi <code>Tuotevarasto</code>-luokka taidolla muistaa tuotteen mÃ¤Ã¤rÃ¤n muutoshistoriaa.</p>

        <p>Aloitetaan apuvÃ¤lineen laadinnalla.</p>

        <p>Muutoshistorian muistamisen voisi toki toteuttaa suoraankin <code>ArrayList&lt;Double&gt;</code>-oliona luokassa <i>Tuotevarasto</i>, mutta nyt laaditaan kuitenkin oma <i>erikoistettu vÃ¤line</i> tÃ¤hÃ¤n tarkoitukseen. VÃ¤line toteutetaan kapseloimalla <code>ArrayList&lt;Double&gt;</code>-olio.</p>

        <p><code>Muutoshistoria</code>-luokan julkiset konstruktorit ja metodit:</p>

<ul>
<li><b>public Muutoshistoria()</b> luo tyhjÃ¤n <code>Muutoshistoria</code>-olion.</li>

<li><b>public void lisaa(double tilanne)</b> lisÃ¤Ã¤ muutoshistorian viimeisimmÃ¤ksi muistettavaksi mÃ¤Ã¤rÃ¤ksi parametrina annetun tilanteen. </li>

<li><b>public void nollaa()</b> tyhjÃ¤Ã¤ muistin.</li>

<li><b>public String toString()</b> palauttaa muutoshistorian
    characterStringesityksen. <i>ArrayList-luokan antama characterStringesitys kelpaa sellaisenaan.</i> </li>

</ul>


<h4 class="req">Muutoshistoria.java, vaihe 2</h4>

<p>
TÃ¤ydennÃ¤ <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>

<li><b>public double maxArvo()</b> palauttaa muutoshistorian
   suurimman arvon. Jos historia on tyhjÃ¤, metodi palauttaa nollan.</li>


<li><b>public double minArvo()</b> palauttaa muutoshistorian
   pienimmÃ¤n arvon. Jos historia on tyhjÃ¤, metodi palauttaa nollan.</li>

<li><b>public double keskiarvo()</b> palauttaa muutoshistorian
    arvojen keskiarvon. Jos historia on tyhjÃ¤, metodi palauttaa nollan.</li>

</ul>

<h4>Muutoshistoria.java, vaihe 3</h4>

<p>
TÃ¤ydennÃ¤ <code>Muutoshistoria</code>-luokkaa analyysimetodein:</p>

<ul>
<li><b>public double suurinMuutos()</b> palauttaa muutoshistorian isoimman (huom: -5:n kokoinen muutos on isompi kuin 4:n kokoinen muutos) yksittÃ¤isen muutoksen itseisarvon. Jos historia on tyhjÃ¤ tai yhden arvon mittainen, metodi palauttaa nollan. Itseisarvo on luvun etÃ¤isyys nollasta. Esimerkiksi luvun -5.5 itseisarvo on 5.5, luvun 3.2 itseisarvo on 3.2. </li>

<li><b>public double varianssi()</b> palauttaa muutoshistorian arvojen varianssin (kÃ¤ytetÃ¤Ã¤n otosvarianssin kaavaa). Jos historia on tyhjÃ¤ tai yhden arvon mittainen, metodi palauttaa nollan.</li>
</ul>

<p>Ohjeen varianssin laskemiseksi voit katsoa esimerkiksi <a href="http://fi.wikipedia.org/wiki/Varianssi#Populaatio-_ja_otosvarianssi">Wikipediasta</a> kohdasta populaatio- ja otosvarianssi. Esimerkiksi lukujen 3, 2, 7, 2 keskiarvo on 3.5, joten otosvarianssi on ((3 - 3.5)Â² + (2 - 3.5)Â² + (7 - 3.5)Â² + (2 - 3.5)Â²)/(4 - 1) Ë 5,666667.)</p>




<h4 class="req">MuistavaTuotevarasto, vaihe 1</h4>

<p>
Toteuta luokan <code>Tuotevarasto</code> aliluokkana <code>MuistavaTuotevarasto</code>.
Uusi versio tarjoaa vanhojen lisÃ¤ksi varastotilanteen muutoshistoriaan liittyviÃ¤
palveluita. Historiaa hallitaan <code>Muutoshistoria</code>-oliolla.
</p>

<p>
Julkiset konstruktorit ja metodit:</p>

<ul>

<li><b>public MuistavaTuotevarasto(String tuotenimi, double tilavuus, double alkuSaldo)</b>
     luo tuotevaraston. Tuotenimi, vetoisuus ja alkusaldo annetaan parametrina.
     <i>Aseta alkusaldo sekÃ¤ varaston alkusaldoksi ettÃ¤ muutoshistorian ensimmÃ¤iseksi arvoksi.</i>

<li><b>public String historia()</b> palauttaa tuotehistorian tyyliin
       <tt>[0.0, 119.2, 21.2]</tt>.  <i>KÃ¤ytÃ¤ Muutoshistoria-olion merkkiesitystÃ¤ sellaisenaan.</i>

</ul>
<p>
<b>Huomaa</b> ettÃ¤ tÃ¤ssÃ¤ esiversiossa historia ei vielÃ¤ toimi kunnolla; nyt vasta vain aloitussaldo muistetaan.
</p>

<p>
KÃ¤yttÃ¶esimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getName()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielÃ¤ tilaa 10.3
...
<b>// mutta vielÃ¤ historia() ei toimi kunnolla:</b>
System.out.println(mehu.historia()); // [1000.0]
   // saadaan siis vasta konstruktorin asettama historian alkupiste...
...
</pre>


<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielÃ¤ tilaa 10.299999999999955
[1000.0]
</pre>

<h4 class="req">MuistavaTuotevarasto, vaihe 2</h4>

<p>
<i>On aika aloittaa historia!</i> EnsimmÃ¤inen versio ei historiasta tiennyt kuin alkupisteen. TÃ¤ydennÃ¤ luokkaa metodein
</p>
<ul>

<li><b>public void lisaaVarastoon(double maara)</b>

    toimii kuin <i>Varasto</i>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan.
<b>Huom: </b> historiaan tulee kirjata lisÃ¤yksen jÃ¤lkeinen varastosaldo, ei lisÃ¤ttÃ¤vÃ¤Ã¤ mÃ¤Ã¤rÃ¤Ã¤!
</li>



<li><b>public double otaVarastosta(double maara)</b> toimii kuin <code>Varasto</code>-luokan metodi, mutta muuttunut tilanne kirjataan historiaan. <b>Huom: </b> historiaan tulee kirjata poiston jÃ¤lkeinen varastosaldo, ei poistettavaa mÃ¤Ã¤rÃ¤Ã¤!</li>

</ul>

<p>
KÃ¤yttÃ¶esimerkki:
</p>

<pre class="sh_java">
// tuttuun tapaan:
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
System.out.println(mehu.getName()); // Juice
mehu.lisaaVarastoon(1.0);
System.out.println(mehu);           // Juice: saldo = 989.7, vielÃ¤ tilaa 10.3
...
// mutta nyt on historiaakin:
System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]
...
</pre>
<p>
Tulostus siis:
</p>
<pre>
Juice
Juice: saldo = 989.7, vielÃ¤ tilaa 10.299999999999955
[1000.0, 988.7, 989.7]
</pre>
<p>

<p>
<i>Muista miten korvaava metodi voi kÃ¤yttÃ¤Ã¤ hyvÃ¤kseen korvattua metodia!</i>
</p>


<h4 class="req">MuistavaTuotevarasto, vaihe 3</h4>
<p>
TÃ¤ydennÃ¤ luokkaa metodilla
</p>
<ul>

<li><b>public void tulostaAnalyysi()</b>, joka tulostaa
     tuotteeseen liittyviÃ¤ historiatietoja esimerkin
     esittÃ¤mÃ¤Ã¤n tapaan.</li>
</ul>

<p>
KÃ¤yttÃ¶esimerkki:
</p>
<pre class="sh_java">
MuistavaTuotevarasto mehu = new MuistavaTuotevarasto("Juice", 1000.0, 1000.0);
mehu.otaVarastosta(11.3);
mehu.lisaaVarastoon(1.0);
//System.out.println(mehu.historia()); // [1000.0, 988.7, 989.7]

mehu.tulostaAnalyysi();
</pre>
<p>
Metodi <i>tulostaAnalyysi</i> kirjoittaa ilmoituksen tyyliin:
</p>

<pre>
Tuote: Juice
Historia: [1000.0, 988.7, 989.7]
Suurin tuotemÃ¤Ã¤rÃ¤: 1000.0
Pienin tuotemÃ¤Ã¤rÃ¤: 988.7
Keskiarvo: 992.8
</pre>
<p>

<h4>MuistavaTuotevarasto, vaihe 4</h4>
<p>
TÃ¤ydennÃ¤ analyysin tulostus sellaiseksi, ettÃ¤ mukana ovat myÃ¶s muutoshistorian suurin muutos ja historian varianssi.
</p>

</div>


<h3>PerintÃ¤, rajapinnat, kumpikin, vai eikÃ¶ kumpaakaan?</h3>

<p>PerintÃ¤ ei sulje pois rajapintojen kÃ¤yttÃ¶Ã¤, eikÃ¤ rajapintojen kÃ¤yttÃ¶ sulje pois perinnÃ¤n kÃ¤yttÃ¶Ã¤. Rajapinnat toimivat sopimuksena luokan tarjoamasta toteutuksesta, ja mahdollistavat konkreettisen toteutuksen abstrahoinnin. Rajapinnan toteuttavan luokan vaihto on hyvin helppoa.</p>

        <p>Aivan kuten rajapintaa toteuttaessa, sitoudumme perittÃ¤essÃ¤ siihen, ettÃ¤ aliluokkamme tarjoaa kaikki yliluokan metodit. Monimuotoisuuden ja polymorfismin takia perintÃ¤kin toimii kuin rajapinnat. Voimme antaa yliluokkaa kÃ¤yttÃ¤vÃ¤lle metodille sen aliluokan ilmentymÃ¤n.</p>

        <p>TehdÃ¤Ã¤n seuraavaksi maatilasimulaattori, jossa simuloidaan maatilan elÃ¤mÃ¤Ã¤. Huomaa ettÃ¤ ohjelmassa ei kÃ¤ytetÃ¤ perintÃ¤Ã¤, ja rajapintojenkin kÃ¤yttÃ¶ on melko vÃ¤hÃ¤istÃ¤. Usein ohjelmat tehdÃ¤Ã¤nkin niin ettÃ¤ ensin toteutetaan yksi versio, jota lÃ¤hdetÃ¤Ã¤n parantamaan myÃ¶hemmin. TyypillistÃ¤ on ettÃ¤ ensimmÃ¤istÃ¤ versiota toteutettaessa ongelma-aluetta ei vielÃ¤ ymmÃ¤rretÃ¤ kunnolla, jolloin rajapintojen ja kÃ¤sitehierarkioiden suunnittelu ennalta on hyvin vaikeaa ja saattaa jopa hidastaa tyÃ¶skentelyÃ¤.</p>


<div class="tehtavat">
<h3>Maatilasimulaattori</h3>

<p>
Maatiloilla on lypsÃ¤viÃ¤ elÃ¤imiÃ¤, jotka tuottavat maitoa.  Maatilat
eivÃ¤t itse kÃ¤sittele maitoa, vaan se kuljetetaan Maitoautoilla
meijereille.  Meijerit ovat yleisiÃ¤ maitotuotteita tuottavia
rakennuksia.  Jokainen meijeri erikoistuu yhteen tuotetyyppiin,
esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja
Maitomeijeri tuottaa maitoa.
<p>

<p>
Rakennetaan maidon elÃ¤mÃ¤Ã¤ kuvaava simulaattori. Toteuta kaikki luokat pakkaukseen <code>maatilasimulaattori</code>.
<p>


<h4>MaitosÃ¤iliÃ¶</h4>

<p>
Jotta maito pysyisi tuoreena, tÃ¤ytyy se sÃ¤ilÃ¶Ã¤ sille tarkoitettuun sÃ¤iliÃ¶Ã¶n.
SÃ¤iliÃ¶itÃ¤ valmistetaan sekÃ¤ oletustilavuudella 2000 litraa, ettÃ¤
asiakkaalle rÃ¤Ã¤tÃ¤lÃ¶idyllÃ¤ tilavuudella.  Toteuta luokka Maitosailio
jolla on seuraavat konstruktorit ja metodit.
</p>

  <ul>
    <li><strong>public Maitosailio()</strong></li>
    <li><strong>public Maitosailio(double tilavuus)</strong></li>
    <li><strong>public double getTilavuus()</strong></li>
    <li><strong>public double getSaldo()</strong></li>
    <li><strong>public double paljonkoTilaaJaljella()</strong></li>
    <li><strong>public void lisaaSailioon(double maara)</strong>
      lisÃ¤Ã¤ sÃ¤iliÃ¶Ã¶n vain niin paljon maitoa kuin sinne mahtuu,
      ylimÃ¤Ã¤rÃ¤iset jÃ¤Ã¤vÃ¤t lisÃ¤Ã¤mÃ¤ttÃ¤, maitosÃ¤iliÃ¶n ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</li>
    <li><strong>public double otaSailiosta(double maara)</strong>
      ottaa sÃ¤iliÃ¶stÃ¤ pyydetyn mÃ¤Ã¤rÃ¤n, tai niin paljon kuin siellÃ¤ on jÃ¤ljellÃ¤
    </li>
  </ul>

<p>
Toteuta <code>Maitosailio</code>-luokalle myÃ¶s <code>toString()</code>-metodi, jolla kuvaat sen tilaa.
Ilmaistessasi sÃ¤iliÃ¶n tilaa <code>toString()</code>-metodissa, pyÃ¶ristÃ¤ litramÃ¤Ã¤rÃ¤t
ylÃ¶spÃ¤in kÃ¤yttÃ¤en <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.
</p>

<p>Testaa maitosailiÃ¶tÃ¤ seuraavalla ohjelmapÃ¤tkÃ¤llÃ¤:</p>

<pre class="sh_java">
        Maitosailio sailio = new Maitosailio();
        sailio.otaSailiosta(100);
        sailio.lisaaSailioon(25);
        sailio.otaSailiosta(5);
        System.out.println(sailio);

        sailio = new Maitosailio(50);
        sailio.lisaaSailioon(100);
        System.out.println(sailio);
</pre>


<p>Ohjelman tulostuksen tulee olla seuraavankaltainen:</p>

<pre>
20.0/2000.0
50.0/50.0
</pre>

<p>
Huomaa ettÃ¤ kutsuttaessa <code>System</code>-luokan <code>out</code>-olioon liittyvÃ¤Ã¤
<code>println()</code>-metodia, joka saa parametrikseen <code>Object</code>-tyyppisen
muuttujan, tulostus kÃ¤yttÃ¤Ã¤ <code>Maitosailio</code>-luokassa korvattua
<code>toString()</code>-metodia! TÃ¤ssÃ¤ on kyse polymorfismista, eli
ajonaikaisesta kÃ¤ytettÃ¤vien metodien pÃ¤Ã¤ttelystÃ¤.
</p>

<h4>LehmÃ¤</h4>

<p>Saadaksemme maitoa tarvitsemme myÃ¶s lehmiÃ¤. LehmÃ¤llÃ¤ on nimi ja utareet. Utareiden tilavuus on satunnainen luku vÃ¤liltÃ¤ 15 ja 40, luokkaa <code>Random</code> voi kÃ¤yttÃ¤Ã¤Ã¤ satunnaislukujen arpomiseen, esimerkiksi  <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code> on seuraavat toiminnot:</p>

  <ul>
    <li><strong>public Lehma()</strong> luo uuden lehmÃ¤n satunnaisesti valitulla nimellÃ¤</li>
    <li><strong>public Lehma(String name)</strong> luo uuden lehmÃ¤n annetulla nimellÃ¤</li>
    <li><strong>String getName()</strong> palauttaa lehmÃ¤n nimen</li>
    <li><strong>double getTilavuus()</strong> palauttaa utareiden tilavuuden</li>
    <li><strong>double getMaara()</strong> palauttaa utareissa olevan maidon mÃ¤Ã¤rÃ¤n</li>
    <li><strong>String toString()</strong> palauttaa lehmÃ¤Ã¤ kuvaavan characterStringn (ks. esimerkki alla)</li>
  </ul>

<p><code>Lehma</code> toteuttaa myÃ¶s rajapinnat: <code>Lypsava</code>, joka kuvaa lypsÃ¤miskÃ¤yttÃ¤ytymistÃ¤, ja <code>Eleleva</code>, joka kuvaa elelemiskÃ¤yttÃ¤ytymistÃ¤.</p>

<pre class="sh_java">
public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
</pre>

<p>
LehmÃ¤Ã¤ lypsettÃ¤essÃ¤ sen koko maitovarasto tyhjennetÃ¤Ã¤n jatkokÃ¤sittelyÃ¤
varten.  LehmÃ¤n elellessÃ¤ sen maitovarasto tÃ¤yttyy hiljalleen.
Suomessa maidontuotannossa kÃ¤ytetyt lehmÃ¤t tuottavat keskimÃ¤Ã¤rin
noin 25-30 litraa maitoa pÃ¤ivÃ¤ssÃ¤.  Simuloidaan tÃ¤tÃ¤ tuotantoa
tuottamalla noin 0.7 - 2 litraa tunnissa.
</p>

<p>
Jos lehmÃ¤lle ei anneta nimeÃ¤, valitse sille nimi satunnaisesti seuraavasta listasta.
</p>

<pre class="sh_java">
    private static final String[] NIMIA = new String[]{
        "Anu", "Arpa", "Essi", "Heluna", "Hely",
        "Hento", "Hilke", "Hilsu", "Hymy", "Ihq", "Ilme", "Ilo",
        "Jaana", "Jami", "Jatta", "Laku", "Liekki",
        "Mainikki", "Mella", "Mimmi", "Naatti",
        "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
        "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
</pre>

<p>Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmapÃ¤tkÃ¤n avulla.</p>

<pre class="sh_java">
        Lehma lehma = new Lehma();
        System.out.println(lehma);


        Eleleva elelevaLehma = lehma;
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();
        elelevaLehma.eleleTunti();

        System.out.println(lehma);

        Lypsava lypsavaLehma = lehma;
        lypsavaLehma.lypsa();

        System.out.println(lehma);
        System.out.println("");

        lehma = new Lehma("Ammu");
        System.out.println(lehma);
        lehma.eleleTunti();
        lehma.eleleTunti();
        System.out.println(lehma);
        lehma.lypsa();
        System.out.println(lehma);

</pre>

<p>
Ohjelman tulostus on erimerkiksi seuraavanlainen.</p>

</p>

<pre>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
</pre>


<h4>Lypsyrobotti</h4>
<p>
Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lypsÃ¤misen.
Jotta lypsyrobotti voi lypsÃ¤Ã¤ lypsÃ¤vÃ¤Ã¤ otusta, tulee lypsyrobotin
olla kiinnitetty maitosÃ¤iliÃ¶Ã¶n:
</p>

  <ul>
    <li><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</li>
    <li><strong>Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitosÃ¤iliÃ¶ tai <code>null</code>-viitteen, jos sÃ¤iliÃ¶tÃ¤ ei ole vielÃ¤ kiinnitetty</li>
    <li><strong>void setMaitosailio(Maitosailio maitosailio)</strong> kiinnittÃ¤Ã¤ annetun sÃ¤iliÃ¶n lypsyrobottiin</li>
    <li><strong>void lypsa(Lypsava lypsava)</strong> lypsÃ¤Ã¤ lehmÃ¤n robottiin kiinnitettyyn maitosÃ¤iliÃ¶Ã¶n, metodi heittÃ¤Ã¤ poikkeuksen <code>IllegalStateException</code>, jos sÃ¤iliÃ¶tÃ¤ ei ole kiinnitetty </li>
  </ul>

<p>Toteuta luokka Lypsyrobotti ja testaa sitÃ¤ seuraavien ohjelmanpÃ¤tkien avulla. Varmista ettÃ¤ lypsyrobotti voi lypsÃ¤Ã¤ kaikkia Lypsava-rajapinnan toteuttavia olioita!</p>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        lypsyrobotti.lypsa(lehma);
</pre>

<pre>
Exception in thread "main" java.lang.IllegalStateException: MaitosÃ¤iliÃ¶tÃ¤ ei ole asennettu
        at maatilasimulaattori.Lypsyrobotti.lypsa(Lypsyrobotti.java:17)
        at maatilasimulaattori.Main.main(Main.java:9)
Java Result: 1
</pre>

<pre class="sh_java">
        Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
        Lehma lehma = new Lehma();
        System.out.println("");

        Maitosailio sailio = new Maitosailio();
        lypsyrobotti.setMaitosailio(sailio);
        System.out.println("SÃ¤iliÃ¶: " + sailio);

        for(int i = 0; i &lt; 2; i++) {
            System.out.println(lehma);
            System.out.println("ElellÃ¤Ã¤n..");
            for(int j = 0; j &lt; 5; j++) {
                lehma.eleleTunti();
            }
            System.out.println(lehma);

            System.out.println("LypsetÃ¤Ã¤n...");
            lypsyrobotti.lypsa(lehma);
            System.out.println("SÃ¤iliÃ¶: " + sailio);
            System.out.println("");
        }
</pre>

<p>Ohjelman tulostus on esimerkiksi seuraavanlainen.</p>

<pre>
SÃ¤iliÃ¶: 0.0/2000.0
Mella 0.0/23.0
ElellÃ¤Ã¤n..
Mella 6.2/23.0
LypsetÃ¤Ã¤n...
SÃ¤iliÃ¶: 6.2/2000.0

Mella 0.0/23.0
ElellÃ¤Ã¤n..
Mella 7.8/23.0
LypsetÃ¤Ã¤n...
SÃ¤iliÃ¶: 14.0/2000.0
</pre>

<h4>Navetta</h4>

<p>
LehmÃ¤t hoidetaan (eli tÃ¤ssÃ¤ tapauksessa lypsetÃ¤Ã¤n) navetassa.
Alkukantaisissa navetoissa on maitosÃ¤iliÃ¶ ja tilaa yhdelle
lypsyrobotille. Huomaa ettÃ¤ lypsyrobottia asennettaessa se kytketÃ¤Ã¤n
juuri kyseisen navetan maitosÃ¤iliÃ¶Ã¶n.  Jos navetassa ei ole
lypsyrobottia, ei siellÃ¤ voida myÃ¶skÃ¤Ã¤n hoitaa lehmiÃ¤.
Toteuta luokka <code>Navetta</code> jolla on seuraavat konstruktorit ja metodit:
</p>

  <ul>
    <li><strong>public Navetta(Maitosailio maitosailio)</strong></li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</li>
    <li><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnittÃ¤Ã¤ sen navetan maitosÃ¤iliÃ¶Ã¶n</li>
    <li><strong>public void hoida(Lehma lehma)</strong> lypsÃ¤Ã¤ parametrina annetun lehmÃ¤n lypsyrobotin avulla, metodi heittÃ¤Ã¤ poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lypsÃ¤Ã¤ parametrina annetut lehmÃ¤t lypsyrobotin avulla, metodi heittÃ¤Ã¤ poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public String toString()</strong> palauttaa navetan sisÃ¤ltÃ¤mÃ¤n maitosÃ¤iliÃ¶n tilan</li>
  </ul>

<p><code>Collection</code> on Javan oma rajapinta joka kuvaa kokoelmien kÃ¤yttÃ¤ytymistÃ¤.  Esimerkiksi luokat <code>ArrayList</code> ja <code>LinkedList</code> toteuttavat rajapinnan <code>Collection</code>. Jokaista <code>Collection</code>-rajapinnan toteuttavaa ilmentymÃ¤Ã¤ voi myÃ¶s iteroida for-each-tyyppisesti.</p>

<p>
Testaa luokkaa <code>Navetta</code> seuraavan ohjelmapÃ¤tkÃ¤n avulla.
ÃlÃ¤ hermoile luokasta <code>LinkedList</code>, se toimii ulkoapÃ¤in katsottuna
kuin <code>ArrayList</code>, mutta sen kapseloima toteutus on hieman erilainen.
TÃ¤stÃ¤ lisÃ¤Ã¤ tietorakenteet-kurssilla!
</p>

<pre class="sh_java">
        Navetta navetta = new Navetta(new Maitosailio());
        System.out.println("Navetta: " + navetta);

        Lypsyrobotti robo = new Lypsyrobotti();
        navetta.asennaLypsyrobotti(robo);

        Lehma ammu = new Lehma();
        ammu.eleleTunti();
        ammu.eleleTunti();

        navetta.hoida(ammu);
        System.out.println("Navetta: " + navetta);

        LinkedList&lt;Lehma&gt; lehmaLista = new LinkedList();
        lehmaLista.add(ammu);
        lehmaLista.add(new Lehma());

        for(Lehma lehma: lehmaLista) {
            lehma.eleleTunti();
            lehma.eleleTunti();
        }

        navetta.hoida(lehmaLista);
        System.out.println("Navetta: " + navetta);
</pre>

<p>
Tulostuksen tulee olla esimerkiksi seuraavanlainen:
</p>

<pre>
Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
</pre>

<h4>Maatila</h4>

<p>
Maatilalla on omistaja ja siihen kuuluu navetta sekÃ¤ joukko lehmiÃ¤.
Maatila toteuttaa myÃ¶s aiemmin nÃ¤hdyn rajapinnan <code>Eleleva</code>,
jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan
liittyvÃ¤t lehmÃ¤t elelevÃ¤t tunnin.  Toteuta luokka maatila siten,
ettÃ¤ se toimii seuraavien esimerkkiohjelmien mukaisesti.
</p>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        System.out.println(maatila);

        System.out.println(maatila.getOmistaja() + " on ahkera mies!");
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosÃ¤iliÃ¶: 0.0/2000.0
Ei lehmiÃ¤.
Esko on ahkera mies!
</pre>


<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        System.out.println(maatila);
</pre>


<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosÃ¤iliÃ¶: 0.0/2000.0
LehmÃ¤t:
        Naatti 0.0/19.0
        Hilke 0.0/30.0
        Sylkki 0.0/29.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosÃ¤iliÃ¶: 0.0/2000.0
LehmÃ¤t:
        Heluna 2.0/17.0
        Rima 3.0/32.0
        Ilo 3.0/25.0
</pre>

<pre class="sh_java">
        Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
        Lypsyrobotti robo = new Lypsyrobotti();
        maatila.asennaNavettaanLypsyrobotti(robo);

        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());
        maatila.lisaaLehma(new Lehma());

        maatila.eleleTunti();
        maatila.eleleTunti();

        maatila.hoidaLehmat();

        System.out.println(maatila);
</pre>

<p>
Odotettu tulostus:
</p>

<pre>
Maatilan omistaja: Esko
Navetan maitosÃ¤iliÃ¶: 18.0/2000.0
LehmÃ¤t:
        Hilke 0.0/30.0
        Sylkki 0.0/35.0
        Hento 0.0/34.0
</pre>
</div>


<h3>Abstrakti luokka</h3>

        <p>Abstrakti luokka yhdistÃ¤Ã¤ rajapintoja ja perintÃ¤Ã¤. NiistÃ¤ ei voi tehdÃ¤ ilmentymiÃ¤, vaan ilmentymÃ¤t tehdÃ¤Ã¤n tehdÃ¤Ã¤n abstraktin luokan aliluokista.  Abstrakti luokka voi sisÃ¤ltÃ¤Ã¤ sekÃ¤ normaaleja metodeja, joissa on metodirunko, ettÃ¤ abstrakteja metodeja, jotka sisÃ¤ltÃ¤vÃ¤t ainoastaan metodimÃ¤Ã¤rittelyn. Abstraktien metodien toteutus jÃ¤tetÃ¤Ã¤n perivÃ¤n luokan vastuulle. Yleisesti ajatellen abstrakteja luokkia kÃ¤ytetÃ¤Ã¤n esimerkiksi kun abstraktin luokan kuvaama kÃ¤site ei ole selkeÃ¤ itsenÃ¤inen kÃ¤site. TÃ¤llÃ¶in siitÃ¤ ei tule pystyÃ¤ tekemÃ¤Ã¤n ilmentymiÃ¤. </p>

        <p>SekÃ¤ abstraktin luokan ettÃ¤ abstraktien metodien mÃ¤Ã¤rittelyssÃ¤ kÃ¤ytetÃ¤Ã¤n avainsanaa <code>abstract</code>. Abstrakti luokka mÃ¤Ã¤ritellÃ¤Ã¤n lauseella <code>public abstract class <em>LuokanNimi</em></code>, abstrakti metodi taas lauseella <code>public abstract <em>palautustyyppi</em> <em>metodinNimi</em></code>. Pohditaan seuraavaa abstraktia luokkaa <code>Toiminto</code>, joka tarjoaa rungon toiminnoille ja niiden suorittamiselle.</p>

<pre class="sh_java">
public abstract class Toiminto {

    private String name;

    public Toiminto(String name) {
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }

    public abstract void suorita(Scanner lukija);
}
</pre>

        <p>Abstrakti luokka <code>Toiminto</code> toimii runkona erilaisten toimintojen toteuttamiseen. Esimerkiksi pluslaskun voi toteuttaa perimÃ¤llÃ¤ luokka <code>Toiminto</code> seuraavasti.</p>

<pre class="sh_java">
public class Pluslasku extends Toiminto {

    public Pluslasku() {
        super("Pluslasku");
    }

    @Override
    public void suorita(Scanner lukija) {
        System.out.print("Anna ensimmÃ¤inen luku: ");
        int eka = Integer.parseInt(reader.nextLine());
        System.out.print("Anna toinen luku: ");
        int toka = Integer.parseInt(reader.nextLine());

        System.out.println("Lukujen summa on " + (eka + toka));
    }
}
</pre>

        <p>Koska kaikki <code>Toiminto</code>-luokan perivÃ¤t luokat ovat myÃ¶s tyyppiÃ¤ toiminto, voimme rakentaa kÃ¤yttÃ¶liittymÃ¤n <code>Toiminto</code>-tyyppisten muuttujien varaan. Seuraava luokka <code>Kayttoliittyma</code> sisaltaa listan toimintoja ja lukijan. Toimintoja voi lisÃ¤tÃ¤ kÃ¤yttÃ¶liittymÃ¤Ã¤n dynaamisesti.</p>

<pre class="sh_java">
public class Kayttoliittyma {

    private Scanner lukija;
    private List&lt;Toiminto&gt; toiminnot;

    public Kayttoliittyma(Scanner lukija) {
        this.lukija = lukija;
        this.toiminnot = new ArrayList&lt;Toiminto&gt;();
    }

    public void lisaaToiminto(Toiminto toiminto) {
        this.toiminnot.add(toiminto);
    }

    public void start() {
        while (true) {
            tulostaToiminnot();
            System.out.println("Valinta: ");

            String valinta = this.reader.nextLine();
            if (valinta.equals("0")) {
                break;
            }

            suoritaToiminto(valinta);
            System.out.println();
        }
    }

    private void tulostaToiminnot() {
        System.out.println("\t0: Lopeta");
        for (int i = 0; i < this.toiminnot.size(); i++) {
            String toiminnonNimi = this.toiminnot.get(i).getName();
            System.out.println("\t" + (i + 1) + ": " + toiminnonNimi);
        }
    }

    private void suoritaToiminto(String valinta) {
        int toiminto = Integer.parseInt(valinta);

        Toiminto valittu = this.toiminnot.get(toiminto - 1);
        valittu.suorita(lukija);
    }
}
</pre>

        <p>KÃ¤yttÃ¶liittymÃ¤ toimii seuraavasti:</p>

<pre class="sh_java">
        Kayttoliittyma kayttolittyma = new Kayttoliittyma(new Scanner(System.in));
        kayttolittyma.lisaaToiminto(new Pluslasku());

        kayttolittyma.start();
</pre>

<pre>
Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">1</font>
Anna ensimmÃ¤inen luku: <font color="red">8</font>
Anna toinen luku: <font color="red">12</font>
Lukujen summa on 20

Toiminnot:
        0: Lopeta
        1: Pluslasku
Valinta: <font color="red">0</font>
</pre>

        <p>Rajapintojen ja abstraktien luokkien ero on siinÃ¤, ettÃ¤ abstraktit luokat tarjoavat enemmÃ¤n rakennetta ohjelmaan. Koska abstrakteihin luokkiin voidaan mÃ¤Ã¤ritellÃ¤ toiminnallisuutta, voidaan niitÃ¤ kÃ¤yttÃ¤Ã¤ esimerkiksi oletustoiminnallisuuden mÃ¤Ã¤rittelyyn. YllÃ¤ kÃ¤yttÃ¶liittymÃ¤ kÃ¤ytti abstraktissa luokassa mÃ¤Ã¤riteltyÃ¤ toiminnan nimen tallentamista.</p>


<div class="tehtavat">
  <h3>Erilaisia laatikoita</h3>

  <p>TehtÃ¤vÃ¤pohjan mukana tulee luokat <code>Tavara</code> ja <code>Laatikko</code>. Luokka <code>Laatikko</code> on abstrakti luokka, jossa useamman tavaran lisÃ¤Ã¤minen on toteutettu siten, ettÃ¤ kutsutaan aina <code>lisaa</code>-metodia. Yhden tavaran lisÃ¤Ã¤miseen tarkoitettu metodi <code>lisaa</code> on abstrakti, joten jokaisen <code>Laatikko</code>-luokan perivÃ¤n laatikon tulee toteuttaa se. TehtÃ¤vÃ¤nÃ¤si on muokata luokkaa <code>Tavara</code> ja toteuttaa muutamia erilaisia laatikoita luokan <code>Laatikko</code> pohjalta.</p>

  <p>LisÃ¤Ã¤ kaikki uudet luokat pakkaukseen <code>laatikot</code>.</p>


<pre class="sh_java">
package laatikot;

import java.util.Collection;

public abstract class Laatikko {

    public abstract void lisaa(Tavara tavara);

    public void lisaa(Collection&lt;Tavara&gt; tavarat) {
        for (Tavara tavara : tavarat) {
            lisaa(tavara);
        }
    }

    public abstract boolean onkoLaatikossa(Tavara tavara);
}
</pre>

<h4>Tavaran muokkaus</h4>

  <p>LisÃ¤Ã¤ <code>Tavara</code>-luokan konstruktoriin tarkistus, jossa tarkistetaan ettÃ¤ tavaran paino ei ole koskaan negatiivinen (paino 0 hyvÃ¤ksytÃ¤Ã¤n). Jos paino on negatiivinen, tulee konstruktorin heittÃ¤Ã¤ <code>IllegalArgumentException</code>-poikkeus. Toteuta <code>Tavara</code>-luokalle myÃ¶s metodit <code>equals</code> ja <code>hashCode</code>, joiden avulla  pÃ¤Ã¤set hyÃ¶dyntÃ¤mÃ¤Ã¤n erilaisten listojen ja kokoelmien <code>contains</code>-metodia. Toteuta metodit siten, ettÃ¤ Tavara-luokan oliomuuttujan <code>paino</code> arvolla ei ole vÃ¤liÃ¤. <em>Voit hyvin hyÃ¶dyntÃ¤Ã¤ NetBeansin tarjoamaa toiminnallisuutta equalsin ja hashCoden toteuttamiseen.</em></p>

<h4>Maksimipainollinen laatikko</h4>

  <p>Toteuta pakkaukseen <code>laatikot</code> luokka <code>MaksimipainollinenLaatikko</code>, joka perii luokan <code>Laatikko</code>. Maksimipainollisella laatikolla on konstruktori <code>public MaksimipainollinenLaatikko(int maksimipaino)</code>, joka mÃ¤Ã¤rittelee laatikon maksimipainon. Maksimipainolliseen laatikkoon voi lisÃ¤tÃ¤ tavaraa jos ja vain jos tavaran lisÃ¤Ã¤minen ei ylitÃ¤ laatikon maksimipainoa.</p>

<pre class="sh_java">
        MaksimipainollinenLaatikko kahviLaatikko = new MaksimipainollinenLaatikko(10);
        kahviLaatikko.lisaa(new Tavara("Saludo", 5));
        kahviLaatikko.lisaa(new Tavara("Pirkka", 5));
        kahviLaatikko.lisaa(new Tavara("Kopi Luwak", 5));

        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Pirkka")));
        System.out.println(kahviLaatikko.onkoLaatikossa(new Tavara("Kopi Luwak")));
</pre>

<pre>
true
true
false
</pre>

<h4>Yhden tavaran laatikko ja Hukkaava laatikko</h4>

        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>YhdenTavaranLaatikko</code>, joka perii luokan <code>Laatikko</code>. Yhden tavaran laatikolla on konstruktori <code>public YhdenTavaranLaatikko()</code>, ja siihen mahtuu tasan yksi tavara. Jos tavara on jo laatikossa sitÃ¤ ei tule vaihtaa. Laatikkoon lisÃ¤ttÃ¤vÃ¤n tavaran painolla ei ole vÃ¤liÃ¤.</p>

<pre class="sh_java">
        YhdenTavaranLaatikko laatikko = new YhdenTavaranLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
true
false
</pre>


        <p>Toteuta seuraavaksi pakkaukseen <code>laatikot</code> luokka <code>HukkaavaLaatikko</code>, joka perii luokan <code>Laatikko</code>. Hukkaavalla laatikolla on konstruktori <code>public HukkaavaLaatikko()</code>. Hukkaavaan laatikkoon voi lisÃ¤tÃ¤ kaikki tavarat, mutta tavaroita ei lÃ¶ydy niitÃ¤ etsittÃ¤essÃ¤. Laatikkoon lisÃ¤Ã¤misen tulee siis aina onnistua, mutta metodin <code>onkoLaatikossa</code> kutsumisen tulee aina palauttaa false.</p>

<pre class="sh_java">
        HukkaavaLaatikko laatikko = new HukkaavaLaatikko();
        laatikko.lisaa(new Tavara("Saludo", 5));
        laatikko.lisaa(new Tavara("Pirkka", 5));

        System.out.println(laatikko.onkoLaatikossa(new Tavara("Saludo")));
        System.out.println(laatikko.onkoLaatikossa(new Tavara("Pirkka")));
</pre>

<pre>
false
false
</pre>


</div>

<h3>Huomio olioiden poistamisesta ArrayListista</h3>

<p>Seuraavassa tehtÃ¤vÃ¤ssÃ¤ saatat joutua tilanteeseen, jossa haluat poistaa ArrayListiÃ¤ lÃ¤pikÃ¤ydessÃ¤si osan listan olioista:</p>

<pre class="sh_java">
   // joissain mÃ¤Ã¤ritelty seuraavasti:
   // ArrayList&ltOlio&gt lista = new ... 

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         lista.remove(olio);
      }
   }
</pre>

<p>Ratkaisu ei toimi ja aiheuttaa poikkeuksen <code>ConcurrentModificationException</code>, sillÃ¤ listaa <em>foreach</em>-tyylillÃ¤ lÃ¤pikÃ¤ydessÃ¤ listaa ei saa muokata. Palaamme aiheeseen hieman tarkemmin viikolla 6. Jos tÃ¶rmÃ¤Ã¤t tilanteeseen, voit hoitaa sen esim. seuraavasti:</p>

<pre class="sh_java">
   // joissain mÃ¤Ã¤ritelty seuraavasti:
   // ArrayList&ltOlio&gt lista = new ... 

   ArrayList&ltOlio&gt poistettavat = new ArrayList&ltOlio&gt();

   for ( Olio olio : lista ) {
      if ( tarvitseePoistaa(olio) ) {
         poistattavat.add(olio);
      }
   }

   lista.removeAll(poistettavat);
</pre>

<p>Eli poistettavat oliot kerÃ¤tÃ¤Ã¤n listan lÃ¤pikÃ¤yntinÃ¤ erilliselle listalle ja poisto-operaatio suoritetaan vasta listan lÃ¤pikÃ¤ynnin jÃ¤lkeen.</p>

<div class="tehtavat">

<h3>Luola</h3>


  <p><em>TÃ¤mÃ¤ tehtÃ¤vÃ¤ on neljÃ¤n tehtÃ¤vÃ¤pisteen arvoinen.</em> Huom! Toteuta kaikki toiminnallisuus pakkaukseen <code>luola</code>.</p>

<p><b>Huom: jotta testit toimisivat, ohjelmasi saa luoda vain yhden Scanner-olion. ÃlÃ¤ kÃ¤ytÃ¤ luokkien nimissÃ¤ skandeja. ÃlÃ¤ myÃ¶skÃ¤Ã¤n kÃ¤ytÃ¤ staattisia muuttujia, testit suorittavat ohjelman useita kertoja joten staattisiin muuttujiin edellisillÃ¤ suorituskerroilla jÃ¤Ã¤neet arvot todennÃ¤kÃ¶isesti hÃ¤iritsevÃ¤t testien toimintaa!</b></p>


<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ pÃ¤Ã¤set toteuttamaan luolapelin. PelissÃ¤ pelaaja on luolassa hirviÃ¶itten kanssa. Pelaajan tehtÃ¤vÃ¤nÃ¤ on ehtiÃ¤ tallata kaikki hirviÃ¶t ennen kuin hÃ¤nen lampustaan loppuu virta ja hirviÃ¶t pÃ¤Ã¤sevÃ¤t pimeÃ¤n turvin syÃ¶mÃ¤Ã¤n hÃ¤net. Pelaaja voi nÃ¤hdÃ¤ hirviÃ¶iden sijainnit vÃ¤lkÃ¤yttÃ¤mÃ¤llÃ¤ lamppua, jonka jÃ¤lkeen hÃ¤nen on liikuttava sokkona ennen seuraavaa vÃ¤lkÃ¤ytystÃ¤. Pelaaja voi kulkea monta askelta yhden siirron aikana.</p>

<p>Pelitilanne eli luola, pelaaja ja hirviÃ¶t esitetÃ¤Ã¤n pelaajalle tekstimuotoisesti. Tulostuksen ensimmÃ¤inen rivi kertoo jÃ¤ljellÃ¤ olevien siirtojen (eli lampun jÃ¤ljellÃ¤ olevan virran) mÃ¤Ã¤rÃ¤n. Virran mÃ¤Ã¤rÃ¤Ã¤ seuraa pelaajan ja hirviÃ¶itten sijainnit, joiden jÃ¤lkeen on pelitilanteesta piirretty kartta. Alla olevassa esimerkissÃ¤ nÃ¤et pelaajan (<code>@</code>) ja kolme hirviÃ¶tÃ¤ (<code>h</code>).  Alla olevassa esimerkissÃ¤ pelaajalla on virtaa neljÃ¤Ã¤ntoista siirtoon.</p>

<pre>
14

@ 1 2
h 6 1
h 7 3
h 12 2

.................
......h..........
.@.........h.....
.......h.........
</pre>

<p>YllÃ¤ olevassa esimerkissÃ¤ virtaa on 14 vÃ¤lkÃ¤ytykseen. Pelaaja <code>@</code> sijatsee koordinaatissa <code>1 2</code>. Huomaa ettÃ¤ koordinaatit lasketaan aina pelialueen vasemmasta ylÃ¤laidasta lÃ¤htien. Alla olevassa kartassa merkki <code>X</code> on koordinaatissa <code>0 0</code>, <code>Y</code> koordinaatissa <code>2 0</code> ja <code>Z</code> koordinaatissa <code>0 2</code>.</p>

<pre>
X.Y..............
.................
Z................
.................
</pre>



<p>KÃ¤yttÃ¤jÃ¤ voi liikkua antamalla sarjan komentoja ja painamalla rivinvaihtoa. Komennot ovat:</p>
<ul>
  <li><code>w</code> liiku ylÃ¶spÃ¤in</li>
  <li><code>s</code> liiku alaspÃ¤in</li>
  <li><code>a</code> liiku vasemmalle</li>
  <li><code>d</code> liiku oikealle</li>
</ul>

<p>Kun kÃ¤yttÃ¤jÃ¤n antamat komennot on suoritettu (niitÃ¤ voi olla useampi), piirretÃ¤Ã¤n uusi pelitilanne. Lampun virta vÃ¤henee yhdellÃ¤ aina kun uusi pelitilanne piirretÃ¤Ã¤n. Jos virta menee nollaan, peli loppuu ja ruudulle tulostetaan teksti <code>HÃVISIT</code></p>

<p>HirviÃ¶t liikkuvat pelissÃ¤ satunnaisesti, yhden askeleen jokaista pelaajan askelta kohti. Jos pelaaja ja hirviÃ¶ osuvat samaan ruutuun (vaikka vain tilapÃ¤isesti), hirviÃ¶ tuhoutuu. Jos hirviÃ¶ yrittÃ¤Ã¤ siirtyÃ¤ pelilaudalta ulos tai ruutuun jossa on jo hirviÃ¶, jÃ¤tetÃ¤Ã¤n siirto suorittamatta. Kun kaikki hirviÃ¶t on tuhottu, peli loppuu ja tulostetaan <code>VOITIT</code>.</p>

<p>Testaamisen helpottamiseksi tee peliisi luokka <code>Luola</code>, jolla on  :</p>

<p>
  <ul>
    <li>konstruktori <strong><code>public Luola(int leveys, int korkeus, int hirvioita, int siirtoja, boolean hirviotLiikkuvat)</code></strong>
      <p>values <code>leveys</code> ja <code>korkeus</code> antavat luolan koon (se on aina neliskulmainen), <code>hirvioita</code> antaa hirviÃ¶iden lukumÃ¤Ã¤rÃ¤n alussa (hirviÃ¶iden sijainnin voi arpoa), <code>siirtoja</code> antaa siirtojen lukumÃ¤Ã¤rÃ¤n alussa ja jos <code>hirviotLiikkuvat</code> on <code>false</code>, hirviÃ¶t eivÃ¤t liiku.</p></li>
    <li>metodi <strong><code>public void run()</code></strong> joka kÃ¤ynnistÃ¤Ã¤ pelin</li>
  </ul>
</p>

<p><em>Huom!</em> pelaajan tulee aloittaa sijainnista 0,0!</p>
<p><em>Huom!</em> jos pelaaja tai hirviÃ¶ koittaa liikkua ulos luolasta
  tai kaksi hirviÃ¶tÃ¤ koittaa liikkua samaan ruutuun, ei liikettÃ¤ tule
  tapahtua!</p>
</ul>

  <p>Alla vielÃ¤ selkeyden vuoksi vielÃ¤ esimerkkipeli:</p>

<pre>
14

@ 0 0
h 1 2
h 7 8
h 7 5
h 8 0
h 2 9

@.......h.
..........
.h........
..........
..........
.......h..
..........
..........
.......h..
..h.......

<font color="red">ssd</font>
13

@ 1 2
h 8 8
h 7 4
h 8 3
h 1 8

..........
..........
.@........
........h.
.......h..
..........
..........
..........
.h......h.
..........

<font color="red">ssss</font>
12

@ 1 6
h 6 9
h 6 5
h 8 3

..........
..........
..........
........h.
..........
......h...
.@........
..........
..........
......h...

<font color="red">dd</font>
11

@ 3 6
h 5 9
h 6 7
h 8 1

..........
........h.
..........
..........
..........
..........
...@......
......h...
..........
.....h....

<font color="red">ddds</font>
10

@ 6 7
h 6 6
h 5 0

.....h....
..........
..........
..........
..........
..........
......h...
......@...
..........
..........

<font color="red">w</font>
9

@ 6 6
h 4 0

....h.....
..........
..........
..........
..........
..........
......@...
..........
..........
..........

<font color="red">www</font>
8

@ 6 3
h 4 0

....h.....
..........
..........
......@...
..........
..........
..........
..........
..........
..........

<font color="red">aa</font>
7

@ 4 3
h 4 2

..........
..........
....h.....
....@.....
..........
..........
..........
..........
..........
..........

<font color="red">w</font>
VOITIT
</pre>


</div>

<!-- BEGIN SNIP -->

<div class="tyhja"></div>

<div class="viikkoraja">Viikko 5</div>

<h2 id="tiedostostoon_kirjoitus">Tiedostoon kirjoittaminen</h3>

<p>Luvussa 15 opimme, ettÃ¤ tekstitiedostojen lukeminen onnistuu <code>Scanner</code>- ja <code>File</code>-luokkien avulla.
Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/java/io/FileWriter.html">FileWriter</a></code> tarjoaa toiminnallisuuden tiedostoon kirjoittamiseen. Luokan <code>FileWriter</code> konstruktorille annetaan parametrina kohdetiedoston sijaintia kuvaava characterString.</p>

<pre class="sh_java">
        FileWriter kirjoittaja = new FileWriter("tiedosto.txt");
        kirjoittaja.write("Hei tiedosto!\n"); // rivinvaihto tulee myÃ¶s kirjoittaa tiedostoon!
        kirjoittaja.write("LisÃ¤Ã¤ tekstiÃ¤\n");
        kirjoittaja.write("Ja vielÃ¤ lisÃ¤Ã¤");
        kirjoittaja.close(); // sulkemiskutsu sulkee tiedoston ja varmistaa ettÃ¤ kirjoitettu teksti menee tiedostoon
</pre>

    <p>EsimerkissÃ¤ kirjoitetaan tiedostoon "tiedosto.txt" characterString "Hei tiedosto!", jota seuraa rivinvaihto, ja vielÃ¤ hieman lisÃ¤Ã¤ tekstiÃ¤. Huomaa ettÃ¤ tiedostoon kirjoitettaessa metodi <code>write</code> ei lisÃ¤Ã¤ rivinvaihtoja, vaan ne tulee lisÃ¤tÃ¤ itse.</p>

    <p>SekÃ¤ <code>FileWriter</code>-luokan konstruktori ettÃ¤ <code>write</code>-metodi heittÃ¤Ã¤ mahdollisesti poikkeuksen, joka tulee joko kÃ¤sitellÃ¤ tai siirtÃ¤Ã¤ kutsuvan metodin vastuulle. Metodi, jolle annetaan parametrina kirjoitettavan tiedoston nimi ja kirjoitettava sisÃ¤ltÃ¶ voisi nÃ¤yttÃ¤Ã¤ seuraavalta.</p>

<pre class="sh_java">
public class Tallentaja {

    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }
}
</pre>

    <p>YllÃ¤ olevassa <code>kirjoitaTiedostoon</code>-metodissa luodaan ensin <code>FileWriter</code>-olio, joka kirjoittaa parametrina annetussa sijainnissa sijaitsevaan tiedostoon <code>tiedostonNimi</code>. TÃ¤mÃ¤n jÃ¤lkeen kirjoitetaan tiedostoon <code>write</code>-metodilla. Konstruktorin ja <code>write</code>-metodin mahdollisesti heittÃ¤mÃ¤ poikkeus tulee kÃ¤sitellÃ¤ joko <code>try-catch</code>-lohkolla tai siirtÃ¤mÃ¤llÃ¤ poikkeuksen kÃ¤sittely vastuuta eteenpÃ¤in. Metodissa <code>kirjoitaTiedostoon</code> kÃ¤sittelyvastuu on siirretty eteenpÃ¤in.</p>

    <p>Luodaan <code>main</code>-metodi jossa kutsutaan <code>Tallentaja</code>-olion <code>kirjoitaTiedostoon</code>-metodia. Poikkeusta ei ole pakko kÃ¤sitellÃ¤ <code>main</code>-metodissakaan, vaan se voi ilmoittaa heittÃ¤vÃ¤nsÃ¤ mahdollisesti poikkeuksen mÃ¤Ã¤rittelyllÃ¤ <code>throws Exception</code>.</p>

<pre class="sh_java">
    public static void main(String[] args) throws Exception {
        Tallentaja tallentaja = new Tallentaja();
        tallentaja.kirjoitaTiedostoon("paivakirja.txt", "Rakas pÃ¤ivÃ¤kirja, tÃ¤nÃ¤Ã¤n oli kiva pÃ¤ivÃ¤.");
    }
</pre>

    <p>YllÃ¤ olevaa metodia kutsuttaessa luodaan tiedosto "paivakirja.txt" johon kirjoitetaan teksti "Rakas pÃ¤ivÃ¤kirja, tÃ¤nÃ¤Ã¤n oli kiva pÃ¤ivÃ¤.". Jos tiedosto on jo olemassa, pyyhkiytyy vanhan tiedoston sisÃ¤ltÃ¶ uutta kirjoittaessa. Metodilla <code>append()</code> voidaan lisÃ¤tÃ¤ olemassaolevan tiedoston perÃ¤Ã¤n tekstiÃ¤, jolloin olemassaolevaa  tekstiÃ¤ ei poisteta. LisÃ¤tÃ¤Ã¤n <code>Tallentaja</code>-luokalle metodi <code>lisaaTiedostoon()</code>, joka lisÃ¤Ã¤ parametrina annetun tekstin tiedoston loppuun.</p>

<pre class="sh_java">
public class Tallentaja {
    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.write(teksti);
        kirjoittaja.close();
    }

    public void lisaaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        FileWriter kirjoittaja = new FileWriter(tiedostonNimi);
        kirjoittaja.append(teksti);
        kirjoittaja.close();
    }
}
</pre>

    <p>Useimmiten tiedoston perÃ¤Ã¤n metodilla <code>append</code> kirjoittamisen sijasta on helpompi kirjoittaa koko tiedosto uudelleen.</p>

<div class="tehtavat">

<NEXTWEEK></NEXTWEEK>
<h3>TiedostonkÃ¤sittelijÃ¤</h3>

<p>Saat tehtÃ¤vÃ¤rungon mukana luokan <code>Tiedostonkasittelija</code> joka sisÃ¤ltÃ¤Ã¤ metodirungot tiedoston lukemista ja tiedostoon kirjoittamista varten.</p>

<h4>Tiedoston lukeminen</h4>

<p>TÃ¤ydennÃ¤ metodi <code>public ArrayList&lt;String&gt; lue(String tiedosto)</code> sellaiseksi, ettÃ¤ se palauttaa parametrina annetun tekstitiedoston sisÃ¤ltÃ¤mÃ¤t rivit ArrayList:ina siten, ettÃ¤ tiedoston jokainen rivi on omana characterStringnaan listalla.
</p>

<p>Projektissa on testaamista varten kaksi tekstitiedostoa <code>src/koesyote1.txt</code> ja <code>src/koesyote2.txt</code>. Metodia on tarjoitus kÃ¤yttÃ¤Ã¤ seuraavalla tavalla: 
</p>

<pre class="sh_java">
    public static void main(String[] args) throws FileNotFoundException, IOException {
        TiedostonKasittelija t = new TiedostonKasittelija();

        for (String rivi : t.lue("src/koesyote1.txt")) {
            System.out.println(rivi);
        }
    }
</pre>

<p>Tulostuksen pitÃ¤isi olla</p>

<pre>
eka
toka
</pre>


<h4>Rivin kirjoittaminen tiedostoon</h4>

<p>TÃ¤ydennÃ¤ projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, String teksti)</code>  sellaiseksi, ettÃ¤ se tallentaa ensimmÃ¤isen parametrin mÃ¤Ã¤rittelemÃ¤Ã¤n tiedostoon toisena parametrina annetun characterStringn. Jos tiedosto on jo olemassa, kirjoitetaan vanhan version pÃ¤Ã¤lle.
</p>


<h4>Rivin kirjoittaminen tiedostoo</h4>

<p>TÃ¤ydennÃ¤ projektipohjan mukana tuleva metodi <code>public void tallenna(String tiedosto, ArrayList<String> tekstit)</code> sellaiseksi, ettÃ¤ se tallentaa ensimmÃ¤isen parametrin mÃ¤Ã¤rittelemÃ¤Ã¤n tiedostoon toisena parametrina annetun listan siten, ettÃ¤ jokainen characterString tulee omalle rivilleen.  Jos tiedosto on jo olemassa, kirjoitetaan vanhan version pÃ¤Ã¤lle.
</p>

    <h3>Muistava kahteen suuntaan kÃ¤Ã¤ntÃ¤vÃ¤ sanakirja</h3>

    <p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ laajennetaan aiemmin toteutettua sanakirjaa siten, ettÃ¤ sanat voidaan lukea tiedostosta ja kirjoittaa tiedostoon. Sanakirjan tulee myÃ¶s osata kÃ¤Ã¤ntÃ¤Ã¤ molempiin suuntiin, suomesta vieraaseen kieleen sekÃ¤ toiseen suuntaan (tehtÃ¤vÃ¤ssÃ¤ oletetaan hieman epÃ¤realistisesti, ettÃ¤ suomen kielessÃ¤ ja vieraassa kielessÃ¤ ei ole yhtÃ¤Ã¤n samalla tavalla kirjoitettavaa sanaa). TehtÃ¤vÃ¤nÃ¤si on luoda sanakirja luokkaan <code>MuistavaSanakirja</code> Toteuta luokka pakkaukseen <code>sanakirja</code>.</p>

<h4>Muistiton perustoiminnallisuus</h4>

<p>Tee sanakirjalle parametriton konstruktori sekÃ¤ metodit:</p>

 <ul>
        <li><code>public void lisaa(String sana, String kaannos)</code></li>lisÃ¤Ã¤ sanan sanakirjaan. Jokaisella sanalla on vain yksi kÃ¤Ã¤nnÃ¶s, jos sama sana lisÃ¤tÃ¤Ã¤n uudelleen, ei tapahdu mitÃ¤Ã¤n.<br/>
        <li><code>public String kaanna(String sana)</code></li> palauttaa kÃ¤Ã¤nnÃ¶ksen annetulle sanalle, jos sanaa ei tunneta, palautetaan null<br/>
 </ul>

<p>Sanakirjan tulee tÃ¤ssÃ¤ vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("apina", "apfe");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("banana") );
</pre>

<p>Tulostuu</p>

<pre>
monkey
apina
null
banana
</pre>

<p>Kuten tulostuksesta ilmenee, kÃ¤Ã¤nnÃ¶ksen lisÃ¤Ã¤misen jÃ¤lkeen sanakirja osaa tehdÃ¤ kÃ¤Ã¤nnÃ¶ksen molempiin suuntiin.</p>

<h4>Sanojen poistaminen</h4>

<p>LisÃ¤Ã¤ sanakirjalle metodi <code>public void poista(String sana)</code></li> joka poistaa annetun sanan ja sen kÃ¤Ã¤nnÃ¶ksen sanakirjasta.</p>

<p>Sanakirjan tulee tÃ¤ssÃ¤ vaiheessa toimia seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja();
sanakirja.lisaa("apina", "monkey");
sanakirja.lisaa("banaani", "banana");
sanakirja.lisaa("ohjelmointi", "programming");
sanakirja.poista("apina");
sanakirja.poista("banana");

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("monkey") );
System.out.println( sanakirja.kaanna("banana") );
System.out.println( sanakirja.kaanna("banaani") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
</pre>

<p>Tulostuu</p>

<pre>
null
null
null
null
programming
</pre>

<p>Poisto siis toimii myÃ¶s molemmin puolin, alkuperÃ¤isen sanan tai sen kÃ¤Ã¤nnÃ¶ksen poistamalla, poistuu sanakirjasta tieto molempien suuntien kÃ¤Ã¤nnÃ¶ksestÃ¤. </p>



<h4>Lataaminen tiedostosta</h4>

<p>Tee sanakirjalle konstruktori <code>public Sanakirja(String tiedosto)</code>  ja metodi <code>public boolean lataa()</code>, joka lataa sanakirjan konstruktorin parametrina annetun nimisestÃ¤ tiedostosta. Jos tiedoston avaaminen tai lukeminen ei onnistu, palauttaa metodi false ja muuten true.</p>

<p>Sanakirjatiedostossa yksi rivi sisÃ¤ltÃ¤Ã¤ sanan ja sen kÃ¤Ã¤nnÃ¶ksen merkillÃ¤ ":" erotettuna. TehtÃ¤vÃ¤pohjan mukana tuleva testaamiseen tarkoitettu sanakirjatiedosto <code>src/sanat.txt</code> on sisÃ¤llÃ¶ltÃ¤Ã¤n seuraava: </p>

<pre>
apina:monkey
alla oleva:below
olut:beer
</pre>

<p>Lue sanakirjatiedosto rivi riviltÃ¤ lukijan metodilla <code>nextLine</code>. Voit pilkkoa rivin String metodilla <code>split</code> seuraavasti:

<pre class="sh_java">
Scanner tiedostonLukija = new ...
while ( tiedostonreader.hasNextLine() ){
    String rivi = tiedostonreader.nextLine();
    String[] osat = rivi.split(":");   // pilkotaan rivi :-merkkien kohdalta
    
    System.out.println( osat[0] );     // ennen :-merkkiÃ¤ ollut osa rivistÃ¤
    System.out.println( osat[1] );     // :-merkin jÃ¤lkeen ollut osa rivistÃ¤
}
</pre>

<p>Sanakirjaa kÃ¤ytetÃ¤Ã¤n seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
sanakirja.lataa();

System.out.println( sanakirja.kaanna("apina") );
System.out.println( sanakirja.kaanna("ohjelmointi") );
System.out.println( sanakirja.kaanna("alla oleva") );
</pre>

<p>Tulostuu</p>

<pre>
monkey
null
below
</pre>


<h4>Tallennus tiedostoon</h4>

    <p>Tee sanakirjalle metodi <code>public boolean talleta()</code>, jota kutsuttaessa sanakirjan sisÃ¤ltÃ¶ kirjoitetaan konstruktorin parametrina annetun nimiseen tiedostoon. Jos tallennus ei onnistu, palauttaa metodi false ja muuten true. Sanakirjatiedostot tulee tallentaa yllÃ¤esitellyssÃ¤ muodossa, eli ohjelman on osattava lukea itse kirjottamiaan tiedostoja.</p>

<p><strong>Huom:</strong> vaikka sanakirja osaa kÃ¤Ã¤nnÃ¶kset molempiin suuntiin, ei sanakirjatiedostoon tule kirjoittaa kuin toinen suunta. Eli jos sanakirja tietÃ¤Ã¤ esim. kÃ¤Ã¤nnÃ¶ksen <em>tietokone = computer</em>, tulee rivi:</p>

<pre>
tietokone:computer
</pre>

<p>tai rivi</p>

<pre>
computer:tietokone
</pre>

<p>mutta ei molempia!</p>

    <p>Talletus kannattanee hoitaa siten, ettÃ¤ koko kÃ¤Ã¤nnÃ¶slista kirjoitetaan uudelleen vanhan tiedoston pÃ¤Ã¤lle, eli materiaalissa esiteltyÃ¤ <code>append</code>-komentoa ei kannata kÃ¤yttÃ¤Ã¤.</p>

<p>Sanakirjan lopullista versiota on tarkoitus kÃ¤yttÃ¤Ã¤  seuraavasti:</p>

<pre class="sh_java">
MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
sanakirja.lataa();

// kÃ¤ytÃ¤ sanakirjaa

sanakirja.tallenna();
</pre>

<p>Eli kÃ¤ytÃ¶n aluksi ladataan sanakirja tiedostosta ja lopussa tallennetaan se takaisin tiedostoon jotta sanakirjaan tehdyt muutokset pysyvÃ¤t voimassa seuraavallekin kÃ¤ynnistyskerralle.</p>
</div>



<h2 id="kalit">KÃ¤yttÃ¶liittymÃ¤t</h2>

<p><hr/></p>
<p><big><strong><strong>Huom!</strong> Osa kÃ¤yttÃ¶liittymÃ¤tehtÃ¤vien testeistÃ¤ avaa kÃ¤yttÃ¶liittymÃ¤n ja kÃ¤yttÃ¤Ã¤ hiirtÃ¤si kÃ¤yttÃ¶liittymÃ¤komponenttien klikkailuun. Kun suoritat kÃ¤yttÃ¶liittymÃ¤tehtÃ¤vien testejÃ¤, Ã¤lÃ¤ kÃ¤ytÃ¤ hiirtÃ¤si!</strong></big></p>
<p><hr/></p>

<p>Ohjelmamme ovat tÃ¤hÃ¤n mennessÃ¤ koostuneet lÃ¤hinnÃ¤ sovelluslogiikasta ja sovelluslogiikkaa kÃ¤yttÃ¤vÃ¤stÃ¤ tekstikÃ¤yttÃ¶liittymÃ¤stÃ¤. Muutamissa tehtÃ¤vissÃ¤ on ollut myÃ¶s graafinen kÃ¤yttÃ¶liittymÃ¤, mutta ne on yleensÃ¤ luotu puolestamme. Tutustutaan seuraavaksi graafisten kÃ¤yttÃ¶liittymien luomiseen Javalla.</p>

<p>KÃ¤yttÃ¶liittymÃ¤t ovat ikkunoita, jotka sisÃ¤ltÃ¤vÃ¤t erilaisia osia kuten nappeja, tekstikenttiÃ¤ ja valikkoja. KÃ¤yttÃ¶liittymien ohjelmoinnissa kÃ¤ytetÃ¤Ã¤n Javan <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">Swing</a>-komponenttikirjastoa, joka tarjoaa luokkia kÃ¤yttÃ¶liittymÃ¤komponenttien luomiseen ja kÃ¤sittelyyn.</p>

<p>KÃ¤yttÃ¶liittymien peruselementti on luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFrame.html" target="_blank">JFrame</a></code>, jonka sisÃ¤ltÃ¤mÃ¤Ã¤n komponenttiosioon kÃ¤yttÃ¶liittymÃ¤komponentit luodaan. Oikeaoppisesti luodut kÃ¤yttÃ¶liittymÃ¤t toteuttavat rajapinnan <code>Runnable</code>, ja ne kÃ¤ynnistetÃ¤Ã¤n pÃ¤Ã¤ohjelmasta. KÃ¤ytÃ¤mme kurssilla seuraavanlaista kÃ¤yttÃ¶liittymÃ¤runkoa:</p>

<pre class="sh_java">
import java.awt.Container;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.WindowConstants;

public class Kayttoliittyma implements Runnable {

    private JFrame frame;

    public Kayttoliittyma() {
    }

    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }

    private void luoKomponentit(Container container) {
    }

    public JFrame getFrame() {
        return frame;
    }
}
</pre>

<p>Tarkastellaan yllÃ¤olevan kÃ¤yttÃ¶liittymÃ¤luokan koodia hieman tarkemmin.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {
</pre>

<p>Luokka <code>Kayttoliittyma</code> toteuttaa Javan rajapinnan <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Runnable.html" target="_blank">Runnable</a>, joka tarjoaa mahdollisuuden sÃ¤ikeistettyyn ohjelman suorittamiseen. SÃ¤ikeistetyllÃ¤ suorittamisella voidaan suorittaa useita ohjelman osia rinnakkain. Emme tutustu sÃ¤ikeisiin tarkemmin, lisÃ¤Ã¤ tietoa sÃ¤ikeistÃ¤ tulee muunmuassa toisen vuoden kurssilla <em>KÃ¤yttÃ¶jÃ¤rjestelmÃ¤t</em>.</p>

<pre class="sh_java">
    private JFrame frame;
</pre>

<p>KÃ¤yttÃ¶liittymÃ¤ sisÃ¤ltÃ¤Ã¤ oliomuuttujana <code>JFrame</code>-olion, joka on nÃ¤kyvÃ¤n kÃ¤yttÃ¶liittymÃ¤n pohjaelementti. Kaikki kÃ¤yttÃ¶liittymÃ¤komponentit lisÃ¤tÃ¤Ã¤n <code>JFrame</code>-olion sisÃ¤ltÃ¤mÃ¤Ã¤n komponenttialueeseen. Huomaa ettÃ¤ <strong>oliomuuttujia ei saa alustaa metodien ulkopuolella</strong>. Esimerkiksi oliomuuttujan <code>JFrame</code> alustus luokkamÃ¤Ã¤rittelyssÃ¤ <code>"private JFrame frame = new JFrame()"</code> kiertÃ¤Ã¤ kÃ¤yttÃ¶liittymÃ¤sÃ¤ikeiden suoritusjÃ¤rjestyksen, ja voi johtaa ydintuhoon. Tai ohjelmasi kaatumiseen.</p>

<pre class="sh_java">
    @Override
    public void run() {
        frame = new JFrame("Otsikko");
        frame.setPreferredSize(new Dimension(200, 100));

        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        luoKomponentit(frame.getContentPane());

        frame.pack();
        frame.setVisible(true);
    }
</pre>

<p>Rajapinta <code>Runnable</code> mÃ¤Ã¤rittelee metodin <code>public void run()</code>, joka jokaisen <code>Runnable</code>-rajapinnan toteuttajan tulee toteuttaa. Metodissa <code>public void run()</code> luodaan ensin uusi JFrame-ikkuna, jonka otsikoksi asetetaan <code>"Otsikko"</code>. TÃ¤mÃ¤n jÃ¤lkeen asetetaan ikkunan toivotuksi kooksi 200, 100 eli ikkunan leveydeksi tulee 200 pikseliÃ¤, korkeudeksi 100 pikseliÃ¤. Komento <code>frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</code> kertoo JFrame-oliolle, ettÃ¤ kÃ¤yttÃ¶liittymÃ¤ tulee sulkea kun kÃ¤yttÃ¤jÃ¤ painaa kÃ¤yttÃ¶liittymÃ¤ssÃ¤ olevaa ruksia.</p>

<p>TÃ¤mÃ¤n jÃ¤lkeen kutsutaan luokassa myÃ¶hemmin mÃ¤Ã¤riteltyÃ¤ metodia <code>luoKomponentit</code>. Metodille annetaan parametrina <code>JFrame</code>-olion <em><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Container.html" target="_blank">Container</a></em>-olio, johon voi lisÃ¤tÃ¤ kÃ¤yttÃ¶liittymÃ¤komponentteja.</em>

<p>Lopuksi kutsutaan metodia <code>frame.pack()</code>, joka asettaa JFrame-olion aiemmin mÃ¤Ã¤ritellyn kokoiseksi ja jÃ¤rjestÃ¤Ã¤ JFrame-olion sisÃ¤ltÃ¤mÃ¤n Container-olion sisÃ¤llÃ¤ olevat kÃ¤yttÃ¶liittymÃ¤komponentit. Lopuksi kutsutaan metodia <code>frame.setVisible(true)</code>, joka nÃ¤yttÃ¤Ã¤ kÃ¤yttÃ¶liittymÃ¤n kÃ¤yttÃ¤jÃ¤lle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
    }
</pre>

<p>Metodissa <code>luoKomponentit</code> lisÃ¤tÃ¤Ã¤n <code>JFrame</code>-olion sisÃ¤ltÃ¤mÃ¤Ã¤n komponenttialueeseen kÃ¤yttÃ¶liittymÃ¤komponentteja. EsimerkissÃ¤mme ei ole yhtÃ¤kÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤komponenttia JFrame-ikkunan lisÃ¤ksi. Luokalla <code>Kayttoliittyma</code> on myÃ¶s sen kÃ¤yttÃ¶Ã¤ helpottava metodi <code>getFrame</code>, jolla pÃ¤Ã¤stÃ¤Ã¤n kÃ¤siksi luokan kapseloimaan JFrame-olioon.</em>

<p>Swing-kÃ¤yttÃ¶liittymÃ¤t kÃ¤ynnistetÃ¤Ã¤n <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/SwingUtilities.html" target="_blank">SwingUtilities</a></code>-luokan tarjoaman <code>invokeLater</code>-metodin avulla. Metodi <code>invokeLater</code> saa parametrinaan <code>Runnable</code>-rajapinnan toteuttavan olion. Metodi asettaa <code>Runnable</code>-olion suoritusjonoon, ja kutsuu sitÃ¤ kun ehtii. Luokan <code>SwingUtilities</code> avulla voimme kÃ¤ynnistÃ¤Ã¤ uusia sÃ¤ikeitÃ¤ tarvittaessa.</p>

<pre class="sh_java">
import javax.swing.SwingUtilities;

public class Main {

    public static void main(String[] args) {
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma();
        SwingUtilities.invokeLater(kayttoliittyma);
    }
}
</pre>


<p>Kun yllÃ¤oleva pÃ¤Ã¤ohjelmametodi suoritetaan, nÃ¤emme luokassa <code>Kayttoliittyma</code> mÃ¤Ã¤rittellyn kÃ¤yttÃ¶liittymÃ¤n.</p>

    <p><img src="img-ohja/kali/eka-kali.png"/></p>


<h3>KÃ¤yttÃ¶liittymÃ¤komponentit</h3>


<p>KÃ¤yttÃ¶liittymÃ¤ koostuu taustaikkunan (JFrame) sisÃ¤ltÃ¤mÃ¤stÃ¤ komponenttipohjasta (Container), ja siihen asetetuista kÃ¤yttÃ¶liittymÃ¤komponenteista. KÃ¤yttÃ¶liittymÃ¤komponentteja ovat erilaiset painikkeet, tekstit ym. Jokaiselle komponentille on oma luokka. Kannattaa tutustua Oraclen visuaalinen kuvasarjaan erilaisista komponenteista osoitteessa <a href="http://docs.oracle.com/javase/tutorial/ui/features/components.html" target="_blank">http://docs.oracle.com/javase/tutorial/ui/features/components.html</a>.</p>

<h4>Teksti</h4>

<p>Tekstin nÃ¤yttÃ¤minen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JLabel.html" target="_blank">JLabel</a></code>-luokan avulla. Luokka <code>JLabel</code> tarjoaa kÃ¤yttÃ¶liittymÃ¤komponentin, jolle voi asettaa tekstiÃ¤ ja jonka sisÃ¤ltÃ¤mÃ¤Ã¤ tekstiÃ¤ voi muokata. Teksti asetetaan joko konstruktorissa tai erillisellÃ¤ <code>setText</code>-metodilla.</p>

<p>Muokataan kÃ¤yttÃ¶liittymÃ¤pohjaamme siten, ettÃ¤ siinÃ¤ nÃ¤kyy tekstiÃ¤. Luodaan uusi JLabel-tekstikomponentti metodissa <code>luoKomponentit</code>. TÃ¤mÃ¤n jÃ¤lkeen lisÃ¤tÃ¤Ã¤n se <code>JFrame</code>-oliolta saatuun <code>Container</code>-olioon <code>Container</code>-olion <code>add</code>-metodia kÃ¤yttÃ¤en.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JLabel teksti = new JLabel("TekstikenttÃ¤!");
        container.add(teksti);
    }
</pre>

<p>Kuten yllÃ¤ olevasta lÃ¤hdekoodista nÃ¤emme, JLabel-kÃ¤yttÃ¶liittymÃ¤komponentti tulee nÃ¤yttÃ¤mÃ¤Ã¤n tekstin <code>"TekstikenttÃ¤!"</code>. Kun suoritamme kÃ¤yttÃ¶liittymÃ¤n, nÃ¤emme seuraavanlaisen ikkunan.</p>

    <p><img src="img-ohja/kali/kali-tekstikentta.png"/></p>


<div class="tehtavat">

<h3>TervehtijÃ¤</h3>

<p>Toteuta kÃ¤yttÃ¶liittymÃ¤, joka nÃ¤yttÃ¤Ã¤ tekstin "Moi!". KÃ¤yttÃ¶liittymÃ¤n (eli JFrame-olion) leveyden tulee olla vÃ¤hintÃ¤Ã¤n 400 ja korkeuden 100 ja otsikkona teksti "Swing on". TehtÃ¤vÃ¤ tulee toteuttaa tehtÃ¤vÃ¤pohjassa tulevaan kÃ¤yttÃ¶liittymÃ¤runkoon.  JFrame-olion luominen ja nÃ¤kyvÃ¤ksi asettamisen tulee tapahtua metodissa <code>run()</code>, tekstikomponentti lisÃ¤tÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤lle metodissa <code>luoKomponentit(Container container)</code>.</p>

<p><strong>HUOM: KÃ¤yttÃ¶liittymien oliomuuttujia saa alustaa vain metodeissa tai konstruktorissa! ÃlÃ¤ alusta oliomuuttujia suoraan mÃ¤Ã¤rittelyn yhteydessÃ¤.</strong></p>
</div>

<h4>Painikkeet</h4>

<p>KÃ¤yttÃ¶liittymÃ¤Ã¤n saa painikkeita <code>JButton</code>-luokan avulla. JButton-olion lisÃ¤Ã¤minen kÃ¤yttÃ¶liittymÃ¤Ã¤n tapahtuu aivan kuin JLabel-olion lisÃ¤Ã¤minen.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
    }
</pre>

    <p><img src="img-ohja/kali/kali-nappi.png"/></p>

<p>YritetÃ¤Ã¤n seuraavaksi lisÃ¤tÃ¤ kÃ¤yttÃ¶liittymÃ¤Ã¤n sekÃ¤ tekstiÃ¤, ettÃ¤ nappi.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("Click!");
        container.add(nappi);
        JLabel teksti = new JLabel("TekstiÃ¤.");
        container.add(teksti);
    }
</pre>

<p>Ohjelmaa suorittaessa nÃ¤emme seuraavanlaisen kÃ¤yttÃ¶liittymÃ¤n.</p>

    <p><img src="img-ohja/kali/kali-tarve-asettelulle.png"/></p>

<p>Vain viimeiseksi lisÃ¤tty kÃ¤yttÃ¶liittymÃ¤komponentti on nÃ¤kyvillÃ¤, eikÃ¤ ohjelma toimi toivotusti. MistÃ¤ tÃ¤ssÃ¤ oikein on kyse?</p>

<h3>KÃ¤yttÃ¶liittymÃ¤komponenttien asettelu</h3>

<p>Jokaisella kÃ¤yttÃ¶liittymÃ¤komponentilla on oma sijainti kÃ¤yttÃ¶liittymÃ¤ssÃ¤. Komponentin sijainnin mÃ¤Ã¤rÃ¤Ã¤ kÃ¤ytÃ¶ssÃ¤ oleva kÃ¤yttÃ¶liittymÃ¤n asettelija (<em>Layout Manager</em>). YrittÃ¤essÃ¤mme aiemmin lisÃ¤tÃ¤ useampia kÃ¤yttÃ¶liittymÃ¤komponentteja <code>Container</code>-olioon kÃ¤yttÃ¶liittymÃ¤ssÃ¤ oli vain yksi komponentti nÃ¤kyvillÃ¤. Jokaisessa <code>Container</code>-oliossa on oletuksena kÃ¤yttÃ¶liittymÃ¤asettelija <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/BorderLayout.html" target="_blank">BorderLayout</a></code>.</p>

<p>BorderLayout asettelee kÃ¤yttÃ¶liittymÃ¤komponentit viiteen alueeseen: kÃ¤yttÃ¶liittymÃ¤n keskikohdan lisÃ¤ksi kÃ¤ytÃ¶ssÃ¤ on ilmansuunnat. Voimme antaa Container-olion <code>add</code>-metodille ylimÃ¤Ã¤rÃ¤isenÃ¤ parametrina lisÃ¤toiveen kohdasta, johon haluamme asettaa kÃ¤yttÃ¶liittymÃ¤komponentin. BorderLayout-luokassa on kÃ¤ytÃ¶ssÃ¤ luokkamuuttujat <code>BorderLayout.NORTH</code>, <code>BorderLayout.EAST</code>, <code>BorderLayout.SOUTH</code>, <code>BorderLayout.WEST</code>, ja <code>BorderLayout.CENTER</code>.</p>

<p>KÃ¤ytettÃ¤vÃ¤ kÃ¤yttÃ¶liittymÃ¤asettelija asetetaan <code>Container</code>-oliolle metodin <code>setLayout</code>-parametrina. Metodille <code>add</code> voidaan antaa kÃ¤yttÃ¶liittymÃ¤komponentin lisÃ¤ksi paikka, johon komponentti lisÃ¤tÃ¤Ã¤n. Alla on esimerkki, jossa jokaiseen BorderLayoutin tarjoamaan paikkaan asetetaan kÃ¤yttÃ¶liittymÃ¤komponentti.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        // seuraava rivi siis ei tÃ¤ssÃ¤ tilanteessa pakollinen, sillÃ¤ BorderLayout on JFramessa jokatapauksessa oletuksena
        container.setLayout(new BorderLayout());

        container.add(new JButton("Pohjoinen (North)"), BorderLayout.NORTH);
        container.add(new JButton("ItÃ¤ (East)"), BorderLayout.EAST);
        container.add(new JButton("EtelÃ¤ (South)"), BorderLayout.SOUTH);
        container.add(new JButton("LÃ¤nsi (West)"), BorderLayout.WEST);
        container.add(new JButton("Keski (Center)"), BorderLayout.CENTER);

        container.add(new JButton("Oletuspaikka (Center)"));
    }
</pre>

<p>Huomaa, ettÃ¤ nappi <code>"Keski (Center)"</code> ei tule nÃ¤kymÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤ssÃ¤ sillÃ¤ nappi <code>"Oletuspaikka (Center)"</code> asetetaan oletuksena sen paikalle. KÃ¤yttÃ¶liittymÃ¤ssÃ¤pohjassa yllÃ¤ oleva koodi nÃ¤yttÃ¤Ã¤ seuraavalta.</p>

    <p><img src="img-ohja/kali/layout-borderlayout.png"/></p>

<p>Kuten kÃ¤yttÃ¶liittymÃ¤komponentteja, myÃ¶s kÃ¤yttÃ¶liittymÃ¤n asettelijoita on useita. Oraclella on kÃ¤yttÃ¶liittymÃ¤asettelijoihin visuaalinen opas osoitteessa <a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank">http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html</a>. Tutustutaan seuraavaksi kÃ¤yttÃ¶liittymÃ¤asettelijaan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/BoxLayout.html" target="_blank">BoxLayout</a></code>.</a>

<h4>BoxLayout</h4>

<p>BoxLayoutia kÃ¤ytettÃ¤essÃ¤ kÃ¤yttÃ¶liittymÃ¤komponentit asetetaan kÃ¤yttÃ¶liittymÃ¤Ã¤n joko vaakasuunnassa tai pystysuunnassa. BoxLayoutin konstruktorille annetaan parametrina Container-olio, johon kÃ¤yttÃ¶liittymÃ¤komponentteja ollaan asettamassa, ja kÃ¤yttÃ¶liittymÃ¤komponenttien asettelusuunta. Asettelusuunta on joko <code>BoxLayout.X_AXIS</code>, eli komponentit vaakasuunnassa, tai <code>BoxLayout.Y_AXIS</code>, eli komponentit pystysuunnassa. Toisin kuin BorderLayout-asettelijaa kÃ¤ytettÃ¤essÃ¤, BoxLayoutilla ei ole rajattua mÃ¤Ã¤rÃ¤Ã¤ paikkoja. Container-olioon voi siis lisÃ¤tÃ¤ niin monta kÃ¤yttÃ¶liittymÃ¤komponenttia kuin haluaa.</p>

<p>KÃ¤yttÃ¶liittymÃ¤n asettelu <code>BoxLayout</code>-asettelijaa kÃ¤yttÃ¤en toimii kuten <code>BorderLayout</code>-asettelijan kÃ¤yttÃ¶. Luomme ensin asettelijan, jonka asetamme <code>Container</code>-oliolle sen metodilla <code>setLayout</code>. TÃ¤mÃ¤n jÃ¤lkeen voimme lisÃ¤tÃ¤ kÃ¤yttÃ¶liittymÃ¤komponentteja <code>Container</code>-olion <code>add</code>-metodilla. Emme tarvitse erillistÃ¤ sijaintia ilmaisevaa parametria. Alla esimerkki vaakasuunnassa asetetuista kÃ¤yttÃ¶liittymÃ¤komponenteista.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.X_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

<p><img src="img-ohja/kali/boxlayout-x_axis.png"/></p>

<p>KÃ¤yttÃ¶liittymÃ¤komponenttien asettelu pystysuunnassa ei vaadi suurta muutosta. Vaihdamme <code>BoxLayout</code>-olion konstruktorille annettavaksi suuntaparametriksi <code>BoxLayout.Y_AXIS</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Eka!"));
        container.add(new JLabel("Toka!"));
        container.add(new JLabel("Kolmas!"));
    }
</pre>

    <p><img src="img-ohja/kali/boxlayout-y_axis.png"/></p>

<p>KÃ¤yttÃ¶liittymÃ¤asettelijoita kÃ¤yttÃ¤mÃ¤llÃ¤ voimme luoda kÃ¤yttÃ¶liittymiÃ¤, joissa kÃ¤yttÃ¶liittymÃ¤komponentit ovat aseteltu sopivasti. Alla on esimerkkikÃ¤yttÃ¶liittymÃ¤, jossa komponentit asetetaan pystysuuntaan. Ensin teksti, ja sitten vaihtoehtoinen valinta. Vaihtoehtoisen valinnan, eli valinnan jossa vain yksi vaihtoehto on aina voimassa, voi tehdÃ¤ kÃ¤yttÃ¤mÃ¤llÃ¤ <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/ButtonGroup.html" target="_blank">ButtonGroup</a></code>-ryhmittelijÃ¤Ã¤ ja <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JRadioButton.html" target="_blank">JRadioButton</a></code>-painikkeita.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        BoxLayout layout = new BoxLayout(container, BoxLayout.Y_AXIS);
        container.setLayout(layout);

        container.add(new JLabel("Valitse ruokavalio:"));

        JRadioButton liha = new JRadioButton("Liha");
        JRadioButton kala = new JRadioButton("Kala");

        ButtonGroup buttonGroup = new ButtonGroup();
        buttonGroup.add(liha);
        buttonGroup.add(kala);

        container.add(liha);
        container.add(kala);
    }
</pre>


    <p><img src="img-ohja/kali/buttongroup-ruokavalio.png"/></p>

<div class="tehtavat">

<h3>Kysely</h3>

<p>Toteuta tehtÃ¤vÃ¤pohjaan kÃ¤yttÃ¶liittymÃ¤, joka nÃ¤yttÃ¤Ã¤ seuraavalta:</p>

<p><img src="img-ohja/kali/157-kysely.png"/></p>

<p>KÃ¤ytÃ¤ kÃ¤yttÃ¶liittymÃ¤n asettelijana luokkaa <code>BoxLayout</code>, komponentteina luokkia <code>JLabel</code>, <code>JRadioButton</code>, <code>JCheckBox</code> ja <code>JButton</code>.</p>

<p>KÃ¤ytÃ¤ <code>ButtonGroup</code>-luokkaa varmistamaan ettÃ¤ vaihtoehdot "Siksi" ja "Koska se on kivaa" eivÃ¤t voi olla valittuina samaan aikaan.</p>

<p>Varmista ettÃ¤ kÃ¤yttÃ¶liittymÃ¤ on niin iso, ettÃ¤ kÃ¤yttÃ¤jÃ¤ voi klikata nappeja muuttamatta sen kokoa. Voit kÃ¤yttÃ¤Ã¤ esimerkiksi leveytenÃ¤ 200 pikseliÃ¤, korkeutena 300 pikseliÃ¤.</p>
</div>


<h3>Tapahtumien kÃ¤sittely</h3>

<p>TÃ¤hÃ¤nastiset graafiset kÃ¤yttÃ¶liittymÃ¤mme ovatvaikkakin hienoja hieman tylsiÃ¤: ne eivÃ¤t reagoi millÃ¤Ã¤n tavalla kÃ¤yttÃ¶liittymÃ¤ssÃ¤ tehtyihin tapahtumiin. Reagoimattomuus ei johdu kÃ¤yttÃ¶liittymÃ¤komponenteista, vaan siitÃ¤ ettÃ¤ emme ole lisÃ¤nneet kÃ¤yttÃ¶liittymÃ¤komponentteihin tapahtumia kÃ¤sitteleviÃ¤ kuuntelijoita.</p>

<p>Tapahtumankuuntelijat <em>kuuntelevat</em> kÃ¤yttÃ¶liittymÃ¤komponentteja joihin ne on liitetty. Aina kun kÃ¤yttÃ¶liittymÃ¤komponentille tehdÃ¤Ã¤n joku toiminto, esimerkiksi napille napin painaminen, kÃ¤yttÃ¶liittymÃ¤komponentti kutsuu jokaisen siihen liitetyn tapahtumakuuntelijan tiettyÃ¤ metodia. KÃ¤ytÃ¤nnÃ¶ssÃ¤ tapahtumankuuntelijat ovat tietyn rajapinnan toteuttavia luokkia, joiden ilmentymiÃ¤ kÃ¤yttÃ¶liittymÃ¤komponentille voi lisÃ¤tÃ¤. Tapahtuman tapahtuessa kÃ¤yttÃ¶liittymÃ¤komponentti kÃ¤y jokaisen siihen liitetyn tapahtumankuuntelijan lÃ¤pi, ja kutsuu rajapinnassa mÃ¤Ã¤riteltyÃ¤ metodia.</p>

<p>Swing-kÃ¤yttÃ¶liittymissÃ¤ eniten kÃ¤ytetty tapahtumankuuntelurajapinta on <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionListener.html">ActionListener</a></code>. Rajapinta <code>ActionListener</code> mÃ¤Ã¤rittelee metodin <code>void actionPerformed(ActionEvent e)</code>, joka saa parametrinaan tapahtumasta kertovan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/ActionEvent.html" target="_blank">ActionEvent</a></code>-olion.</p>

<p>Toteutetaan ensimmÃ¤inen oma tapahtumankuuntelija, jonka tarkoituksena on vain tulostaa viesti standarditulostusvirtaan nappia painettaessa. Luokka <code>ViestiKuuntelija</code> toteuttaa rajapinnan <code>ActionListener</code> ja tulostaa viestin <code>"Viesti vastaanotettu!"</code> kun metodia <code>actionPerformed</code> kutsutaan.</p>

<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ViestiKuuntelija implements ActionListener {

    @Override
    public void actionPerformed(ActionEvent ae) {
        System.out.println("Viesti vastaanotettu!");
    }
}
</pre>

<p>Luodaan seuraavaksi kÃ¤yttÃ¶liittymÃ¤Ã¤n <code>JButton</code>-tyyppinen nappi, ja lisÃ¤tÃ¤Ã¤n siihen <code>ViestiKuuntelija</code>-luokan ilmentymÃ¤. Luokalle <code>JButton</code> voi lisÃ¤tÃ¤ tapahtumankuuntelijan kÃ¤yttÃ¤mÃ¤llÃ¤ sen ylÃ¤luokassa <code>AbstractButton</code> mÃ¤Ã¤riteltyÃ¤ metodia <code>public void addActionListener(ActionListener actionListener)</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        JButton nappi = new JButton("ViestitÃ¤!");
        nappi.addActionListener(new ViestiKuuntelija());

        container.add(nappi);
    }
</pre>

<p><img src="img-ohja/kali/kali-actionlistener-viestita.png"/></p>

<p>KÃ¤yttÃ¶liittymÃ¤ssÃ¤ olevaa nappia painettaessa nÃ¤emme standarditulostusvirrassa seuraavan viestin.</p>

<pre>
Viesti vastaanotettu!
</pre>

<h4>Olioiden kÃ¤sittely tapahtumankuuntelijoissa</h4>

<p>Haluamme usein ettÃ¤ tapahtumankuuntelija muokkaa jonkun olion tilaa. PÃ¤Ã¤stÃ¤ksemme olioon kÃ¤siksi tapahtumankuuntelijassa, tulee meidÃ¤n antaa viite kÃ¤siteltÃ¤vÃ¤Ã¤n olioon tapahtumankuuntelijalle sen konstruktorissa. Tapahtumankuuntelijat ovat tÃ¤ysin samanlaisia luokkia kuin muutkin Javan luokat, eli pÃ¤Ã¤semme ohjelmoimaan kaiken haluamamme toiminnallisuuden.</p>

<p>Pohditaan seuraavaa kÃ¤yttÃ¶liittymÃ¤Ã¤ jossa on kaksi <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextArea.html" target="_blank">JTextArea</a></code>-tyyppistÃ¤ tekstikenttÃ¤Ã¤, eli tekstikenttÃ¤Ã¤ johon kÃ¤yttÃ¤jÃ¤ voi syÃ¶ttÃ¤Ã¤ tekstiÃ¤, ja <code>JButton</code>-tyyppinen nappi. KÃ¤yttÃ¶liittymÃ¤ kÃ¤yttÃ¤Ã¤ <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/GridLayout.html" target="_blank">GridLayout</a></code>-asettelijaa, jonka avulla kÃ¤yttÃ¶liittymÃ¤n voi rakentaa taulukkomaiseksi. GridLayout-luokan konstruktorille mÃ¤Ã¤riteltiin yksi rivi ja kolme saraketta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>

    <p><img src="img-ohja/kali/kopioija-alku.png"/></p>

<p>Haluamme lisÃ¤tÃ¤ kÃ¤yttÃ¶liittymÃ¤Ã¤n toiminnallisuuden, jossa <code>JButton</code>-nappia painettaessa vasemman tekstikentÃ¤n sisÃ¤ltÃ¶ kopioituu oikeaan tekstikenttÃ¤Ã¤n. TÃ¤mÃ¤ onnistuu toteuttamalla tapahtumankuuntelija. Luodaan rajapinnan <code>ActionListener</code> toteuttava luokka <code>KenttienKopioija</code>, joka kopioi JTextArea kentÃ¤stÃ¤ toiseen. </p>


<pre class="sh_java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JTextArea;

public class KenttienKopioija implements ActionListener {

    private JTextArea lahde;
    private JTextArea kohde;

    public KenttienKopioija(JTextArea lahde, JTextArea kohde) {
        this.lahde = lahde;
        this.kohde = kohde;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        this.kohde.setText(this.lahde.getText());
    }
}
</pre>

<p>Tapahtumankuuntelijan rekisterÃ¶inti <code>JButton</code>-oliolle onnistuu metodilla <code>addActionListener</code>.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(1, 3);
        container.setLayout(layout);

        JTextArea textAreaVasen = new JTextArea("Le Kopioija");
        JTextArea textAreaOikea = new JTextArea();
        JButton kopioiNappi = new JButton("Kopioi!");

        KenttienKopioija kopioija = new KenttienKopioija(textAreaVasen, textAreaOikea);
        kopioiNappi.addActionListener(kopioija);

        container.add(textAreaVasen);
        container.add(kopioiNappi);
        container.add(textAreaOikea);
    }
</pre>


<p>Nappia painettaessa vasemman tekstikentÃ¤n sisÃ¤ltÃ¶ kopioituu oikealla olevaan tekstikenttÃ¤Ã¤n.</p>

    <p><img src="img-ohja/kali/kopioija-valmis.png"/></p>



<div class="tehtavat">

<h3>Ilmoitin</h3>

<p>Toteuta tehtÃ¤vÃ¤pohjaan kÃ¤yttÃ¶liittymÃ¤, joka nÃ¤yttÃ¤Ã¤ seuraavalta.</p>

    <p><img src="img-ohja/kali/158-ilmoitin.png"/></p>

<p>Ohjelman tulee koostua seuraavista pakkauksessa <code>ilmoitin</code> olevista luokista. Luokka <code>Ilmoitin</code> on kÃ¤yttÃ¶liittymÃ¤luokka, joka kÃ¤ynnistetÃ¤Ã¤n <code>Main</code>-luokasta. Ilmoittimessa on kÃ¤yttÃ¶liittymÃ¤komponentteina <code>JTextField</code>, <code>JButton</code>, ja <code>JLabel</code>. Voit asetella kÃ¤yttÃ¶liittymÃ¤komponentit <code>GridLayout</code>-asettelijan avulla: kutsu <code>new GridLayout(3, 1)</code> luo uuden asettelijan, joka asettelee kolme kÃ¤yttÃ¶liittymÃ¤elementtiÃ¤ pystysuunnassa.</p>

<p>Sovelluksessa tulee olla lisÃ¤ksi luokka <code>TapahtumanKuuntelija</code>, joka toteuttaa rajapinnan <code>ActionListener</code>. Tapahtumankuuntelija liitetÃ¤Ã¤n nappiin ja sen tulee kopioida kÃ¤yttÃ¶liittymÃ¤ssÃ¤ olevan JTextField-kentÃ¤n sisÃ¤ltÃ¶ JLabel-kenttÃ¤Ã¤n napin painalluksen yhteydessÃ¤ ja samalla tyhentÃ¤Ã¤ JTextField asettamalla sen sisÃ¤llÃ¶ksi "".</p>

<p>Varmista ettÃ¤ kÃ¤yttÃ¶liittymÃ¤ kÃ¤ynnistyy niin isona ettÃ¤ jokaista nappulaa voi klikata.</p>
</div>

<h3>Sovelluslogiikan ja kÃ¤yttÃ¶liittymÃ¤logiikan eriyttÃ¤minen</h3>

<p>Sovelluslogiikan (esimerkiksi tallennus- tai lukutoiminnallisuuden) ja kÃ¤yttÃ¶liittymÃ¤n sekoittaminen samoihin luokkiin on yleisesti ottaen huono asia. Se vaikeuttaa ohjelman testaamista ja muokkaamista huomattavasti, ja tekee koodista myÃ¶s paljon vaikeammin luettavaa. Single responsibility principlen sanoin "Jokaisella luokalla pitÃ¤isi olla vain yksi selkeÃ¤ vastuu". Sovelluslogiikan erottaminen kÃ¤yttÃ¶liittymÃ¤logiikasta onnistuu sopivan rajapintasuunnittelun kautta.  Oletetaan, ettÃ¤ kÃ¤ytÃ¶ssÃ¤mme on rajapinta <code>PersonVarasto</code>, ja haluamme toteuttaa kÃ¤yttÃ¶liittymÃ¤n henkilÃ¶iden tallentamiseen.</p>

<pre class="sh_java">
public interface PersonVarasto {
    void talleta(Person henkilo);
    Person hae(String henkilotunnus);

    void poista(Person henkilo);
    void poista(String henkilotunnus);
    void poistaKaikki();

    Collection&lt;Person&gt; haeKaikki();
}
</pre>

<h4>KÃ¤yttÃ¶liittymÃ¤n toteutus</h4>

<p>KÃ¤yttÃ¶liittymÃ¤Ã¤ toteutettaessa hyvÃ¤ aloitustapa on sopivien kÃ¤yttÃ¶liittymÃ¤komponenttien lisÃ¤Ã¤minen kÃ¤yttÃ¶liittymÃ¤Ã¤n. HenkilÃ¶iden tallennuksessa tarvitsemme kentÃ¤t nimelle ja henkilÃ¶tunnukselle, sekÃ¤ napin jolla henkilÃ¶ voidaan lisÃ¤tÃ¤. KÃ¤ytetÃ¤Ã¤n Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JTextField.html" target="_blank">JTextField</a></code>-luokkaa tekstin syÃ¶ttÃ¤miseen, ja <code>JButton</code>-luokkaa napin toteuttamiseen. Luodaan kÃ¤yttÃ¶liittymÃ¤Ã¤n lisÃ¤ksi selventÃ¤vÃ¤t <code>JLabel</code>-tyyppiset selitystekstit.</p>

<p>KÃ¤ytetÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤n asetteluun <code>GridLayout</code>-asettelijaa. RivejÃ¤ kÃ¤yttÃ¶liittymÃ¤ssÃ¤ on 3, sarakkeita 2. LisÃ¤tÃ¤Ã¤n tapahtumankuuntelija myÃ¶hemmin. KÃ¤yttoliittymÃ¤luokan metodi <code>luoKomponentit</code> nÃ¤yttÃ¤Ã¤ nyt seuraavalta.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("LisÃ¤Ã¤ henkilÃ¶!");
        // tapahtumankuuntelija

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<p>KÃ¤yttÃ¶liittymÃ¤ nÃ¤yttÃ¤Ã¤ seuraavalta kun siihen on lisÃ¤tty tietoa.</p>

    <p><img src="img-ohja/kali/kali-henkilon-lisays.png"/></p>

<p>Tapahtumankuuntelijan tulee tietÃ¤Ã¤ tallennustoiminnallisuudesta eli <code>PersonVarasto</code>-rajapinnasta sekÃ¤ kentistÃ¤, joita se kÃ¤yttÃ¤Ã¤. Luodaan <code>ActionListener</code>-rajapinnan toteuttava luokka <code>PersonnLisaysKuuntelija</code>. Luokka saa konstruktorissaan parametrina <code>PersonVarasto</code>-rajapinnan toteuttavan olion sekÃ¤ kaksi <code>JTextField</code>-oliota, jotka ovat kentÃ¤t nimelle ja henkilÃ¶tunnukselle. Metodissa <code>actionPerformed</code> luodaan uusi <code>Person</code>-olio ja tallennetaan se <code>PersonVarasto</code>-olion tarjoamalla <code>talleta</code>-metodilla.</p>

<pre class="sh_java">
public class PersonnLisaysKuuntelija implements ActionListener {

    private PersonVarasto henkiloVarasto;
    private JTextField nimiKentta;
    private JTextField hetuKentta;

    public PersonnLisaysKuuntelija(PersonVarasto henkiloVarasto, JTextField nimiKentta, JTextField hetuKentta) {
        this.henkiloVarasto = henkiloVarasto;
        this.nameKentta = nimiKentta;
        this.hetuKentta = hetuKentta;
    }

    @Override
    public void actionPerformed(ActionEvent ae) {
        Person henkilo = new Person(nimiKentta.getText(), hetuKentta.getText());
        this.henkiloVarasto.talleta(henkilo);
    }
}
</pre>

<p>Jotta saamme <code>PersonVarasto</code>-viitteen <code>PersonnLisaysKuuntelija</code>-oliolle, tulee sen olla kÃ¤yttÃ¶liittymÃ¤n tiedossa. LisÃ¤tÃ¤Ã¤n kÃ¤yttÃ¶liittymÃ¤lle oliomuuttuja <code>private PersonVarasto henkiloVarasto</code>, joka asetetaan konstruktorissa. Luokan <code>Kayttoliittyma</code> konstruktoria muokataan siten, ettÃ¤ sille annetaan <code>PersonVarasto</code>-rajapinnan toteuttama luokka.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private PersonVarasto henkiloVarasto;

    public Kayttoliittyma(PersonVarasto henkiloVarasto) {
        this.henkiloVarasto = henkiloVarasto;
    }
    // ...


</pre>

<p>Voimme nyt luoda tapahtumankuuntelijan <code>PersonnLisaysKuuntelija</code>, jolle annetaan sekÃ¤ <code>PersonVarasto</code>-viite, ettÃ¤ kentÃ¤t.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        GridLayout layout = new GridLayout(3, 2);
        container.setLayout(layout);

        JLabel nimiTeksti = new JLabel("Nimi: ");
        JTextField nimiKentta = new JTextField();
        JLabel hetuTeksti = new JLabel("Hetu: ");
        JTextField hetuKentta = new JTextField();

        JButton lisaaNappi = new JButton("LisÃ¤Ã¤ henkilÃ¶!");
        PersonnLisaysKuuntelija kuuntelija = new PersonnLisaysKuuntelija(henkiloVarasto, nimiKentta, hetuKentta);
        lisaaNappi.addActionListener(kuuntelija);

        container.add(nimiTeksti);
        container.add(nimiKentta);
        container.add(hetuTeksti);
        container.add(hetuKentta);
        container.add(new JLabel(""));
        container.add(lisaaNappi);
    }
</pre>

<div class="tehtavat">
<h3>Axe Click Effect</h3>

<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ toteutetaan laskuri klikkausten laskemiseen. TehtÃ¤vÃ¤ssÃ¤ sovelluslogiikka, eli laskeminen ja kÃ¤yttÃ¶liittymÃ¤logiikka on erotettu toisistaan. Lopullisen sovelluksen tulee nÃ¤yttÃ¤Ã¤ kutakuinkin seuraavalta. </p>

    <p><img src="img-ohja/kali/159-clickeffect.png"/></p>

<h4>OmaLaskuri</h4>

<p>Toteuta pakkaukseen <code>clicker.sovelluslogiikka</code> rajapinnan <code>Laskuri</code> toteuttava luokka <code>OmaLaskuri</code>. Luokan <code>OmaLaskuri</code> metodin <code>annaArvo</code> palauttama luku on aluksi 0. Kun metodia <code>kasvata</code> kutsutaan, kasvaa arvo aina yhdellÃ¤.</p>

<p>Voit halutessasi testata luokan toimintaa seuraavan ohjelman avulla.</p>

<pre class="sh_java">
        Laskuri laskuri = new OmaLaskuri();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
        laskuri.kasvata();
        System.out.println("Arvo: " + laskuri.annaArvo());
</pre>

<pre>
Arvo: 0
Arvo: 1
Arvo: 2
</pre>

<h4>KlikkaustenKuuntelija</h4>

<p>Toteuta pakkaukseen <code>clicker.kayttoliittyma</code> rajapinnan <code>ActionListener</code> toteuttava luokka <code>KlikkaustenKuuntelija</code>. Luokka <code>KlikkaustenKuuntelija</code> saa konstruktorin parametrina <code>Laskuri</code>-rajapinnan toteuttavan olion ja <code>JLabel</code>-olion.</p>

<p>Toteuta <code>actionPerformed</code>-metodi siten, ettÃ¤ <code>Laskuri</code>-oliota kasvatetaan aluksi yhdellÃ¤, jonka jÃ¤lkeen laskurin arvo asetetaan <code>JLabel</code>-olion tekstiksi. <code>JLabel</code>-olion tekstiÃ¤ voidaan muuttaa metodilla <code>setText</code>.</p>

<h4>KÃ¤yttÃ¶liittymÃ¤</h4>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, ettÃ¤ kÃ¤yttÃ¶liittymÃ¤ saa konstruktorin parametrina <code>Laskuri</code>-olion, tarvitset uuden konstruktorin. LisÃ¤Ã¤ kÃ¤yttÃ¶liittymÃ¤Ã¤n tarvittavat kÃ¤yttÃ¶liittymÃ¤komponentit. RekisterÃ¶i napille myÃ¶s edellisessÃ¤ osassa toteutettu tapahtumankuuntelija.</p>

<p>KÃ¤ytÃ¤ kÃ¤yttÃ¶liittymÃ¤komponenttien asetteluun <code>BorderLayout</code>-luokan tarjoamia toiminnallisuuksia. Muuta myÃ¶s <code>Main</code>-luokkaa siten, ettÃ¤ kÃ¤yttÃ¶liittymÃ¤lle annetaan <code>OmaLaskuri</code>-olio. Kun kÃ¤yttÃ¶liittymÃ¤ssÃ¤ olevaa <code>"Click!"</code>nappia on painettu kahdesti, sovellus nÃ¤yttÃ¤Ã¤ kutakuinkin seuraavalta.</p>

    <p><img src="img-ohja/kali/159-clickeffect-klikattu.png"/></p>

</div>


<h3>SisÃ¤kkÃ¤iset Container-oliot</h3>

<p>TÃ¶rmÃ¤Ã¤mme silloin tÃ¤llÃ¶in tilanteeseen, jossa <code>JFrame</code>-luokan tarjoama <code>Container</code>-olio ei riitÃ¤ kÃ¤yttÃ¶liittymÃ¤n asetteluun. Saatamme tarvita erilaisia kÃ¤yttÃ¶liittymÃ¤nÃ¤kymiÃ¤ tai mahdollisuutta kÃ¤yttÃ¶liittymÃ¤komponenttien ryhmittelyyn niiden kÃ¤yttÃ¶tarkoituksen mukaan. Esimerkiksi alla olevan kÃ¤yttÃ¶liittymÃ¤n rakentaminen ei olisi kovin helppoa vain <code>JFrame</code>-luokan tarjoamalla <code>Container</code>-oliolla.</p>

   <p><img src="img-ohja/kali/jpanel-container.png"/></p>

<p>Voimme asettaa Container-tyyppisiÃ¤ olioita toistensa sisÃ¤Ã¤n. Luokka <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JPanel.html" target="_blank">JPanel</a></code> (katso myÃ¶s <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html" target="_blank">How to Use Panels</a>) mahdollistaa sisÃ¤kkÃ¤iset <code>Container</code>-oliot. JPanel-luokan ilmentymÃ¤Ã¤n voi lisÃ¤tÃ¤ kÃ¤yttÃ¶liittymÃ¤komponentteja samalla tavalla kuin <code>JFrame</code>-luokasta saatuun <code>Container</code>-ilmentymÃ¤Ã¤n. TÃ¤mÃ¤n lisÃ¤ksi <code>JPanel</code>-luokan ilmentymÃ¤n voi lisÃ¤tÃ¤ <code>Container</code>-olioon. TÃ¤mÃ¤ mahdollistaa useamman <code>Container</code>-olion kÃ¤yttÃ¤misen kÃ¤yttÃ¶liittymÃ¤n suunnittelussa.</p>

<p>YllÃ¤ olevan kÃ¤yttÃ¶liittymÃ¤n luominen on helpompaa <code>JPanel</code>-luokan avulla.. Luodaan kÃ¤yttÃ¶liittymÃ¤, jossa on kolme nappia "Suorita", "Testaa", ja "LÃ¤hetÃ¤", sekÃ¤ tekstialue joka sisÃ¤ltÃ¤Ã¤ tekstiÃ¤. Napit ovat oma joukkonsa, joten tehdÃ¤Ã¤n niille erillinen <code>JPanel</code>-olio joka asetetaan <code>JFrame</code>-luokasta saadun <code>Container</code>-olion etelÃ¤osaan. Tekstialue tulee keskelle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(luoValikko(), BorderLayout.SOUTH);
    }

    private JPanel luoValikko() {
        JPanel panel = new JPanel(new GridLayout(1, 3));
        panel.add(new JButton("Suorita"));
        panel.add(new JButton("Testaa"));
        panel.add(new JButton("LÃ¤hetÃ¤"));
        return panel;
    }
</pre>

<p>JPanel-luokalle annetaan konstruktorin parametrina kÃ¤ytettÃ¤vÃ¤ asettelutyyli. Jos asettelutyyli tarvitsee konstruktorissaan viitteen kÃ¤ytettyyn <code>Container</code>-olioon, on <code>JPanel</code>-luokalla myÃ¶s metodi <code>setLayout</code>.</p>

<p>Jos kÃ¤yttÃ¶liittymÃ¤ssÃ¤mme on selkeÃ¤t erilliset kokonaisuudet, voimme myÃ¶s periÃ¤ <code>JPanel</code> luokan. Esimerkiksi yllÃ¤olevan valikon voisi toteuttaa myÃ¶s seuraavasti.</p>

<pre class="sh_java">
import java.awt.GridLayout;
import javax.swing.JButton;
import javax.swing.JPanel;

public class ValikkoPanel extends JPanel {

    public ValikkoPanel() {
        super(new GridLayout(1, 3));
        luoKomponentit();
    }

    private void luoKomponentit() {
        add(new JButton("Suorita"));
        add(new JButton("Testaa"));
        add(new JButton("LÃ¤hetÃ¤"));
    }
}
</pre>

<p>Nyt kÃ¤yttÃ¶liittymÃ¤luokassa voidaan luoda <code>ValikkoPanel</code>-luokan ilmentymÃ¤.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new JTextArea());
        container.add(new ValikkoPanel(), BorderLayout.SOUTH);
    }
</pre>

<p>Huomaa ettÃ¤ tapahtumankÃ¤sittelyÃ¤ tarvittaessa luokalle <code>ValikkoPanel</code> tulee antaa parametrina kaikki tarvittavat oliot.</p>

<div class="tehtavat">
<h3>Calculator</h3>

<p>TehtÃ¤vÃ¤ssÃ¤ on tarkoitus toteuttaa yksinkertainen laskin. Laskimen kÃ¤yttÃ¶liittymÃ¤n tulee olla seuraavanlainen:</p>

   <p><img src="img-ohja/laskin.png"/></p>

<p>TehtÃ¤vÃ¤pohjan mukana tulee kÃ¤ynistyksen suorittava pÃ¤Ã¤ohjelma sekÃ¤ graafisen kÃ¤yttÃ¶liittymÃ¤n sisÃ¤ltÃ¤vÃ¤ luokka <code>GraafinenLaskin</code>. KÃ¤yttÃ¶liittymÃ¤n on oltava tÃ¤smÃ¤lleen seuraavassa osassa kuvaillulla tavalla tehty, muuten saat vapaasti suunnitella ohjelman rakenteen.</p> 

<h4>Layout kuntoon</h4>

<p>KÃ¤yttÃ¶liittymÃ¤n pohjana olevassa  <code>JFrame</code>:ssa tulee kÃ¤yttÃ¤Ã¤ asettelijana <code>GridLayout</code>ia jossa on kolme riviÃ¤ ja yksi sarake. YlimpÃ¤nÃ¤ on tuloskenttÃ¤vÃ¤ toimiva  <code>JTextField</code>, jonka tÃ¤ytyy asettaa metodikutsulla <code>setEnabled(false)</code> "poissa pÃ¤Ã¤ltÃ¤". Toisena on syÃ¶tekenttÃ¤nÃ¤ toimiva  <code>JTextField</code>. TuloskentÃ¤ssÃ¤ on aluksi teksti 0 ja syÃ¶tekenttÃ¤ on tyhjÃ¤.</p>

<p>Alimpana komponenttina sijaitsee <code>JPanel</code> jolla asettelijana <code>GridLayout</code>ia jossa on yksi rivi ja kolme saraketta. Panelissa on kolme <code>JButton</code>ia, joissa tekstit "+", "+" ja "Z".</p>

<h4>Perustoiminnallisuus</h4>

<p>Laskimen toimintalogiikka on seuraava. KÃ¤yttÃ¤jÃ¤n kirjottaessa syÃ¶tekenttÃ¤Ã¤n luvun n ja painaessa <strong>+</strong>, lisÃ¤tÃ¤Ã¤n tuloskentÃ¤ssÃ¤ olevaan arvoon n ja pÃ¤ivitetÃ¤Ã¤n tuloskenttÃ¤ uuteen arvoon. Vastaavasti kÃ¤yttÃ¤jÃ¤n kirjottaessa syÃ¶tekenttÃ¤Ã¤n luvun n ja painaessa <strong>-</strong>, vÃ¤hennetÃ¤Ã¤n tuloskentÃ¤ssÃ¤ olevasta arvosta n ja pÃ¤ivitetÃ¤Ã¤n tuloskenttÃ¤ uuteen arvoon. Jos kÃ¤yttÃ¤jÃ¤ painaa <strong>Z</strong>, nollautuu tuloskenttÃ¤.</p>

<h4>HienosÃ¤Ã¤tÃ¶</h4>

<p>Laajennetaan vielÃ¤ ohjelmaa seuraavilla ominaisuuksissa:</p>
<ul>
<li>Jos tuloskentÃ¤ssÃ¤ on 0, ei <strong>Z</strong>-nappia voi painaa, eli se tulee olla asetettu metodikutsulla <code>setEnabled(false)</code> "poissa pÃ¤Ã¤ltÃ¤". Muissa tilanteissa napin tulee olla pÃ¤Ã¤llÃ¤.</li>
<li>Kun kÃ¤yttÃ¤jÃ¤ painaa jotain napeista<strong>+, -, Z</strong> syÃ¶tekenttÃ¤ tyhjenee.</li>
<li>Jos syÃ¶tekenttÃ¤ssÃ¤ oleva syÃ¶te ei ole kokonaisluku ja kÃ¤yttÃ¤jjÃ¤ painaa jotain napeista<strong>+, -, Z</strong> syÃ¶tekenttÃ¤ tyhjenee ja tuloskentÃ¤n tila ei muutu (paitsi napin ollessa <strong></strong>).</li>
</ul>
</div>

<h2>PiirtÃ¤minen</h2>

<p>Luokkaa <code>JPanel</code> kÃ¤ytetÃ¤Ã¤n <code>Container</code>-toiminnallisuuden lisÃ¤ksi usein piirtoalustana siten, ettÃ¤ kÃ¤yttÃ¤jÃ¤ perii luokan <code>JPanel</code> ja korvaa metodin <code>protected void paintComponent(Graphics graphics)</code>. KÃ¤yttÃ¶liittymÃ¤ kutsuu metodia <code>paintComponent</code> aina kun kÃ¤yttÃ¶liittymÃ¤komponentin sisÃ¤ltÃ¶ halutaan piirtÃ¤Ã¤ ruudulle. Metodi <code>paintComponent</code> saa kÃ¤yttÃ¶liittymÃ¤ltÃ¤ parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code> toteuttavan olion. Luodaan luokan <code>JPanel</code> perivÃ¤ luokka <code>Piirtoalusta</code>, joka korvaa <code>paintComponent</code>-metodin.</p>

<pre class="sh_java">
public class Piirtoalusta extends JPanel {

    public Piirtoalusta() {
        super.setBackground(Color.WHITE);
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
    }
}
</pre>

<p>YllÃ¤ oleva piirtoalusta ei sisÃ¤llÃ¤ konkreettista piirtÃ¤mistoiminnallisuutta. Asetamme konstruktorissa piirtoalustan taustan valkoiseksi kutsumalla ylÃ¤luokan metodia <code>setBackground</code>. Metodin <code>setBackGround</code> saa parametrina <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Color.html" target="_blank">Color</a></code>-luokan ilmentymÃ¤n. Luokka <code>Color</code> sisÃ¤ltÃ¤Ã¤ yleisimmÃ¤t vÃ¤rit luokkamuuttujina, esimerkiksi vÃ¤ri valkoinen lÃ¶ytyy luokkamuuttujasta <code>Color.WHITE</code>.</p>

<p>Korvattu <code>paintComponent</code> metodi kutsuu ylÃ¤luokan <code>paintComponent</code>-metodia eikÃ¤ tee muuta. LisÃ¤tÃ¤Ã¤n piirtoalusta seuraavaksi kÃ¤yttÃ¶liittymÃ¤luokan <code>luoKomponentit</code>-metodiin. KÃ¤ytÃ¤mme kappaleen <a href="#58">58. KÃ¤yttÃ¶liittymÃ¤t</a> alussa mÃ¤Ã¤riteltyÃ¤ kÃ¤yttÃ¶liittymÃ¤pohjaa.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        container.add(new Piirtoalusta());
    }
</pre>

<p>KÃ¤ynnistÃ¤essÃ¤mme kÃ¤yttÃ¶liittymÃ¤n nÃ¤emme tyhjÃ¤n ruudun, jonka taustavÃ¤ri on valkoinen. Alla olevan kÃ¤yttÃ¶liittymÃ¤n toivotuksi kooksi on asetettu <code>setPreferredSize</code>-metodilla 300, 300, ja sen otsikko on <code>"Piirtoalusta"</code>.</p>

    <p><img src="img-ohja/kali/piirtoalusta.png"/></p>

<p>Piirtoalustalle piirtÃ¤minen tapahtuu <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html" target="_blank">Graphics</a></code>-olion tarjoamien metodien avulla. Muokataan <code>Piirtoalusta</code>-luokan metodia <code>paintComponent</code> siten, ettÃ¤ siinÃ¤ piirretÃ¤Ã¤n kaksi suorakulmiota <code>Graphics</code>-olion tarjoaman metodin <code>fillRect</code> avulla.</p>

<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.fillRect(50, 80, 100, 50);
        graphics.fillRect(200, 20, 50, 200);
    }
</pre>

<p>Metodi <code>fillRect</code> saa parametrina suorakulmion <code>x</code>, ja <code>y</code> -koordinaatit, sekÃ¤ suorakulmion leveyden ja korkeuden tÃ¤ssÃ¤ jÃ¤rjestyksessÃ¤. YllÃ¤ siis piirretÃ¤Ã¤n ensin koordinaatista <code>(50, 80)</code> alkava 100 pikseliÃ¤ leveÃ¤ ja 50 pikseliÃ¤ korkea suorakulmio. TÃ¤mÃ¤n jÃ¤lkeen piirretÃ¤Ã¤n koordinaatista <code>(200, 20)</code> alkava 50 pikseliÃ¤ leveÃ¤ ja 100 pikseliÃ¤ korkea suorakulmio.</p>

<p>Kuten piirtotuloksesta huomaat, koordinaatisto ei toimi aivan kuten olemme tottuneet.</p>

    <p><img src="img-ohja/kali/piirtoalusta-suorakulmiot.png"/></p>

<p>Javan <code>Graphics</code>-olio (ja useiden muiden ohjelmointikielten kÃ¤yttÃ¶liittymÃ¤kirjastot) olettaa ettÃ¤ y-akselin arvo kasvaa alaspÃ¤in mennessÃ¤. Koordinaatiston origo, eli piste <code>(0, 0)</code> on piirrettÃ¤vÃ¤n alueen vasemmassa ylÃ¤kulmassa: Graphics-olio tietÃ¤Ã¤ aina kÃ¤yttÃ¶liittymÃ¤komponentin, johon piirretÃ¤Ã¤n, ja osaa sen perusteella pÃ¤Ã¤tellÃ¤ piirtotapahtuman sijainnin. KÃ¤yttÃ¶liittymÃ¤n origon sijainti selkeytyy seuraavalla ohjelmalla. PiirretÃ¤Ã¤n ensin pisteestÃ¤ (0, 0) lÃ¤htevÃ¤ 10 pikseliÃ¤ leveÃ¤ ja 200 pikseliÃ¤ korkea vihreÃ¤ suorakulmio. TÃ¤mÃ¤n jÃ¤lkeen piirretÃ¤Ã¤n pisteestÃ¤ (0, 0) lÃ¤htevÃ¤ 200 pikseliÃ¤ leveÃ¤ ja 10 pikseliÃ¤ korkea musta. Seuraavana piirrettÃ¤vÃ¤n kuvion vÃ¤ri mÃ¤Ã¤ritellÃ¤Ã¤n <code>Graphics</code>-oliolle metodilla <code>setColor</code>.</p>


<pre class="sh_java">
    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);

        graphics.setColor(Color.GREEN);
        graphics.fillRect(0, 0, 10, 200);
        graphics.setColor(Color.BLACK);
        graphics.fillRect(0, 0, 200, 10);
    }
</pre>

    <p><img src="img-ohja/kali/piirtoalusta-koordinaatisto.png"/></p>

<p>TÃ¤mÃ¤ koordinaatiston kÃ¤Ã¤nteisyys johtuu siitÃ¤, miten kÃ¤yttÃ¶liittymien kokoa muokataan. KÃ¤yttÃ¶liittymÃ¤n kokoa muutettaessa sitÃ¤ pienennetÃ¤Ã¤n tai suurennetaan "oikeasta alakulmasta vetÃ¤en", jolloin ruudulla nÃ¤kyvÃ¤ piirros siirtyy kokoa muuttaessa. Kun koordinaatisto alkaa vasemmasta ylÃ¤kulmasta, on piirroksen sijainti aina sama, mutta nÃ¤kyvÃ¤ osa muuttuu.</p>

<div class="tehtavat">

<h3>Piirtoalusta ja PiirtÃ¤minen</h3>

<p>TehtÃ¤vÃ¤pohjassa on valmiina kÃ¤yttÃ¶liittymÃ¤, johon on kytketty <code>JPanel</code>-luokan perivÃ¤ luokka <code>Piirtoalusta</code>. Muuta luokan <code>Piirtoalusta</code> metodin <code>paintComponent</code> toteutusta siten, ettÃ¤ se piirtÃ¤Ã¤ seuraavanlaisen kuvion. Saat kÃ¤yttÃ¤Ã¤ tehtÃ¤vÃ¤ssÃ¤ vain <code>graphics</code>-olion <code>fillRect</code>-metodia.</p>

<p><img src="img-ohja/smiley.gif"/></p>

<p>Huom! ÃlÃ¤ kÃ¤ytÃ¤ enempÃ¤Ã¤ kuin viittÃ¤ <code>fillRect</code>-kutsua. Kuvion ei tarvitse olla tÃ¤smÃ¤lleen samanlainen kuin yllÃ¤oleva, testit kertovat kun piirtÃ¤mÃ¤si kuva on tarpeeksi lÃ¤hellÃ¤ haluttua kuvaa.</p>

</div>

<p>Laajennetaan edellistÃ¤ esimerkkiÃ¤ siten, ettÃ¤ piirrÃ¤mme kÃ¤yttÃ¶liittymÃ¤ssÃ¤ erillisen hahmo-olion. Luodaan hahmon edustamiseen luokka <code>Hahmo</code>. Hahmolla on koordinaatteina ilmaistu sijainti, ja se piirretÃ¤Ã¤n ympyrÃ¤nÃ¤ jonka halkaisija on 10 pikseliÃ¤. Hahmon sijaintia voi muuttaa kutsumalla sen <code>siirry</code>-metodia.</p>

<pre class="sh_java">
import java.awt.Graphics;

public class Hahmo {

    private int x;
    private int y;

    public Hahmo(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public void siirry(int xmuutos, int ymuutos) {
        this.x += xmuutos;
        this.y += ymuutos;
    }

    public void piirra(Graphics graphics) {
        graphics.fillOval(x, y, 10, 10);
    }
}
</pre>

<p>Muutetaan piirtoalustaa siten, ettÃ¤ sille annetaan <code>Hahmo</code>-luokan ilmentymÃ¤ konstruktorin parametrina. Luokan <code>Piirtoalusta</code> metodi <code>paintComponent</code> ei itse piirrÃ¤ hahmoa, vaan delegoi piirtovastuun <code>Hahmo</code>-luokan ilmentymÃ¤lle.</p>

<pre class="sh_java">
import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;

public class Piirtoalusta extends JPanel {

    private Hahmo hahmo;

    public Piirtoalusta(Hahmo hahmo) {
        super.setBackground(Color.WHITE);
        this.hahmo = hahmo;
    }

    @Override
    protected void paintComponent(Graphics graphics) {
        super.paintComponent(graphics);
        hahmo.piirra(graphics);
    }
}
</pre>

<p>Annetaan hahmo myÃ¶s kÃ¤yttÃ¶liittymÃ¤lle parametrina. Hahmo on siis kÃ¤yttÃ¶liittymÃ¤stÃ¤ erillinen olio, joka vain halutaan piirtÃ¤Ã¤ kÃ¤yttÃ¶liittymÃ¤ssÃ¤. Oleelliset muutokset kÃ¤yttÃ¶liittymÃ¤luokassa ovat siis konstruktorin muuttaminen siten, ettÃ¤ se saa parametrina <code>Hahmo</code>-olion. TÃ¤mÃ¤n lisÃ¤ksi metodissa <code>luoKomponentit</code> annetaan <code>Hahmo</code>-luokan ilmentymÃ¤ parametrina luotavalle <code>Piirtoalusta</code>-oliolle.</p>

<pre class="sh_java">
public class Kayttoliittyma implements Runnable {

    private JFrame frame;
    private Hahmo hahmo;

    public Kayttoliittyma(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

// ...

    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);
    }
// ...
</pre>

<p>KÃ¤yttÃ¶liittymÃ¤n voi nyt kÃ¤ynnistÃ¤Ã¤ antamalla sen konstruktorille <code>Hahmo</code>-olion parametrina.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Hahmo(30, 30));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

    <p><img src="img-ohja/kali/piirtoalusta-hahmon-piirtaminen.png"/></p>

<p>YllÃ¤ olevassa kÃ¤yttÃ¶liittymÃ¤ssÃ¤ nÃ¤kyy huikea, pallonmuotoinen hahmo.</p>

<p>LisÃ¤tÃ¤Ã¤n seuraavaksi ohjelmaan hahmon siirtÃ¤mistoiminnallisuus. Haluamme liikuttaa hahmoa nÃ¤ppÃ¤imistÃ¶llÃ¤. Kun kÃ¤yttÃ¤jÃ¤ painaa nuolta vasemmalle, hahmon pitÃ¤isi siirtyÃ¤ vasemmalle. Oikealle osoittavaa nuolta painettaessa hahmon pitÃ¤isi siirtyÃ¤ oikealle. Tarvitsemme siis tapahtumankuuntelijan, joka kuuntelee nÃ¤ppÃ¤imistÃ¶Ã¤. Rajapinta <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> mÃ¤Ã¤rittelee nÃ¤ppÃ¤imistÃ¶nkuuntelijalta vaaditut toiminnallisuudet.</p>

<p>Rajapinta <code>KeyListener</code> vaatii metodien <code>keyPressed</code>, <code>keyReleased</code>, ja <code>keyTyped</code> toteuttamista. Olemme kiinnostuneita vain tapahtumasta, jossa nÃ¤ppÃ¤intÃ¤ painetaan, joten jÃ¤tÃ¤mme metodit <code>keyReleased</code> ja <code>keyTyped</code> tyhjiksi. Luodaan luokka <code>NappaimistonKuuntelija</code>, joka toteuttaa rajapinnan <code>KeyListener</code>. Luokka saa parametrina <code>Hahmo</code>-olion, jota tapahtumankÃ¤sittelijÃ¤n tulee liikuttaa.</p>

<pre class="sh_java">
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo) {
        this.hahmo = hahmo;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Metodi <code>keyPressed</code> saa kÃ¤yttÃ¶liittymÃ¤ltÃ¤ parametrina <code>KeyEvent</code>-luokan ilmentymÃ¤n. KeyEvent-oliolta saa tietoon painettuun nappiin liittyvÃ¤n numeron sen <code>getKeyCode()</code>-metodilla. Eri nÃ¤ppÃ¤imille on luokkamuuttujat <code>KeyEvent</code>-luokassa, esimerkiksi nuoli vasemmalle on <code>KeyEvent.VK_LEFT</code>.</p>

<p>Haluamme kuunnella kÃ¤yttÃ¶liittymÃ¤Ã¤n kohdistuvia nÃ¤ppÃ¤imen painalluksia (emme esimerkiksi ole kirjoittamassa tekstikenttÃ¤Ã¤n), joten lisÃ¤tÃ¤Ã¤n nÃ¤ppÃ¤imistÃ¶nkuuntelija <code>JFrame</code>-luokan ilmentymÃ¤lle. Muokataan kÃ¤yttÃ¶liittymÃ¤Ã¤mme siten, ettÃ¤ nÃ¤ppÃ¤imistÃ¶nkuuntelija lisÃ¤tÃ¤Ã¤n JFrame-oliolle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo));
    }
</pre>

<p>Nyt sovelluksemme kuuntelee nÃ¤ppÃ¤imistÃ¶ltÃ¤ tulleita painalluksia, ja ohjaa ne luokan <code>NappaimistonKuuntelija</code> ilmentymÃ¤lle.</p>

<p>Kokeillessamme kÃ¤yttÃ¶liittymÃ¤Ã¤ se ei kuitenkaan toimi: hahmo ei siirry ruudulla. MistÃ¤ tÃ¤ssÃ¤ oikein on kyse? Voimme tarkastaa ettÃ¤ nÃ¤ppÃ¤imistÃ¶n painallukset ohjautuvat <code>NappaimistonKuuntelija</code>-oliolle lisÃ¤Ã¤mÃ¤llÃ¤ <code>keyPressed</code>-metodin alkuun testitulostuksen.</p>

<pre class="sh_java">
    @Override
    public void keyPressed(KeyEvent e) {
        System.out.println("Nappia " + e.getKeyCode() +  " painettu.");

        // ...
</pre>

<p>KÃ¤ynnistÃ¤essÃ¤mme ohjelman ja painaessamme nÃ¤ppÃ¤imiÃ¤ nÃ¤emme konsolissa tulostuksen.</p>

<pre>
Nappia 39 painettu.
Nappia 37 painettu.
Nappia 40 painettu.
Nappia 38 painettu.
</pre>

<p>Huomaamme ettÃ¤ nÃ¤ppÃ¤imistÃ¶n kuuntelija toimii, mutta piirtoalusta ei pÃ¤ivity.</p>

<h3>Piirtoalustan uudelleenpiirtÃ¤minen</h3>

<p>KÃ¤yttÃ¶liittymÃ¤komponentit sisÃ¤ltÃ¤vÃ¤t yleensÃ¤ toiminnallisuuden komponentin ulkoasun uudelleenpiirtÃ¤miseen tarvittaessa. Esimerkiksi nappia painettaessa <code>JButton</code>-luokan ilmentymÃ¤ osaa piirtÃ¤Ã¤ napin "painettuna", jonka jÃ¤lkeen nappi piirretÃ¤Ã¤n taas normaalina. Toteuttamassamme piirtoalustassa ei ole valmista pÃ¤ivitystoiminnallisuutta, vaan meidÃ¤n tulee pyytÃ¤Ã¤ sitÃ¤ piirtÃ¤mÃ¤Ã¤n itsensÃ¤ uudelleen tarvittaessa.</p>

<p>Jokaisella <code>Component</code>-luokan aliluokalla on metodi <code>public void repaint()</code>, jonka kutsuminen pakottaa komponentin uudelleenpiirtÃ¤misen. Haluamme ettÃ¤ <code>Piirtoalusta</code>-olio piirretÃ¤Ã¤n uudestaan aina kun hahmoa siirretÃ¤Ã¤n. Hahmon siirtÃ¤minen tapahtuu luokassa <code>NappaimistonKuuntelija</code>, joten on loogista ettÃ¤ uudelleenpiirtokutsu tapahtuu myÃ¶s nÃ¤ppÃ¤imistÃ¶nkuuntelijassa.</p>

<p>Uudelleenpiirtokutsua varten nÃ¤ppÃ¤imistÃ¶nkuuntelija tarvitsee viitteen piirtoalustaan. Muutetaan luokkaa <code>NappaimistonKuuntelija</code> siten, ettÃ¤ se saa parametrinaan <code>Hahmo</code>-olion lisÃ¤ksi uudelleenpiirrettÃ¤vÃ¤n <code>Component</code>-olion. Kutsutaan <code>Component</code>-olion <code>repaint</code>-metodia jokaisen <code>keyPressed</code> tapahtuman lopussa.</p>

<pre class="sh_java">
import java.awt.Component;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class NappaimistonKuuntelija implements KeyListener {

    private Component component;
    private Hahmo hahmo;

    public NappaimistonKuuntelija(Hahmo hahmo, Component component) {
        this.hahmo = hahmo;
        this.component = component;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_LEFT) {
            hahmo.siirry(-5, 0);
        } else if (e.getKeyCode() == KeyEvent.VK_RIGHT) {
            hahmo.siirry(5, 0);
        }

        component.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void keyTyped(KeyEvent ke) {
    }
}
</pre>

<p>Muutetaan myÃ¶s <code>Kayttoliittyma</code>-luokan <code>luoKomponentit</code>-metodia siten, ettÃ¤ <code>Piirtoalusta</code>-luokan ilmentymÃ¤ annetaan parametrina nÃ¤ppÃ¤imistÃ¶nkuuntelijalle.</p>

<pre class="sh_java">
    private void luoKomponentit(Container container) {
        Piirtoalusta piirtoalusta = new Piirtoalusta(hahmo);
        container.add(piirtoalusta);

        frame.addKeyListener(new NappaimistonKuuntelija(hahmo, piirtoalusta));
    }
</pre>

<p>Nyt hahmon liikuttaminen myÃ¶s nÃ¤kyy kÃ¤yttÃ¶liittymÃ¤ssÃ¤. Aina kun kÃ¤yttÃ¤jÃ¤ painaa nÃ¤ppÃ¤imistÃ¶Ã¤, kÃ¤yttÃ¶liittymÃ¤Ã¤n liitetty nÃ¤ppÃ¤imistÃ¶nkuuntelija kÃ¤sittelee kutsun. Jokaisen kutsun lopuksi kutsutaan piirtoalustan <code>repaint</code>-metodia, joka aiheuttaa piirtoalustan uudelleenpiirtÃ¤misen.</p>

    <p><img src="img-ohja/kali/piirtoalusta-hahmo-liikkuu.png"/></p>

<div class="tehtavat">
<h3>Liikkuva kuvio</h3>

<p>Teemme ohjelman, jossa kÃ¤yttÃ¤jÃ¤ voi liikutella nÃ¤ppÃ¤imistÃ¶n avulla ruudulle piirrettyjÃ¤ kuvioita. Ohjelmassa tulee mukana kÃ¤yttÃ¶liittymÃ¤runko, jota pÃ¤Ã¤set muokkaamaan ohjelman edetessÃ¤.</p>

<p>Aluksi tehdÃ¤Ã¤n muutama luokka, joilla kuvioita hallitaan. PÃ¤Ã¤semme myÃ¶hemmin piirtÃ¤mÃ¤Ã¤n kuvioita ruudulle. Tee kaikki ohjelman luokat pakkaukseen <code>liikkuvakuvio</code>.</p>

<p>TehtÃ¤vÃ¤ssÃ¤ kÃ¤ytetÃ¤Ã¤n perintÃ¤Ã¤ ja abstrakteja luokkia. Kertaa siis tarvittaessa values 18.1, 18.2 ja 18.5</p></p>

<h4 class="req">Abstrakti luokka Kuvio</h4>

<p>Tee abstrakti luokka <code>Kuvio</code>. Kuviolla on oliomuuttujat <code>x</code> ja <code>y</code>, jotka kertovat kuvion sijainnin ruudulla sekÃ¤ metodi <code>public void siirra(int dx, int dy)</code>, jonka avulla kuvion sijainti siirtyy parametrina olevien koordinaattisiirtymien verran. Esim. jos sijainti aluksi on (100,100), niin kutsun <code>siirra(10,-50)</code> jÃ¤lkeen sijainti on (110, 50). Luokan konstruktorin <code>public Kuvio(int x, int y)</code> tulee asettaa kuviolle alkusijainti. LisÃ¤Ã¤ luokalle myÃ¶s metodit <code>public int getX()</code> ja <code>public int getY()</code>.</p>

<p>Luokalla tulee olla myÃ¶s abstrakti metodi <code>public abstract void piirra(Graphics graphics)</code>, jolla kuvio piirretÃ¤Ã¤n piirtoalustalle. Kuvion piirtÃ¤mismetodi toteutetaan luokan <code>Kuvio</code> perivissÃ¤ metodeissa.</p>

<h4 class="req">Ympyra</h4>

<p>Tee luokka <code>Ympyra</code> joka perii Kuvion. YmpyrÃ¤llÃ¤ on <code>halkaisija</code> jonka arvon konstruktori <code>public Ympyra(int x, int y, int halkaisija)</code>. Sijainti tallennetaan ylÃ¤luokassa mÃ¤Ã¤riteltyihin oliomuuttujiin. 
</p>

<p>
Ympyra mÃ¤Ã¤rittelee metodin <code>piirra</code> siten, ettÃ¤ oikean kokoinen ympyrÃ¤ piirretÃ¤Ã¤n koordinaattien osoittamaan paikkaan
parametrina olevan <code>Graphics</code>-olion <code>fillOval</code>-metodia kÃ¤yttÃ¤en, ympyrÃ¤n sijaintia tulee kÃ¤yttÃ¤Ã¤ metodin kahtena ensimmÃ¤isenÃ¤ parametrina. Ota mallia Hahmo-esimerkin vastaavasta metodista.
Graphics-olion metodien toimintaa kannattaa tutkia <a href="http://docs.oracle.com/javase/6/docs/api/java/awt/Graphics.html">Java API:sta.</a> 
</p>

<h4 class="req">Piirtoalusta</h4>

<p>Luo luokka <code>Piirtoalusta</code> joka perii luokan <code>JPanel</code>, mallia voit ottaa esimerkiksi edellisen tehtÃ¤vÃ¤n mukana tulleesta piirtoalustasta. Piirtoalusta saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. Korvaa luokan <code>JPanel</code> metodi <code>protected void paintComponent(Graphics g)</code> siten, ettÃ¤ siinÃ¤ kutsutaan ensin ylÃ¤luokan <code>paintComponent</code>-metodia ja sitten piirtoalustalle asetetun kuvion <code>piirra</code>-metodia.</p>

<p>Muokkaa luokkaa <code>Kayttoliittyma</code> siten, ettÃ¤ se saa konstruktorin parametrina <code>Kuvio</code>-tyyppisen olion. LisÃ¤Ã¤ kÃ¤yttÃ¶liittymÃ¤Ã¤n Piirtoalusta <code>luoKomponentit(Container container)</code>-metodissa, anna piirtoalustalle konstruktorin parametrina kÃ¤yttÃ¶liittymÃ¤lle annettu kuvio.</p>

<p>Testaa lopuksi ettÃ¤ seuraavalla esimerkkikoodilla ruudulle piirtyy ympyrÃ¤.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Ympyra(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-ympyra.png"/></p>



        <h4 class="req">NÃ¤ppÃ¤imistÃ¶ohjaus</h4>

<p>Laajennetaan piirtoalustaa siten, ettÃ¤ kuviota voi liikutella nuolinÃ¤ppÃ¤inten avulla. Luo rajapinnan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/awt/event/KeyListener.html" target="_blank">KeyListener</a></code> toteuttava luokka <code>NappaimistonKuuntelija</code>. Luokan <code>NappaimistonKuuntelija</code> konstruktorin parametrit ovat luokan <code>Component</code> ilmentymÃ¤ ja luokan <code>Kuvio</code> ilmentymÃ¤.</p>

<p>Luokan Component ilmentymÃ¤ annetaan nÃ¤ppÃ¤imistÃ¶nkuuntelijalle, jotta voimme pÃ¤ivittÃ¤Ã¤ halutun komponentin jokaisen nÃ¤ppÃ¤imenpainalluksen jÃ¤lkeen uudestaan. Komponentin pÃ¤ivittÃ¤minen tapahtuu kutsumalla <code>Component</code> luokasta perityvÃ¤Ã¤ metodia <code>repaint</code>. Luokka Piirtoalusta on tyyppiÃ¤ <code>Component</code> koska <code>Component</code> on luokan <code>JPanel</code> perivÃ¤n luokan ylÃ¤luokka.</p>

<p>Toteuta rajapinnan <code>KeyListener</code> mÃ¤Ã¤rittelemÃ¤ metodi <code>keyPressed(KeyEvent e)</code> siten, ettÃ¤ kÃ¤yttÃ¤jÃ¤n painaessa nuolta vasemmalle kuvio siirtyy yhden pykÃ¤lÃ¤n vasemmalle. Oikealle painettaessa yksi oikealle. YlÃ¶s painettaessa yksi ylÃ¶s, ja alas painettaessa yksi alas. Huomaa ettÃ¤ y-akseli kasvaa ikkunan ylÃ¤osasta alaspÃ¤in. NÃ¤ppÃ¤inkoodit nuolinÃ¤ppÃ¤imille ovat <code>KeyEvent.VK_LEFT</code>, <code>KeyEvent.VK_RIGHT</code>, <code>KeyEvent.VK_UP</code>, ja <code>KeyEvent.VK_DOWN</code>. JÃ¤tÃ¤ muut rajapinnan <code>KeyListener</code> vaatimat metodit tyhjiksi.</p>

<p>Kutsu aina Component-luokan <code>repaint</code>-metodia nÃ¤ppÃ¤imistÃ¶nkuuntelutapahtuman lopussa.</p>

<p>LisÃ¤Ã¤ nÃ¤ppÃ¤imistÃ¶nkuuntelija Kayttoliittyma-luokan <code>lisaaKuuntelijat</code>-metodissa. NÃ¤ppÃ¤imistÃ¶nkuuntelija tulee liittÃ¤Ã¤ <code>JFrame</code>-olioon.</p>


        <h4 class="req">Nelio ja Laatikko</h4>


<p>Peri luokasta <code>Kuvio</code> luokat <code>Nelio</code> ja <code>Laatikko</code>. NeliÃ¶llÃ¤ on konstruktori <code>public Nelio(int x, int y, int sivunPituus)</code>, laatikon konstruktori on muotoa <code>public Laatikko(int x, int y, int leveys, int korkeus)</code>. KÃ¤ytÃ¤ piirtÃ¤misessÃ¤ graphics-olion <code>fillRect</code>-metodia.</p>

<p>Varmista, ettÃ¤ neliÃ¶t ja laatikot piirtyvÃ¤t ja liikkuvat oikein Piirtoalustalla.</p>

<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Nelio(50, 50, 250));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-nelio.png"/></p>


<pre class="sh_java">
        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(new Laatikko(50, 50, 100, 300));
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-laatikko.png"/></p>

        <h4 class="req">Koostekuvio</h4>

        <p>Peri luokasta <code>Kuvio</code> luokka <code>Koostekuvio</code>. Koostekuvio sisÃ¤ltÃ¤Ã¤ joukon muita kuvioita jotka se tallettaa ArrayList:iin. Koostekuviolla on metodi <code>public void liita(Kuvio k)</code> jonka avulla koostekuvioon voi liittÃ¤Ã¤ kuvio-olion. Koostekuviolla ei ole omaa sijaintia ja ei ole merkitystÃ¤ mitÃ¤ koostekuvio asettaa perimiensÃ¤ x- ja y-koordinaatin arvoiksi. Koostekuvio piirtÃ¤Ã¤ itsensÃ¤ pyytÃ¤mÃ¤llÃ¤ osiaan piirtÃ¤mÃ¤Ã¤n itsensÃ¤, koostekuvion siirtyminen tapahtuu samoin. Kuviolta peritty metodi <code>siirra</code> on siis ylikirjoitettava!</p>

        <p>Testaa ettÃ¤ koostekuviosi piirtyy ja siirtyy oikein, esim. seuraavan koostekuvion avulla:</p>

<pre class="sh_java">
        Koostekuvio rekka = new Koostekuvio();

        rekka.liita(new Laatikko(220, 110, 75, 100));
        rekka.liita(new Laatikko(80, 120, 200, 100));
        rekka.liita(new Ympyra(100, 200, 50));
        rekka.liita(new Ympyra(220, 200, 50));

        Kayttoliittyma kayttoliittyma = new Kayttoliittyma(rekka);
        SwingUtilities.invokeLater(kayttoliittyma);
</pre>

<p><img src="img-ohja/kali/liikkuvakuvio-rekka.png"/></p>



        <p>Huomaa miten <b>olioiden vastuut</b> jakautuvat tehtÃ¤vÃ¤ssÃ¤. Jokainen Kuvio on vastuussa itsensÃ¤ piirtÃ¤misestÃ¤ ja siirtÃ¤misestÃ¤. Yksinkertaiset kuviot siirtyvÃ¤t kaikki samalla tavalla. Jokaisen yksinkertaisen kuvion on itse hoidettava piirtymisestÃ¤Ã¤n. Koostekuvio siirtÃ¤Ã¤ itsensÃ¤ pyytÃ¤mÃ¤llÃ¤ osiaan siirtymÃ¤Ã¤n, samoin hoituu koostekuvion piirtyminen. Piirtoalusta tuntee Kuvio-olion joka siis voi olla mikÃ¤ tahansa yksinkertainen kuvio tai koostekuvio, kaikki piirretÃ¤Ã¤n ja siirretÃ¤Ã¤n samalla tavalla. Piirtoalusta siis toimii samalla tavalla kuvion oikeasta tyypistÃ¤ huolimatta, piirtoalustan ei tarvitse tietÃ¤Ã¤ kuvion yksityiskohdista mitÃ¤Ã¤n. Kun piirtoalusta kutsuu kuvion metodia <code>piirra</code> tai <code>siirra</code> <b>polymorfismin</b> ansiosta kutsutuksi tulee kuvion todellista tyyppiÃ¤ vastaava metodi.</p>

        <p>Huomionarvoista tehtÃ¤vÃ¤ssÃ¤ on se, ettÃ¤ Koostekuvio voi sisÃ¤ltÃ¤Ã¤ mitÃ¤ tahansa Kuvio-olioita, siis myÃ¶s koostekuvioita! Luokkarakenne mahdollistaakin mielivaltaisen monimutkaisen kuvion muodostamisen ja kuvion siirtely ja piirtÃ¤minen tapahtuu aina tÃ¤smÃ¤lleen samalla tavalla.</p>

        <p>Luokkarakennetta on myÃ¶s helppo laajentaa, esim. perimÃ¤llÃ¤ Kuvio-luokasta uusia kuviotyyppejÃ¤: kolmio, piste, viiva, ym... Koostekuvio toimii ilman muutoksia myÃ¶s uusien kuviotyyppien kanssa, samoin piirtoalusta ja kÃ¤yttÃ¶liittymÃ¤.</p>

</div>


<h3>Valmiit sovelluskehykset</h3>

<p>Sovelluskehys on ohjelma, joka tarjoaa lÃ¤htÃ¶kohdan ja joukon palveluita jonkin erityisen sovelluksen toteuttamiseen. Yksi tapa laatia sovelluskehys on laatia valmiita palveluita tarjoava luokka, jonka pÃ¤Ã¤lle luokan perivÃ¤t luokat rakentavat erityisen sovelluksen. Sovelluskehykset ovat yleensÃ¤ hyvin laajoja, ja tarkoitettu johonkin tiettyyn tarkoitukseen, esimerkiksi pelien ohjelmointiin tai web-sovelluskehitykseen. Tutustutaan seuraavasti pikaisesti valmiin sovelluskirjaston kÃ¤yttÃ¶Ã¶n luomalla sovelluslogiikka Game of Life -pelille.</p>

<div class="tehtavat">
<h3>Game of Life</h3>

<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤sarjassa toteutetaan sovelluslogiikka Game of Life-pelille perimÃ¤llÃ¤ valmis sovellusrunko. Sovellusrunko on projektiin erikseen lisÃ¤tyssÃ¤ kirjastossa, joten sen lÃ¤hdekoodit eivÃ¤t ole nÃ¤htÃ¤vissÃ¤.</p>

<p><b>HUOM:</b> tehtÃ¤vÃ¤ ei ole erityisen vaikea, mutta tehtÃ¤vÃ¤nanto saattaa aluksi vaikuttaa sekavalta. Lue ohje tarkasti uudelleen tai kysy apua jos et pÃ¤Ã¤se alkuun. TehtÃ¤vÃ¤ kannattaa ehdottomasti tehdÃ¤, sillÃ¤ lopputulos on hieno!</p>

<p>Game of Life on matemaatikko John Conway'n kehittelemÃ¤ yksinkertainen "populaatiosimulaattori", kts. <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life</a>.</p>

<p>Game of Lifen sÃ¤Ã¤nnÃ¶t ovat seuraavat:</p>
<ul>
<li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
<li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elÃ¤Ã¤ seuraavaan iteraatioon eli kierrokseen.</li>
<li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
<li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu elÃ¤vÃ¤ksi.</li>
</ul>

<p>Abstrakti luokka <code>GameOfLifeAlusta</code> tarjoaa seuraavat toiminnot</p>
<ul>
  <li><b>public GameOfLifeAlusta(int leveys, int korkeus)</b> luo mÃ¤Ã¤ritellyn kokoisen pelialustan</li>
  <li><b>public boolean[][] getAlusta()</b> tarjoaa pÃ¤Ã¤syn pelialustaan, joka on totuusarvoista koostuva kaksiulotteinen taulukko &ndash; kuten metodin paluuarvosta voi havaita! Palaamme kaksiulotteiseen taulukkoon tarkemmin sitÃ¤ tarvitessamme.</li>
  <li><b>public int getLeveys()</b> palauttaa alustan leveyden</li>
  <li><b>public int getKorkeus()</b> palauttaa alustan korkeuden</li>
  <li><b>public void pelaaKierros()</b> simuloi pelikierroksen</li>
</ul>

<p>Luokassa <code>GameOfLifeAlusta</code> on lisÃ¤ksi mÃ¤Ã¤ritelty seuraavat abstraktit metodit, <b>jotka sinun tulee toteuttaa</b>.<p>

<ul>
  <li><b>public abstract void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) elÃ¤vÃ¤ksi eli asettaa sille arvon <i>true</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitÃ¤Ã¤n.</li>
  <li><b>public abstract void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i>. Jos koordinaatit ovat alustan ulkopuolella ei tapahdu mitÃ¤Ã¤n.</li>
  <li><b>public abstract boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
  <li><b>public abstract void alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b> alustaa kaikki alustan alkiot siten, ettÃ¤ kukin alkio on elÃ¤vÃ¤ todennÃ¤kÃ¶isyydellÃ¤ <i>todennakoisyysPisteelle.</i> TodennÃ¤kÃ¶isyys annetaan double-arvona suljetulla vÃ¤lillÃ¤ [0, 1]. Jos metodia kutsutaan arvolla 1, tulee jokaisen alkion olla elÃ¤vÃ¤. Jos taas todennÃ¤kÃ¶isyys on 0, tulee jokaisen alkion olla kuollut.</li>
  <li><b>public abstract int getElossaOlevienNaapurienLukumaara(int x, int y)</b> kertoo elossa olevien naapureiden lukumÃ¤Ã¤rÃ¤n solulle pisteessÃ¤ (x, y).</li>
  <li><b>public abstract void hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> hoitaa solun (x, y) Game of Life -sÃ¤Ã¤ntÃ¶jen mukaan.</li>
</ul>


<h4>GameOfLife-toteutus, vaihe 1</h4>

<p>Luo pakkaukseen <code>game</code> luokka <code>OmaAlusta</code>, joka perii pakkauksessa <code>gameoflife</code> olevan luokan <code>GameOfLifeAlusta</code>. Huomaa ettÃ¤ pakkausta <code>gameoflife</code> ei ole nÃ¤kyvillÃ¤ omassa projektissasi, vaan se tulee mukana luokkakirjastona. Toteuta luokalle <code>OmaAlusta</code> konstruktori <code>public OmaAlusta(int leveys, int korkeus)</code>, joka kutsuu ylÃ¤luokan konstruktoria annetuilla parametreilla:</p>

<pre class="sh_java">
import gameoflife.GameOfLifeAlusta;

public class OmaAlusta extends GameOfLifeAlusta {

    public OmaAlusta(int leveys, int korkeus) {
        super(leveys, korkeus);
    }

    // ..
</pre>

<p>Voit ensin korvata kaikki abstraktit metodit ei-abstrakteilla metodeilla, jotka eivÃ¤t kuitenkaan vielÃ¤ tee mitÃ¤Ã¤n jÃ¤rkevÃ¤Ã¤. Mutta koska ne eivÃ¤t ole abstrakteja, tÃ¤stÃ¤ luokasta voi luoda ilmentymiÃ¤, toisin kuin abstraktista luokasta GameOfLifeAlusta.</p>

<p>Toteuta seuraavat metodit</p>
<ul>
  <li><b>public void muutaElavaksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) elÃ¤vÃ¤ksi eli asettaa sille arvon <i>true</i></li>
  <li><b>public void muutaKuolleeksi(int x, int y)</b> muuttaa alkion koordinaatissa (x, y) kuolleeksi eli asettaa sille arvon <i>false</i></li>
  <li><b>public boolean onElossa(int x, int y)</b> kertoo onko koordinaatissa (x, y) oleva alkio elossa. Jos koordinaatit ovat alustan ulkopuolella, palautetaan <i>false.</i></li>
</ul>

<p><b>Vihje:</b> PÃ¤Ã¤set ylÃ¤luokassa olevaan kaksiulotteiseen taulukkoon kÃ¤siksi ylÃ¤luokan tarjoaman metodin <code>getAlusta()</code> avulla. Kaksiulotteisia taulukoita kÃ¤ytetÃ¤Ã¤n kuten yksiulotteisia taulukoita, mutta taulukoille annetaan kaksi indeksiÃ¤. EnsimmÃ¤inen indeksi kertoo leveyskohdan, toinen indeksi korkeuskohdan. Esimerkiksi seuraava ohjelmapÃ¤tkÃ¤ luo ensin 10 x 10 -kokoisen taulukon, ja tulostaa sitten taulukon indeksissÃ¤ 3, 1 olevan arvon.</p>

<pre class="sh_java">
boolean[][] arvot = new boolean[10][10];
System.out.println(arvot[3][1]);
</pre>

<p>Vastaavasti OmaAlusta-luokassa voidaan tulostaa ylÃ¤luokasta saadun taulukon arvo indeksissÃ¤ x, y seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
System.out.println(alusta[x][y]);
</pre>

<p>Ja indeksiin x,y voidaan asettaa esim. arvo true seuraavasti:</p>

<pre class="sh_java">
boolean[][] alusta = getAlusta();
alusta[x][y] = true;
</pre>

<p>Tai suoraan kÃ¤yttÃ¤mÃ¤ttÃ¤ apumuuttujaa:</p>

<pre class="sh_java">
getAlusta()[x][y] = true;    
</pre>


<p>Testaa toteutustasi seuraavalla testiohjelmalla.</p>
<pre class="sh_java">
package game;

import gameoflife.komentorivi.KomentoriviGameOfLife;

public class Main {
    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(7, 5);

        alusta.muutaElavaksi(2, 0);
        alusta.muutaElavaksi(4, 0);

        alusta.muutaElavaksi(3, 3);
        alusta.muutaKuolleeksi(3, 3);

        alusta.muutaElavaksi(0, 2);
        alusta.muutaElavaksi(1, 3);
        alusta.muutaElavaksi(2, 3);
        alusta.muutaElavaksi(3, 3);
        alusta.muutaElavaksi(4, 3);
        alusta.muutaElavaksi(5, 3);
        alusta.muutaElavaksi(6, 2);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
    }
}
</pre>
<p>

Tulostuksen pitÃ¤isi olla seuraavanlainen:

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

  X X

X     X
 XXXXX

Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>
<p>

<h4>GameOfLife-toteutus, vaihe 2</h4>

<p>Toteuta metodi <b>alustaSatunnaisetPisteet(double todennakoisyysPisteelle)</b>, joka alustaa kaikki alkiot siten, ettÃ¤ kukin alkio on elÃ¤vÃ¤ todennÃ¤kÃ¶isyydellÃ¤ <i>todennakoisyysPisteelle</i>. TodennÃ¤kÃ¶isyys annetaan metodille suljetulla vÃ¤lillÃ¤ [0, 1] olevana double-tyyppisenÃ¤ parametrina.</p>

<p>Testaa metodia. Arvolla 0.0 ei pitÃ¤isi olla yhtÃ¤Ã¤n elossa olevaa solua, arvolla 1.0 kaikkien solujen tulisi olla elossa (eli nÃ¤kyÃ¤ X-merkkisinÃ¤). Arvolla 0.5 noin puolet soluista on elÃ¤viÃ¤.</p>

<pre class="sh_java">
        OmaAlusta alusta = new OmaAlusta(3, 3);
        alusta.alustaSatunnaisetPisteet(1.0);

        KomentoriviGameOfLife gom = new KomentoriviGameOfLife(alusta);
        gom.pelaa();
</pre>

<pre>
Paina enter jatkaaksesi, muut lopettaa: &lt;enter&gt;

XXX
XXX
XXX
Paina enter jatkaaksesi, muut lopettaa: <font color="red">stop</font>
Kiitos!
</pre>


<h4>GameOfLife-toteutus, vaihe 3</h4>

<p>Toteuta metodi <b>getElossaOlevienNaapurienLukumaara(int x, int y),</b> joka laskee elossa olevien naapurien lukumÃ¤Ã¤rÃ¤n. KeskellÃ¤
taulukkoa olevalla solulla on yhteensÃ¤ kahdeksan naapuria, reunassa olevalla solulla 5, kulmassa olevalla 3. </p>

<p>Testaa metodia seuraavilla lauseilla (voit keksiÃ¤ myÃ¶s muita testitapauksia!):</p>

<pre class="sh_java">
OmaAlusta alusta = new OmaAlusta(7, 5);

alusta.muutaElavaksi(0, 1);
alusta.muutaElavaksi(1, 0);
alusta.muutaElavaksi(1, 2);
alusta.muutaElavaksi(2, 2);
alusta.muutaElavaksi(2, 1);

System.out.println("Elossa naapureita (0,0): " + alusta.getElossaOlevienNaapurienLukumaara(0, 0));
System.out.println("Elossa naapureita (1,1): " + alusta.getElossaOlevienNaapurienLukumaara(1, 1));
</pre>
<p>

Tulostuksen pitÃ¤isi olla seuraavanlainen:
<pre>
Elossa naapureita (0,0): 2
Elossa naapureita (1,1): 5
</pre>


<h4>GameOfLife-toteutus, vaihe 4</h4>

<p>JÃ¤ljellÃ¤ on vielÃ¤ metodin <b>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</b> toteuttaminen. GameOfLife-pelin sÃ¤Ã¤nnÃ¶thÃ¤n olivat seuraavat:</p>

<ul>
  <li>Jokainen elossa oleva solu, jolla on alle kaksi elossa olevaa naapuria kuolee.</li>
  <li>Jokainen elossa oleva solu, jolla on kaksi tai kolme elossa olevaa naapuria elÃ¤Ã¤ seuraavaan iteraatioon eli kierrokseen.</li>
  <li>Jokainen elossa oleva solu, jolla on yli kolme naapuria kuolee.</li>
  <li>Jokainen kuollut solu, jolla on tasan kolme elossa olevaa naapuria muuttuu elÃ¤vÃ¤ksi.</li>
</ul>

<p>Toteuta metodi <code>hoidaSolu(int x, int y, int elossaOleviaNaapureita)</code> yllÃ¤olevien sÃ¤Ã¤ntÃ¶jen mukaan. Kannattaa ohjelmoida ja testata yksi sÃ¤Ã¤ntÃ¶ kerrallaan!</p>

<p>Kun olet saanut kaikki valmiiksi, voit testata ohjelman toimintaa seuraavalla graafisella simulaattorilla.</p>

<pre class="sh_java">
package game;

import gameoflife.Simulaattori;

public class Main {

    public static void main(String[] args) {
        OmaAlusta alusta = new OmaAlusta(100, 100);
        alusta.alustaSatunnaisetPisteet(0.7);

        Simulaattori simulaattori = new Simulaattori(alusta);
        simulaattori.simuloi();
    }
}
</pre>

</div>

<div class="tyhja"></div>

<div class="viikkoraja">Viikko 6</div>

<h2>Muutamia hyÃ¶dyllisiÃ¤ tekniikoita</h2>

<p>Kurssin lÃ¤hestyessÃ¤ loppua katsomme vielÃ¤ muutamaa hyÃ¶dyllistÃ¤ Javan ominaisuutta.</p>

<h3>SÃ¤Ã¤nnÃ¶lliset lausekkeet</h3>

<p>SÃ¤Ã¤nnÃ¶llinen lauseke mÃ¤Ã¤rittelee tiiviissÃ¤ muodossa joukon characterStringja. SÃ¤Ã¤nnÃ¶llisiÃ¤ lausekkeita kÃ¤ytetÃ¤Ã¤n muunmuassa characterStringjen oikeellisuuden tarkistamiseen. Tarkastellaan tehtÃ¤vÃ¤Ã¤, jossa tÃ¤ytyy tarkistaa, onko kÃ¤yttÃ¤jÃ¤n antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa characterStringlla "01", jota seuraa 7 numeroa vÃ¤liltÃ¤ 0&ndash;9.</p>

<p>Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi kÃ¤ymÃ¤llÃ¤ opiskelijanumeroa esittÃ¤vÃ¤n characterStringn lÃ¤pi merkki merkiltÃ¤ <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa ettÃ¤ ensimmÃ¤inen merkki on "0", ja kÃ¤yttÃ¤Ã¤ <code>Integer.parseInt</code> metodikutsua characterStringn muuntamiseen numeroksi. TÃ¤mÃ¤n jÃ¤lkeen voisi tarkistaa ettÃ¤ <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.</p>

<p>Oikeellisuuden tarkistus sÃ¤Ã¤nnÃ¶llisten lausekkeiden avulla vaatii ensin sopivan sÃ¤Ã¤nnÃ¶llisen lausekkeen mÃ¤Ã¤rittelyn. TÃ¤mÃ¤n jÃ¤lkeen voimme kÃ¤yttÃ¤Ã¤ <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako characterString parametrina annettua sÃ¤Ã¤nnÃ¶llistÃ¤ lauseketta. Opiskelijanumeron tapauksessa sopiva sÃ¤Ã¤nnÃ¶llinen lauseke on <code>"01[0-9]{7}"</code>, ja kÃ¤yttÃ¤jÃ¤n syÃ¶ttÃ¤mÃ¤n opiskelijanumeron tarkistaminen kÃ¤y seuraavasti:</p>

<pre class="sh_java">
System.out.print("Anna opiskelijanumero: ");
String numero = reader.nextLine();

if (numero.matches("01[0-9]{7}")) {
    System.out.println("Muoto on oikea.");
} else {
    System.out.println("Muoto ei ole oikea.");
}
</pre>

<p>KÃ¤ydÃ¤Ã¤n seuraavaksi lÃ¤pi eniten kÃ¤ytettyjÃ¤ sÃ¤Ã¤nnÃ¶llisten lausekkeiden merkintÃ¶jÃ¤.</p>

<h4>Pystyviiva eli vaihtoehtoisuus</h4>

<p>Pystyviiva tarkoittaa, ettÃ¤ sÃ¤Ã¤nnÃ¶llisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> mÃ¤Ã¤rittelee characterStringt <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos characterString vastaa jotain mÃ¤Ã¤ritellyistÃ¤ vaihtoehdoista.</p>

<pre class="sh_java">
    String characterString = "00";
    
    if(characterString.matches("00|111|0000")) {
        System.out.println("characterStringsta lÃ¶ytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("characterStringsta ei lÃ¶ytynyt yhtÃ¤kÃ¤Ã¤n vaihtoehdoista");
    }
</pre>

<pre>
characterStringsta lÃ¶ytyi joku kolmesta vaihtoehdosta
</pre>

<p>SÃ¤Ã¤nnÃ¶llinen lauseke <code>00|111|0000</code> vaatii ettÃ¤ characterString on tÃ¤smÃ¤lleen mÃ¤Ã¤ritellyn muotoinen: se ei mÃ¤Ã¤rittele <em>"contains"</em>-toiminnallisuutta.</p>

<pre class="sh_java">
    String characterString = "1111";
    
    if(characterString.matches("00|111|0000")) {
        System.out.println("characterStringsta lÃ¶ytyi joku kolmesta vaihtoehdosta");
    } else {
        System.out.println("characterStringsta ei lÃ¶ytynyt yhtÃ¤kÃ¤Ã¤n vaihtoehdoista");
    }
</pre>

<pre>
characterStringsta ei lÃ¶ytynyt yhtÃ¤kÃ¤Ã¤n vaihtoehdoista
</pre>

<h4>Sulut, eli characterStringn osaan rajattu vaikutusalue</h4>

<p>Sulkujen avulla voi mÃ¤Ã¤rittÃ¤Ã¤, mihin sÃ¤Ã¤nnÃ¶llisen lausekkeen osaan sulkujen sisÃ¤llÃ¤ olevat merkinnÃ¤t vaikuttavat. Jos haluamme sallia characterStringt <code>00000</code> ja <code>00001</code>, voimme mÃ¤Ã¤ritellÃ¤ ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan characterStringa. Lauseke <code>0000(0|1)</code> mÃ¤Ã¤rittelee characterStringt <code>00000</code> ja <code>00001</code>.</p>

<p>Vastaavasti sÃ¤Ã¤nnÃ¶llinen lauseke <code>auto(|n|a)</code> mÃ¤Ã¤rittelee sanan auto yksikÃ¶n nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).</p>


<pre class="sh_java">
System.out.print("Kirjoita joku sanan auto yksikÃ¶n taivutusmuoto: ");
String sana = reader.nextLine();

if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
    System.out.println("Oikein meni!");
} else {
    System.out.println("Taivutusmuoto ei ole oikea.");
}
</pre>

<h4>ToistomerkinnÃ¤t</h4>

<p>Usein halutaan, ettÃ¤ characterStringssa toistuu jokin tietty alicharacterString. SÃ¤Ã¤nnÃ¶llisissÃ¤ lausekkeissa on kÃ¤ytÃ¶ssÃ¤ seuraavat toistomerkinnÃ¤t:</p>

<ul>
<li>MerkintÃ¤ <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "trolololololo";
    
    if(characterString.matches("trolo(lo)*")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>MerkintÃ¤ <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "trolololololo";
    
    if(characterString.matches("tro(lo)+")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>

<pre class="sh_java">
    String characterString = "nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤nÃ¤ BÃ¤tmÃ¤Ã¤n!";
    
    if(characterString.matches("(nÃ¤)+ BÃ¤tmÃ¤Ã¤n!")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>MerkintÃ¤ <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "You have to accidentally the whole meme";
    
    if(characterString.matches("You have to accidentally (delete )?the whole meme")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>MerkintÃ¤ <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "1010";
    
    if(characterString.matches("(10){2}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>

<li>MerkintÃ¤ <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "1";
    
    if(characterString.matches("1{2,4}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto ei ole oikea.
</pre>
</li>

<li>MerkintÃ¤ <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
<pre class="sh_java">
    String characterString = "11111";
    
    if(characterString.matches("1{2,}")) {
        System.out.println("Muoto on oikea.");
    } else {
        System.out.println("Muoto ei ole oikea.");
    }       
</pre>

<pre>
Muoto on oikea.
</pre>
</li>
</ul>

<p>Samassa sÃ¤Ã¤nnÃ¶llisessÃ¤ lausekkeessa voi kÃ¤yttÃ¤Ã¤ myÃ¶s useampia toistomerkintÃ¶jÃ¤. Esimerkiksi sÃ¤Ã¤nnÃ¶llinen lauseke <code>5{3}(1|0)*5{3}</code> mÃ¤Ã¤rittelee characterStringt, jotka alkavat ja loppuvat kolmella vitosella. VÃ¤lissÃ¤ saa tulla rajaton mÃ¤Ã¤rÃ¤ ykkÃ¶siÃ¤ ja nollia.</p>

<h4>Hakasulut, eli merkkiryhmÃ¤t</h4>

<p>MerkkiryhmÃ¤n avulla voi mÃ¤Ã¤ritellÃ¤ lyhyesti joukon merkkejÃ¤. Merkit kirjoitetaan hakasulkujen sisÃ¤Ã¤n, ja merkkivÃ¤lin voi mÃ¤Ã¤rittÃ¤Ã¤ viivan avulla. Esimerkiksi merkintÃ¤ <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintÃ¤ <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintÃ¤ <code>[a-c]*</code> mÃ¤Ã¤rittelee sÃ¤Ã¤nnÃ¶llisen lausekkeen, joka vaatii ettÃ¤ characterString sisÃ¤ltÃ¤Ã¤ vain merkkejÃ¤ <code>a</code>, <code>b</code> ja <code>c</code>.</p>

<div class="tehtavat">

<NEXTWEEK></NEXTWEEK>

<h3>SÃ¤Ã¤nnÃ¶lliset lausekkeet</h3>

<p>Harjoitellaan hieman sÃ¤Ã¤nnÃ¶llisten lausekkeiden kÃ¤yttÃ¶Ã¤. TehtÃ¤vÃ¤t tehdÃ¤Ã¤n oletuspakkauksessa olevaan luokkaan <code>MainProgram</code>.</h3>

<h4 class="req">ViikonpÃ¤ivÃ¤</h4>

<p>Tee sÃ¤Ã¤nnÃ¶llisen lausekkeen avulla luokalle <code>MainProgram</code> metodi <code>public static boolean onViikonpaiva(String characterString)</code>, joka palauttaa <code>true</code> jos sen parametrina saama characterString viikonpÃ¤ivÃ¤n lyhenne (ma, ti, ke, to, pe, la tai su).</p>

<p>Esimerkkitulostuksia metodia kÃ¤yttÃ¤vÃ¤stÃ¤ ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">ti</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<h4 class="req">Vokaalitarkistus</h4>

<p>Tee luokalle <code>MainProgram</code> metodi <code>public static boolean kaikkiVokaaleja(String characterString)</code> joka tarkistaa sÃ¤Ã¤nnÃ¶llisen lausekkeen avulla ovatko parametrina olevan characterStringn kaikki merkit vokaaleja. </p>

<p>Esimerkkitulostuksia metodia kÃ¤yttÃ¤vÃ¤stÃ¤ ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">aie</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">ane</font>
Muoto ei ole oikea.
</pre>

<h4 class="req">Kellonaika</h4>

<p>SÃ¤Ã¤nnÃ¶lliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja characterStringn "sopivuus" kannattaa tarkastaa muulla tyylillÃ¤ tai voi olla tarkoituksenmukaista kÃ¤yttÃ¤Ã¤ sÃ¤Ã¤nnÃ¶llisiÃ¤ lausekkeita vain osaan tarkastuksesta.</p>

<p>Tee luokalle <code>MainProgram</code> metodi <code>public static boolean kellonaika(String characterString)</code>  ohjelma, joka tarkistaa sÃ¤Ã¤nnÃ¶llisen lausekkeen avulla onko parametrina oleva characterString muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina). TÃ¤ssÃ¤ metodissa saat kÃ¤yttÃ¤Ã¤ sÃ¤Ã¤nnÃ¶llisten lausekkeiden lisÃ¤ksi mitÃ¤ tahansa muutakin tekniikkaa.</p>

<p>Esimerkkitulostuksia metodia kÃ¤yttÃ¤vÃ¤stÃ¤ ohjelmasta:</p>

<pre>
Anna characterString: <font color="red">17:23:05</font>
Muoto on oikea.
</pre>

<pre>
Anna characterString: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<pre>
Anna characterString: <font color="red">33:33:33</font>
Muoto ei ole oikea.
</pre>

</div>


<h3>Enum eli lueteltu tyyppi</h3>

<p>Toteutimme aiemmin pelikorttia mallintavan luokan <code>Kortti</code> suunilleen seuraavasti:</p>

<pre class="sh_java">
public class Kortti {

    public static final int RUUTU = 0;
    public static final int PATA = 1;
    public static final int RISTI = 2;
    public static final int HERTTA = 3;

    private int arvo;
    private int maa;

    public Kortti(int arvo, int maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maanNimi() + " "+arvo;
    }

    private String maanNimi() {
        if (maa == 0) {
            return "RUUTU";
        } else if (maa == 1) {
            return  "PATA";
        } else if (maa == 2) {
            return "RISTI";
        }
        return "HERTTA";
    }

    public int getMaa() {
        return maa;
    }
}
</pre>

<p>Kortin maa tallennetaan kortissa olevaan oliomuuttujaan kokonaislukuna. Maan ilmaisemiseen on mÃ¤Ã¤ritelty luettavuutta helpottavat vakiot. Kortteja ja maita ilmaisevia vakioita kÃ¤ytetÃ¤Ã¤n seuraavasti:</p>

<pre class="sh_java">
public static void main(String[] args) {
        Kortti kortti = new Kortti(10, Kortti.HERTTA);

        System.out.println(kortti);

        if (kortti.getMaa() == Kortti.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

}
</pre>

<p>Maan esittÃ¤minen numerona on huono ratkaisu, sillÃ¤ esimerkiksi seuraavat jÃ¤rjenvastaiset tavat kÃ¤yttÃ¤Ã¤ korttia ovat mahdollisia:</p>

<pre class="sh_java">
        Kortti jarjetonKortti = new Kortti(10, 55);

        System.out.println(jarjetonKortti);

        if (jarjetonKortti.getMaa() == 34) {
            System.out.println("kortin maa on 34");
        } else {
            System.out.println("kortin maa on jotain muuta kun 34");
        }

        int maaPotenssiinKaksi = jarjetonKortti.getMaa() * jarjetonKortti.getMaa();

        System.out.println("kortin maa potenssiin kaksi on " + maaPotenssiinKaksi);
</pre>

<p>Jos tiedÃ¤mme muuttujien mahdolliset arvot ennalta, voimme kÃ¤yttÃ¤Ã¤ niiden esittÃ¤miseen <code>enum</code>-tyyppistÃ¤ luokkaa eli <em>lueteltua tyyppiÃ¤</em>. Luetellut tyypit ovat oma luokkatyyppinsÃ¤ rajapinnan ja normaalin luokan lisÃ¤ksi. Lueteltu tyyppi mÃ¤Ã¤ritellÃ¤Ã¤n avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka mÃ¤Ã¤rittelee neljÃ¤ vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.</p>

<pre class="sh_java">
public enum Maa {
    RUUTU, PATA, RISTI, HERTTA
}
</pre>

<p>Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina mÃ¤Ã¤rittelemÃ¤nsÃ¤ vakioarvot. Enumien vakiot on yleensÃ¤ tapana kirjoittaa kokonaan isoin kirjaimin.</p>

<p>Enum luodaan (yleensÃ¤) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>. </p>

<p>Seuraavassa luokka <code>Kortti</code> jossa maa esitetÃ¤Ã¤n enumin avulla:</p>

<pre class="sh_java">
public class Kortti {

    private int arvo;
    private Maa maa;

    public Kortti(int arvo, Maa maa) {
        this.arvo = arvo;
        this.maa = maa;
    }

    @Override
    public String toString() {
        return maa + " "+arvo;
    }

    public Maa getMaa() {
        return maa;
    }

    public int getArvo() {
        return arvo;
    }
}
</pre>

<p>Kortin uutta versiota kÃ¤ytetÃ¤Ã¤n seuraavasti:</p>

<pre class="sh_java">
public class MainProgram {

    public static void main(String[] args) {
        Kortti eka = new Kortti(10, Maa.HERTTA);

        System.out.println(eka);

        if (eka.getMaa() == Maa.PATA) {
            System.out.println("on pata");
        } else {
            System.out.println("ei ole pata");
        }

    }
}
</pre>

<p>Tulostuu:</p>

<pre>
HERTTA 10
ei ole pata
</pre>

<p>Huomaamme, ettÃ¤ enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiÃ¤ <code>Maa</code> ei ylemmÃ¤n esimerkin "jÃ¤rjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvÃ¤ sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.</p>

<h3>Iteraattori</h3>

<p>Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssÃ¤ korttipelissÃ¤ pelaajan kÃ¤dessÃ¤ olevien korttien joukkoa:</p>

<pre class="sh_java">
public class Kasi {
    private ArrayList&lt;Kortti&gt; kortit;

    public Kasi() {
        kortit = new ArrayList&lt;Kortti&gt;();
    }

    public void lisaa(Kortti kortti){
        kortit.add(kortti);
    }

    public void tulosta(){
        for (Kortti kortti : kortit) {
            System.out.println( kortti );
        }
    }
}
</pre>

<p>Luokan metodi <code>tulosta</code> tulostaa jokaisen kÃ¤dessÃ¤ olevan kortin tutuksi tullutta "for each"-lausetta kÃ¤yttÃ¤mÃ¤llÃ¤. ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosÃ¤iliÃ¶t" toteuttavat rajapinnan <em>Iterable</em>. Rajapinnan <em>Iterable</em> toteuttavat oliot on mahdollista kÃ¤ydÃ¤ lÃ¤pi eli "iteroida" esimerkiksi. for each -tyyppisellÃ¤ komennolla.</p>

<p>OliosÃ¤iliÃ¶ voidaan kÃ¤ydÃ¤ lÃ¤pi myÃ¶s kÃ¤yttÃ¤en ns. <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman lÃ¤pikÃ¤yntiin. Seuraavassa on iteraattoria kÃ¤yttÃ¤vÃ¤ versio korttien tulostamisesta:</p>

<pre class="sh_java">
public void tulosta() {
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        System.out.println( iteraattori.next() );
    }
}
</pre>

<p>Iteraattori pyydetÃ¤Ã¤n kortteja sisÃ¤ltÃ¤vÃ¤ltÃ¤ arraylistiltÃ¤ <code>kortit</code>. Iteraattori on ikÃ¤Ã¤nkuin "sormi", joka osoittaa aina tiettyÃ¤ listan sisÃ¤llÃ¤ olevaa olioa, ensin ensimmÃ¤istÃ¤ ja sitten seuraavaa jne... kunnes "sormen" avulla on kÃ¤yty jokainen olio lÃ¤pi.</p>

<p>Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytÃ¤Ã¤n onko lÃ¤pikÃ¤ytÃ¤viÃ¤ olioita vielÃ¤ jÃ¤ljellÃ¤. Jos on, voidaan iteraattorilta pyytÃ¤Ã¤ seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana lÃ¤pikÃ¤yntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa lÃ¤pikÃ¤ytÃ¤vÃ¤Ã¤ olioa.</p>

<p>Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myÃ¶s muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myÃ¶s seuraavasti:</p>

<pre class="sh_java">
public void tulosta(){
    Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

    while ( iteraattori.hasNext() ){
        Kortti seuraavanaVuorossa = iteraattori.next();
        System.out.println( seuraavanaVuorossa );
    }
}
</pre>

<p>Teemme metodin jonka avulla kÃ¤destÃ¤ voi poistaa tiettyÃ¤ arvoa pienemmÃ¤t kortit:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        for (Kortti kortti : kortit) {
            if ( kortti.getArvo() &lt; arvo ) {
                kortit.remove(kortti);
            }
        }
    }
}
</pre>

<p>Huomaamme ettÃ¤ metodin suoritus aiheuttaa kummallisen virheen:</p>

<pre>
Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
        at java.util.AbstractList$Itr.next(AbstractList.java:343)
        at Kasi.poistaHuonommat(Kasi.java:26)
        at MainProgram.main(MainProgram.java:20)
Java Result: 1
</pre>

<p>Virheen syynÃ¤ on se, ettÃ¤ for-each:illa listaa lÃ¤pikÃ¤ydessÃ¤ ei ole sallittua poistaa listalta olioita: komento for-each menee tÃ¤stÃ¤ "sekaisin".</p>

<p>Jos listalta halutaan poistaa osa olioista lÃ¤pikÃ¤ynnin aikana osa, tulee tÃ¤mÃ¤ tehdÃ¤ iteraattoria kÃ¤yttÃ¤en. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellÃ¤ metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:</p>

<pre class="sh_java">
public class Kasi {
    // ...

    public void poistaHuonommat(int arvo) {
        Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

        while (iteraattori.hasNext()) {
            if (iteraattori.next().getArvo() &lt; arvo) {
                // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
                iteraattori.remove();   
            }
        }
    }
}
</pre>


<div class="tehtavat">

<h3>Enum ja Iteraattori</h3>

<p>TehdÃ¤Ã¤n ohjelma pienen yrityksen henkilÃ¶stÃ¶n hallintaan.</p>

<h4>Koulutus</h4>

<p>Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).</p>

<h4>Person</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Person</code>. HenkilÃ¶lle annetaan konstruktorin parametrina annettava nimi ja koulutus. HenkilÃ¶llÃ¤ on myÃ¶s koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekÃ¤ alla olevan esimerkin mukaista jÃ¤lkeÃ¤ tekevÃ¤ <code>toString</code>-metodi.</p>

<pre class="sh_java">
    Person arto = new Person("Arto", Koulutus.FT);
    System.out.println(arto);
</pre>

<pre>
Arto, FT
</pre>


<h4>Tyontekijat</h4>

<p>Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. TyÃ¶ntekijÃ¤t-olio sisÃ¤ltÃ¤Ã¤ listan Person-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:</p>

<ul>
  <li><code>public void lisaa(Person lisattava)</code> lisÃ¤Ã¤ parametrina olevan henkilÃ¶n tyÃ¶ntekijÃ¤ksi</li>
  <li><code>public void lisaa(List&lt;Person&gt; lisattavat)</code> lisÃ¤Ã¤ parametrina olevan listan henkilÃ¶itÃ¤ tyÃ¶ntekijÃ¶iksi</li>
  <li><code>public void tulosta()</code> tulostaa kaikki tyÃ¶ntekijÃ¤t</li>
  <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa tyÃ¶ntekijÃ¤t joiden koulutus on sama kuin parametrissa mÃ¤Ã¤ritelty koulutus</li>
</ul>

<p><strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria kÃ¤yttÃ¤en!</p>

<h4>Irtisanominen</h4>

<p>Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa TyÃ¶ntekijÃ¶iden joukosta kaikki henkilÃ¶t joiden koulutus on sama kuin metodin parametrina annettu.</p>

<p><strong>HUOM:</strong> toteuta metodi iteraattoria kÃ¤yttÃ¤en!</p>

<p>Seuraavassa esimerkki luokan kÃ¤ytÃ¶stÃ¤:</p>

<pre class="sh_java">
Public class MainProgram {

    public static void main(String[] args) {
        Tyontekijat yliopisto = new Tyontekijat();
        yliopisto.lisaa(new Person("Matti", Koulutus.FT));
        yliopisto.lisaa(new Person("Pekka", Koulutus.FilYO));
        yliopisto.lisaa(new Person("Arto", Koulutus.FT));

        yliopisto.tulosta();

        yliopisto.irtisano(Koulutus.FilYO);

        System.out.println("==");

        yliopisto.tulosta();
}
</pre>

<p>Tulostuu:</p>

<pre>
Matti, FT
Pekka, FilYO
Arto, FT
==
Matti, FT
Arto, FT
</pre>

</div>

<h3>Toistolauseet ja continue</h3>

<p>Toistolauseissa on komennon <code>break</code> lisÃ¤ksi kÃ¤ytÃ¶ssÃ¤ komento <code>continue</code>, joka mahdollistaa seuraavaan toistokierrokseen hyppÃ¤Ã¤misen.</p>

<pre class="sh_java">
    List&lt;String&gt; nimet = Arrays.asList("Matti", "Pekka", "Arto");
    
    for(String name: nimet) {
        if (nimi.equals("Arto")) {
            continue;
        }

        System.out.println(nimi);
    }
</pre>

<pre>
Matti
Pekka
</pre>

<p>Komentoa <code>continue</code> kÃ¤ytetÃ¤Ã¤n esimerkiksi silloin, kun tiedetÃ¤Ã¤n ettÃ¤ toistolauseessa iteroitavilla muuttujilla on arvoja, joita ei haluta kÃ¤sitellÃ¤ lainkaan. Klassinen lÃ¤hestymistapa olisi if-lauseen kÃ¤yttÃ¶, mutta komento <code>continue</code> mahdollistaa sisennyksiÃ¤ vÃ¤lttÃ¤vÃ¤n, ja samalla ehkÃ¤ luettavamman lÃ¤hestymistavan kÃ¤siteltÃ¤vien arvojen vÃ¤lttÃ¤miseen. Alla on kaksi esimerkkiÃ¤, jossa kÃ¤ydÃ¤Ã¤n listalla olevia lukuja lÃ¤pi. Jos luku on alle 5, se on jaollinen sadalla, tai se on jaollinen neljÃ¤llÃ¤kymmenellÃ¤, niin sitÃ¤ ei tulosteta, muulloin se tulostetaan. </p>

<pre class="sh_java">
    List&lt;Integer&gt; values = Arrays.asList(1, 3, 11, 6, 120);
    
    for(int luku: values) {
        if (luku > 4 && luku % 100 != 0 && luku % 40 != 0) {
            System.out.println(luku);
        }
    }

    for(int luku: values) {
        if (luku &lt; 5) {
            continue;
        }

        if (luku % 100 == 0) {
            continue;
        }

        if (luku % 40 == 0) {
            continue;
        }
        
        System.out.println(luku);
    }
</pre>

<pre>
11
6
11
6
</pre>

<h3>LisÃ¤Ã¤ enumeista</h3>

<p>Luodaan seuraavaksi lueteltuja tyyppejÃ¤ jotka sisÃ¤ltÃ¤vÃ¤t oliomuuttujia ja toteuttavat rajapinnan.</p>

<h4>Luetellun tyypin konstruktorin parametrit</h4>

<p>Luetellut tyypit voivat sisÃ¤ltÃ¤Ã¤ oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin mÃ¤Ã¤rittelevÃ¤n luokan sisÃ¤isessÃ¤ konstruktorissa. Enum-tyyppisillÃ¤ luokilla ei saa olla <code>public</code>-konstruktoria.</p>

<pre class="sh_java">
public enum Vari {
    PUNAINEN("punainen"), // konstruktorin parametrit mÃ¤Ã¤ritellÃ¤Ã¤n vakioarvoja lueteltaessa
    VIHREA("vihreÃ¤"),
    SININEN("sininen");

    private String name; // oliomuuttuja

    private Vari(String name) { // konstruktori
        this.name = nimi;
    }

    public String getName() {
        return this.name;
    }
}  
</pre>

<p>Lueteltua tyyppiÃ¤ <code>Vari</code> voidaan kÃ¤yttÃ¤Ã¤ esimerkiksi seuraavasti:</p>
<pre class="sh_java">
    System.out.println(Vari.VIHREA.getName());
</pre>

<pre>
vihreÃ¤
</pre>


<div class="tehtavat">

<h3>Elokuvien suosittelija</h3>

<p>Hiljattain Suomeen rantautunut <a href="https://signup.netflix.com/" target="_blank">Netflix</a> lupasi lokakuussa 2006 miljoona dollaria henkilÃ¶lle tai ryhmÃ¤lle, joka kehittÃ¤isi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heidÃ¤n oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank">http://www.netflixprize.com/</a>).</p>

<p>Rakennetaan tÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemÃ¤Ã¤");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + 
            suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + 
            suosittelija.suositteleElokuva(mikke));
</pre>

<pre>
Thomas suositus: Hiljaiset sillat
Mikke suositus: Tuulen viemÃ¤Ã¤
</pre>

<p>Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sekÃ¤ henkilÃ¶kohtaisten henkilÃ¶n antaminen arvioiden perusteella. LÃ¤hdetÃ¤Ã¤n rakentamaan ohjelmaa.</p>

<h4>Person ja Elokuva</h4>

<p>Luo pakkaus <code>suosittelija.domain</code> ja lisÃ¤Ã¤ sinne luokat <code>Person</code> ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String name)</code>, sekÃ¤ metodi <code>public String getName()</code>, joka palauttaa konstruktorissa saadun nimen.</p>

<pre class="sh_java">
    Person henkilo = new Person("Pekka");
    Elokuva elokuva = new Elokuva("Eraserhead");

    System.out.println(henkilo.getName() + " ja " + elokuva.getName());
</pre>

<pre>
Pekka ja Eraserhead
</pre>

<p>LisÃ¤Ã¤ luokille myÃ¶s <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sekÃ¤ korvaa metodit <code>equals</code> ja <code>hashCode</code>.</p>

<p>
Korvaa <code>equals</code> siten ettÃ¤ samuusvertailu tapahtuu oliomuuttujan <code>nimi</code> perusteella. Katso mallia luvusta 45.1. Luvussa 45.2. on ohje metodin <code>hashCode</code> korvaamiselle. Ainakin HashCode kannattaa generoida automaattisesti luvun lopussa olevan ohjeen mukaan:</p> 

<p>
<em>
NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta equals() and hashCode(). TÃ¤mÃ¤n jÃ¤lkeen NetBeans kysyy oliomuuttujat joita metodeissa kÃ¤ytetÃ¤Ã¤n.</em>
</p>

<p><strong>Huom:</strong> virheiden etsimisen helpottamiseksi kannattaa ehkÃ¤ toteuttaa henkilÃ¶lle ja elokuvalle toString-metodit. Testit eivÃ¤t niitÃ¤ vaadi.</p>

<h4>Arvio</h4>

<p>Luo pakkaukseen <code>suosittelija.domain</code> lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code> on julkinen metodi <code>public int getArvo()</code>, joka palauttaa arvioon liittyvÃ¤n arvon. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:</p>

<p>
<table style="padding-left:2em">
  <tr><th>Tunnus</th><th>Arvo</th></tr>
  <tr><td>HUONO</td><td>-5</td></tr>
  <tr><td>VALTTAVA</td><td>-3</td></tr>
  <tr><td>EI_NAHNYT</td><td>0</td></tr>
  <tr><td>NEUTRAALI</td><td>1</td></tr>
  <tr><td>OK</td><td>3</td></tr>
  <tr><td>HYVA</td><td>5</td></tr>
</table>
</p>

<p>Luokkaa voi kÃ¤yttÃ¤Ã¤ seuraavasti:</p>
<pre class="sh_java">
    Arvio annettu = Arvio.HYVA;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
    annettu = Arvio.NEUTRAALI;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
</pre>

<pre>
Arvio HYVA, arvo 5
Arvio NEUTRAALI, arvo 1
</pre>

<h4>ArvioRekisteri, osa 1</h4>

<p>Aloitetaan arvioiden varastointiin liittyvÃ¤n palvelun toteutus.</p>

<p>Luo pakkaukseen <code>suosittelija</code> luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code> sekÃ¤ seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code> lisÃ¤Ã¤ arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
  <li><code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code> palauttaa elokuvalle lisÃ¤tyt arviot listana.</li>
  <li><code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code> palauttaa mapin, joka sisÃ¤ltÃ¤Ã¤ arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sisÃ¤ltÃ¤Ã¤ elokuvaan lisatyt arviot.</li>
</ul>

<p>Testaa metodien toimintaa seuraavalla lÃ¤hdekoodilla:</p>

<pre class="sh_java">
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    ArvioRekisteri rekisteri = new ArvioRekisteri();
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

    System.out.println("Kaikki arviot: " + rekisteri.elokuvienArviot());
    System.out.println("Arviot Eraserheadille: " + rekisteri.annaArviot(eraserhead));
</pre>

<pre>
Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
Arviot Eraserheadille: [HUONO, HUONO, HYVA]
</pre>


<h4>ArvioRekisteri, osa 2</h4>

<p>LisÃ¤tÃ¤Ã¤n seuraavaksi mahdollisuus henkilÃ¶kohtaisten arvioiden lisÃ¤Ã¤iseen.</p>

<p>LisÃ¤Ã¤ luokkaan <code>ArvioRekisteri</code> seuraavat metodit:</p>

<ul>
  <li><code>public void lisaaArvio(Person henkilo, Elokuva elokuva, Arvio arvio)</code> lisÃ¤Ã¤ parametrina annetulle elokuvalle tietyn henkilÃ¶n tekemÃ¤n arvion. Sama henkilÃ¶ voi arvioida tietyn elokuvan vain kertaalleen. HenkilÃ¶n tekemÃ¤ arvio tulee myÃ¶s lisÃ¤tÃ¤ kaikkiin elokuviin liittyviin arvioihin.</li>
  <li><code>public Arvio haeArvio(Person henkilo, Elokuva elokuva)</code> palauttaa parametrina annetun henkilÃ¶n tekemÃ¤n arvion parametrina annetulle elokuvalle. Jos henkilÃ¶ ei ole arvioinut kyseistÃ¤ elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
 <li><code>public Map&lt;Elokuva, Arvio&gt; annaPersonnArviot(Person henkilo)</code> palauttaa hajautustaulun, joka sisÃ¤ltÃ¤Ã¤ henkilÃ¶n tekemÃ¤t arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyvÃ¤t arviot.</li> 
 <li><code>public List&lt;Person&gt; arvioijat()</code> palauttaa listan henkilÃ¶istÃ¤ jotka ovat arvioineet elokuvia.</li></ul>

<p>HenkilÃ¶iden tekemÃ¤t arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkilÃ¶. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.</p>

<p>Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla lÃ¤hdekoodipÃ¤tkÃ¤llÃ¤:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemÃ¤Ã¤");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

    System.out.println("Arviot Eraserheadille: " + arviot.annaArviot(eraserhead));
    System.out.println("Matin arviot: " + arviot.annaPersonnArviot(matti));
    System.out.println("Arvioijat: " + arviot.arvioijat());
</pre>

<pre>
Arviot Eraserheadille: [OK, OK]
Matin arviot: {Tuulen viemÃ¤Ã¤=HUONO, Eraserhead=OK}
Arvioijat: [Pekka, Matti]
</pre>

<p>Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.</p>

<h4>PersonComparator</h4>

<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>PersonComparator</code>. Luokan <code>PersonComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Person&gt;</code>, ja sillÃ¤ pitÃ¤Ã¤ olla konstruktori <code>public PersonComparator(Map&lt;Person, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>PersonComparator</code> kÃ¤ytetÃ¤Ã¤n myÃ¶hemmin henkilÃ¶iden jÃ¤rjestÃ¤miseen henkilÃ¶Ã¶n liittyvÃ¤n luvun perusteella.</p>

<p>PersonComparator-luokan tulee mahdollistaa henkilÃ¶iden jÃ¤rjestÃ¤minen henkilÃ¶Ã¶n liittyvÃ¤n luvun perusteella.</p>

<p>Testaa luokan toimintaa seuraavalla lÃ¤hdekoodilla:</p>

<pre class="sh_java">
    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");
    Person thomas = new Person("Thomas");

    Map&lt;Person, Integer&gt; henkiloidenSamuudet = new HashMap&lt;Person, Integer&gt;();
    henkiloidenSamuudet.put(matti, 42);
    henkiloidenSamuudet.put(pekka, 134);
    henkiloidenSamuudet.put(mikke, 8);
    henkiloidenSamuudet.put(thomas, 82);
    
    List&lt;Person&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("HenkilÃ¶t ennen jÃ¤rjestÃ¤mistÃ¤: " + henkilot);

    Collections.sort(henkilot, new PersonComparator(henkiloidenSamuudet));
    System.out.println("HenkilÃ¶t jÃ¤rjestÃ¤misen jÃ¤lkeen: " + henkilot);
</pre>

<pre>
HenkilÃ¶t ennen jÃ¤rjestÃ¤mistÃ¤: [Matti, Pekka, Mikke, Thomas]
HenkilÃ¶t jÃ¤rjestÃ¤misen jÃ¤lkeen: [Pekka, Thomas, Matti, Mikke]
</pre>

<h4>ElokuvaComparator</h4>


<p>Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sillÃ¤ pitÃ¤Ã¤ olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code> kÃ¤ytetÃ¤Ã¤n myÃ¶hemmin elokuvien jÃ¤rjestÃ¤miseen niiden arvioiden perusteella.</p>

<p>ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien jÃ¤rjestÃ¤minen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimmÃ¤isenÃ¤, matalimman keskiarvon saanut viimeisenÃ¤.</p>

<p>Testaa luokan toimintaa seuraavalla lÃ¤hdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemÃ¤Ã¤");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikke");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

    List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
    System.out.println("Elokuvat ennen jÃ¤rjestÃ¤mistÃ¤: " + elokuvat);

    Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
    System.out.println("Elokuvat jÃ¤rjestÃ¤misen jÃ¤lkeen: " + elokuvat);
</pre>

<pre>
Elokuvat ennen jÃ¤rjestÃ¤mistÃ¤: [Tuulen viemÃ¤Ã¤, Hiljaiset sillat, Eraserhead]
Elokuvat jÃ¤rjestÃ¤misen jÃ¤lkeen: [Hiljaiset sillat, Tuulen viemÃ¤Ã¤, Eraserhead]
</pre>


<h4>Suosittelija, osa 1</h4>

<p>Toteuta pakkaukseen <code>suosittelija</code> luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code> konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija kÃ¤yttÃ¤Ã¤ arviorekisterissÃ¤ olevia arvioita suositusten tekemiseen.</p>

<p>Toteuta luokalle metodi <code>public Elokuva suositteleElokuva(Person henkilo)</code>, joka suosittelee henkilÃ¶lle elokuvia.

Toteuta metodi ensin siten, ettÃ¤ se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvittÃ¤miseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code> metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sekÃ¤ listaa olemassaolevista elokuvista.</p>

<p>Testaa ohjelman toimimista seuraavalla lÃ¤hdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemÃ¤Ã¤");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
    System.out.println("Mikaelille suositeltu elokuva oli: " + suositeltu); 
</pre>

<pre>
Mikaelille suositeltu elokuva oli: Hiljaiset sillat
</pre>

<p>Nyt tekemÃ¤mme ensimmÃ¤inen vaihe toimii oikein ainoastaan henkilÃ¶ille, jotka eivÃ¤t ole vielÃ¤ arvostelleet yhtÃ¤Ã¤n elokuvaa. HeidÃ¤n elokuvamaustaanhan on mahdoton sanoa mitÃ¤Ã¤n ja paras arvaus on suositella heille keskimÃ¤Ã¤rin parhaan arvosanan saanutta elokuvaa. </p>

<h4>Suosittelija, osa 2</h4>

<p><em>Huom! TehtÃ¤vÃ¤ on haastava. Kannattaa tehdÃ¤ ensin muut tehtÃ¤vÃ¤t ja palata tÃ¤hÃ¤n myÃ¶hemmin. Voit palauttaa tehtÃ¤vÃ¤sarjan TMC:hen vaikket saakaan tÃ¤tÃ¤ tehtÃ¤vÃ¤Ã¤ tehdyksi, aivan kuten muidenkin tehtÃ¤vien kohdalla.</em></p>

<p>Valitettavasti tÃ¤mÃ¤n osan virhediagnostiikkakaan ei ole samaa luokkaa kuin edellisissÃ¤ kohdissa.</p>

<p>Jos henkilÃ¶t ovat lisÃ¤nneet omia suosituksia suosituspalveluun, tiedÃ¤mme jotain heidÃ¤n elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, ettÃ¤ se luo henkilÃ¶kohtaisen suosituksen jos henkilÃ¶ on jo arvioinut elokuvia. EdellisessÃ¤ osassa toteutettu toiminnallisuus tulee sÃ¤ilyttÃ¤Ã¤: Jos henkilÃ¶ ei ole arvioinut yhtÃ¤kÃ¤Ã¤n elokuvaa, hÃ¤nelle suositellaan elokuva arvosanojen perusteella.</p>

<p>HenkilÃ¶kohtaiset suositukset perustuvat henkilÃ¶n tekemien arvioiden samuuteen muiden henkilÃ¶iden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, missÃ¤ ylÃ¤rivillÃ¤ on elokuvat, ja vasemmalla on arvioita tehneet henkilÃ¶t. Taulukon solut kuvaavat annettuja arvioita.</p>

<p>
    <table style="padding-left:2em">
      <tr><th>Person \ Elokuva</th><td>Tuulen viemÃ¤Ã¤</td><td>Hiljaiset sillat</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
      <tr><td>Matti</td><td>HUONO (-5)</td><td>HYVA (5)</td><td>OK (3)</td><td>-</td></tr>
      <tr><td>Pekka</td><td>OK (3)</td><td>-</td><td>HUONO (-5)</td><td>VALTTAVA (-3)</td></tr>
      <tr><td>Mikael</td><td>-</td><td>-</td><td>HUONO (-5)</td><td>-</td></tr>
      <tr><td>Thomas</td><td>-</td><td>HYVA (5)</td><td>-</td><td>HYVA (5)</td></tr>
    </table>
</p>

<p>Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eivÃ¤t ole katsoneet yhtÃ¤kÃ¤Ã¤n samaa elokuvaa.</p>

<p>Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).</p>

<pre>
-5 * -5 = 25
</pre>

<p>Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat myÃ¶s katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).</p>

<pre>
-5 * 3 = -15
</pre>

<p>NÃ¤iden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viemÃ¤Ã¤.</p>


<p>Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteistÃ¤ elokuvaa. Matti antoi Tuulen viemÃ¤lle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.</p>

<pre>
-5 * 3 + 3 * -5 = -30
</pre>

<p>Matin ja Mikaelin samuus on edellisestÃ¤ laskusta tiedetty -15. Samuudet ovat symmetrisia.</p>

<p>Matti ja Thomas ovat katsoneet Tuulen viemÃ¤Ã¤, ja kumpikin antoi sille arvosanan hyvÃ¤ (5). Matin ja Thomaksen samuus on siis 25.</p>

<pre>
5 * 5 = 25
</pre>

<p>Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.</p>

<p>Toteuta yllÃ¤ kuvattu suosittelumekanismi. Jos henkilÃ¶lle ei lÃ¶ydy yhtÃ¤Ã¤n suositeltavaa elokuvaa, tai henkilÃ¶, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkilÃ¶ ei ole vielÃ¤ katsonut huonoiksi, vÃ¤lttÃ¤viksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code> arvo <code>null</code>. EdellisessÃ¤ tehtÃ¤vÃ¤ssÃ¤ mÃ¤Ã¤ritellyn lÃ¤hestymistavan tulee toimia jos henkilÃ¶ ei ole lisÃ¤nnyt yhtÃ¤kÃ¤Ã¤n arviota.</p>

<p>ÃlÃ¤ suosittele elokuvia, jonka henkilÃ¶ on jo nÃ¤hnyt.</p>

<p>Voit testata ohjelmasi toimintaa seuraavalla lÃ¤hdekoodilla:</p>

<pre class="sh_java">
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemÃ¤Ã¤");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");
    Elokuva bluesBrothers = new Elokuva("Blues Brothers");

    Person matti = new Person("Matti");
    Person pekka = new Person("Pekka");
    Person mikke = new Person("Mikael");
    Person thomas = new Person("Thomas");
    Person arto = new Person("Arto");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
    arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);
    
    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);
    
    arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
    arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
    System.out.println(matti + " suositus: " + suosittelija.suositteleElokuva(matti));
    System.out.println(arto + " suositus: " + suosittelija.suositteleElokuva(arto));
</pre>

<pre>
Thomas suositus: Eraserhead
Mikael suositus: Tuulen viemÃ¤Ã¤
Matti suositus: Blues Brothers
Arto suositus: Hiljaiset sillat
</pre>

<p>Miljoona kÃ¤sissÃ¤? Ei ehkÃ¤ vielÃ¤. Kursseilla Johdatus tekoÃ¤lyyn ja Johdatus koneoppimiseen opitaan lisÃ¤Ã¤ tekniikoita oppivien jÃ¤rjestelmien rakentamiseen.</p>

</div>

<h3>Vaihteleva mÃ¤Ã¤rÃ¤ parametreja metodille</h3>

<p>Olemme tÃ¤hÃ¤n mennessÃ¤ luoneet metodimme siten, ettÃ¤ niiden parametrien mÃ¤Ã¤rÃ¤t ovat olleet selkeÃ¤sti mÃ¤Ã¤ritelty. Java tarjoaa tavan antaa metodille rajoittamattoman mÃ¤Ã¤rÃ¤n mÃ¤Ã¤rÃ¤tyntyyppisiÃ¤ parametreja asettamalla metodimÃ¤Ã¤rittelyssÃ¤ parametrin tyypille kolme pistettÃ¤ perÃ¤Ã¤n. Esimerkiksi metodille <code>public int sum(int... values)</code> voi antaa summattavaksi niin monta <code>int</code>-tyyppistÃ¤ kokonaislukua kuin kÃ¤yttÃ¤jÃ¤ haluaa. Metodin sisÃ¤llÃ¤ parametrin arvoja voi kÃ¤sitellÃ¤ taulukkona.</p>

<pre class="sh_java">
    public int sum(int... values) {
        int sum = 0;
        for (int i = 0; i < values.length; i++) {
            summa += values[i];
        }
        return summa;
    }
</pre>

<pre class="sh_java">
    System.out.println(summa(3, 5, 7, 9));  // values = {3, 5, 7, 9}
    System.out.println(summa(1, 2));        // values = {1, 2}
</pre>

<pre>
24
3
</pre>

<p>Huomaa yllÃ¤ miten parametrimÃ¤Ã¤rittely <code>int... values</code> johtaa siihen, ettÃ¤ metodin sisÃ¤llÃ¤ nÃ¤kyy taulukkotyyppinen muuttuja <code>values</code>.</p>

<p>Metodille voi mÃ¤Ã¤ritellÃ¤ vain yhden parametrin joka saa rajattoman mÃ¤Ã¤rÃ¤n arvoja, ja sen tulee olla metodimÃ¤Ã¤rittelyn viimeinen parametri. Esimerkiksi:</p>

<pre class="sh_java">
    public void tulosta(String... characterStringt, int times) // ei sallittu!
    public void tulosta(int times, String... characterStringt) // sallittu!
</pre>

<p>Ennalta mÃ¤Ã¤rittelemÃ¤tÃ¶ntÃ¤ parametrien arvojen mÃ¤Ã¤rÃ¤Ã¤ kÃ¤ytetÃ¤Ã¤n esimerkiksi silloin, kun halutaan tarjota rajapinta, joka ei rajoita sen kÃ¤yttÃ¤jÃ¤Ã¤ tiettyyn parametrien mÃ¤Ã¤rÃ¤Ã¤n. Vaihtoehtoinen lÃ¤hestymistapa on metodimÃ¤Ã¤rittely, jolla on parametrina tietyn tyyppinen lista. TÃ¤llÃ¶in oliot voidaan asettaa listaan ennen metodikutsua, ja kutsua metodia antamalla lista sille parametrina.</p>

<div class="tehtavat">

<h3>JoustavatHakuehdot</h3>

<p>Muutamassa tehtÃ¤vÃ¤ssÃ¤ (mm. ohpen kirjasto ja ohjan sanatutkimus) tÃ¶rmÃ¤simme tilanteeseen jossa houduimme filtterÃ¶imÃ¤Ã¤n listasta olioita jotain hakuehtoa vastaavat oliot, esim. sanatutkimuksessa metodit <code>zSisaltava, lLoppuiset, palindromit, kaikkiVoksSis</code> tekivÃ¤t oleellisesti saman asian: kÃ¤vivÃ¤t lÃ¤pi tiedoston sisÃ¤llÃ¶n sana kerrallaan ja tarkastivat jokaisen sanan kohdalla pÃ¤teekÃ¶ sille tietty ehto ja jos pÃ¤tee, ottivat sanan talteen. Koska kaikkien metodien ehto oli erilainen, ei toisteisuutta tehtÃ¤vissÃ¤ osattu poistaa vaan kaikkien koodi oli ehtoa vaille "copypastea". </p>

<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ teemme ohjelman, jonka avulla on mahdollista fitlterÃ¶idÃ¤ rivejÃ¤ <a href="">Project Guttenbergin</a> sivuilta lÃ¶ytyvistÃ¤ kirjoista. Seuraavassa esimerkkinÃ¤ Dostojevskin Rikos ja rangaistus. Haluamme, ettÃ¤ erilaisia filtterÃ¶intiehtoja on monelaisia ja ettÃ¤ filtterÃ¶inti voi tapahtua myÃ¶s eri ehtojen kombinaationa. Ohjelman rakenteen pitÃ¤Ã¤ myÃ¶s mahdollistaa uusien ehtojen lisÃ¤Ã¤minen myÃ¶hemmin.</p>

<p>Sopiva ratkaisu tilanteeseen filtterÃ¶intiehtojen mÃ¤Ã¤ritteleminen omina rajapinnan <code>Ehto</code>toteuttavina olioina. Seuraavassa rajapinnan mÃ¤Ã¤ritelmÃ¤:</p>

<pre class="sh_java">
public interface Ehto {
    boolean toteutuu(String rivi);
}
</pre>

<p>Seuraavassa erÃ¤s rajapinnan toteuttava filtteriluokka:</p>

<pre class="sh_java">
public class SisaltaaSanan implements Ehto {

    String sana;

    public SisaltaaSanan(String sana) {
        this.sana = sana;
    }

    @Override
    public boolean toteutuu(String rivi) {
        return rivi.contains(sana);
    }    
}
</pre>

<p>Luokan oliot ovat siis hyvin yksinkertaisia, ne muistavat konstruktorin parametrina annetun sanan. Olion ainoalta metodilta voi kysyÃ¤ toteutuuko ehto parametrina olevalle characterStringlle, ja ehdon toteutuminen tarkoittaa olion tapauksessa sisÃ¤ltÃ¤Ã¤kÃ¶ characterString olion mustaman sanan.</p>

<p>TehtÃ¤vÃ¤pohjan mukana saat valmiina luokan <code>GutenbergLukija</code> jonka avulla voit tutkia kirjojen rivejÃ¤ filtterÃ¶itynÃ¤ parametrina annetun hakuehdon perusteella:</p>

<pre class="sh_java">
public class GutenbergLukija {

    private List&lg;String&gt; sanat;

    public GutenbergLukija(String osoite) throws IllegalArgumentException {
        // kirjan verkosta hakeva koodi
    }
    
    public List&lg;String&gt; rivitJoilleVoimassa(Ehto ehto){
        List&lg;String&gt; ehdonTayttavat = new ArrayList&lg;String&gt;();
        
        for (String rivi : sanat) {
            if ( ehto.toteutuu(rivi)) {
                ehdonTayttavat.add(rivi);
            }
        }
        
        return ehdonTayttavat;
    }
}
</pre>

<p>Seuraavassa tulostetaan Rikoksesta ja rangaistuksesta kaikki rivit joilla esiintyy sana "beer":</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new SisaltaaSanan("beer");
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>Kaikki sanat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>KaikkiRivit</code> joka kelpuuttaa jokaisen rivin.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new KaikkiRivit();
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>Loppuu huuto- tai kysymysmerkkiin</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>LoppuuHuutoTaiKysymysmerkkiin</code> joka kelpuuttaa ne rivit, joiden viimeinen merkki on huuto- tai kysymysmerkki.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new LoppuuHuutoTaiKysymysmerkkiin();
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p><strong>Muistutus:</strong> merkkien vertailu Javassa tapahtuu == operaattorilla:</p>

<pre class="sh_java">
String name = "pekka";

// HUOM: 'p' on merkki eli char p, "p" taas merkkojono jonka ainoa merkki on p
if ( nimi.charAt(0) == 'p' ) {
    System.out.println("alussa p");
} else {
    System.out.println("alussa jokin muu kuin p");
}
</pre>

<h4>Pituus vÃ¤hintÃ¤Ã¤</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>PituusVahintaan</code> joka oliot kelpuuttavat ne rivit, joiden pituus on vÃ¤hintÃ¤Ã¤n olion konstruktorin parametrina annettu luku.</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new PituusVahintaan(40);
        
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>molemmat</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Molemmat</code>. Luokan oliot saavat konstruktorin parametrina kaksi rajapinnan <code>Ehto</code> toteuttavaa olioa. Molemmat-olio kelpuuttavat ne rivit, jotka sen molemmat konstruktorissa saamat ehdot kelpuuttavat.
Seuraavassa tulostetaan kaikki huuto- tai kysymysmerkkiin loppuvat rivit jotka sisÃ¤ltÃ¤vÃ¤t sanan "beer".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Molemmat(
                    new LoppuuHuutoTaiKysymysmerkkiin(),
                    new SisaltaaSanan("beer")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>negaatio</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>Ei</code>. Luokan oliot saav parametrina rajapinna <code>Ehto</code> toteuttavaavan olioan. Ei-olio kelpuuttavat ne rivit, joita sen parametrina saama ehto ei kelpuuta.
Seuraavassa tulostetaan rivit, joiden pituus vÃ¤hemmÃ¤n kuin 10.
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new Ei( new PituusVahintaan(10) );
      
    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<h4>vÃ¤hintÃ¤Ã¤n yksi</h4>

<p>Tee rajapinnan <code>ehto</code> toteuttava luokka <code>VahintaanYksi</code>. Luokan oliot saavat konstruktorin parametrina mielivaltaisen mÃ¤Ã¤tÃ¤n rajapinnan <code>Ehto</code> toteuttavaa olioa, konstruktorissa siis kÃ¤ytetÃ¤vÃ¤ vaihtuvanmittaista parametrilistaa. VahintaanYksi-olio kelpuuttavat ne rivit, jotka vÃ¤hintÃ¤Ã¤n yksi sen konstruktoriparametrina saamista ehdoista kelpuuttaa. Seuraavassa tulostetaan rivit jotka sisÃ¤ltÃ¤vÃ¤t sanan jonkun sanoista "beer", "milk" tai "oil".
</p>

<pre class="sh_java">
public static void main(String[] args) {
    String osoite = "http://www.gutenberg.myebook.bg/2/5/5/2554/2554-8.txt";
    GutenbergLukija kirja = new GutenbergLukija(osoite);

    Ehto ehto = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    for (String rivi : kirja.rivitJoilleVoimassa(ehto)) {
        System.out.println(rivi);
    }
}
</pre>

<p>Huomaa, ettÃ¤ ehtoja voi kombinoida mielivaltaisesti. Seuraavassa ehto, joka hyvÃ¤ksyy rivit joilla on vÃ¤hintÃ¤Ã¤n yksi sanoista "beer", "milk" tai "oil" ja jotka ovat pituudeltaan 20-30 merkkiÃ¤.</p>

<pre class="sh_java">
    Ehto sanat = new VahintaanYksi(
                    new SisaltaaSanan("beer"),
                    new SisaltaaSanan("milk"),
                    new SisaltaaSanan("oil")
                );

    Ehto oikeaPituus = new Molemmat(
                         new PituusVahintaan(20),
                         new Ei( new PituusVahintaan(31)),
                       );

    Ehto halutut = new Molemmat(sanat, oikeaPituus);
</pre>

</div>

<h3>StringBuilder</h3>

<p>Olemme tottuneet rakentamaan characterStringja seuraavaan tapaan:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        int[] t = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(muotoile(t));
    }

    public static String muotoile(int[] t) {
        String mj = "{";

        for (int i = 0; i &lt; t.length; i++) {
            mj += t[i];
            if (i != t.length - 1) {
                mj += ", ";
        
            }
        }

        return mj + "}";
    }
</pre>

<p>Tulostus:</p>

<pre>
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
</pre>

<p>Tapa on toimiva mutta ei kovin tehokas. Kuten muistamme, characterStringt ovat <em>immutabeleja</em> eli olioita joita ei voi muuttaa. characterString-operaatioiden tuloksena onkin aina uusi characterString-olio. Eli edellisessÃ¤kin esimerkissÃ¤ syntyi vÃ¤livaiheena 10 characterString-olioa. Jos syÃ¶tteen koko olisi isompi, alkaisi vÃ¤livaiheena olevien olioiden luominen vaikuttaa ohjelman suoritusaikaan ikÃ¤vÃ¤llÃ¤ tavalla.</p>

<div class="tehtavat">
<h3>String builder</h3>

<p>Edellisen kaltaisissa tilanteissa onkin paremi kÃ¤yttÃ¤Ã¤ characterStringn muodostamisessa <code>StringBuilder</code>-olioita. Toisin kuin Stringint, StringBuilderit eivÃ¤t ole immutabeleja, ja yhtÃ¤ StringBuilderolioa voi muokata. Tutustu StringBuilderin API-kuvaukseen (lÃ¶ydÃ¤t sen esim googlaamalla stringbuilder java api 6) ja muuta tehtÃ¤vÃ¤pohjassa oleva metodi <code>public static String muotoile(int[] t)</code> toimimaan StringBuilderia kÃ¤yttÃ¤en seuraavaan tapaan:</p>

<pre>
{
 1, 2, 3, 4, 
 5, 6, 7, 8, 
 9, 10
}
</pre>

<p>Eli aaltosulkeet tulevat omalle rivilleen. Taulukon alkioita tulostetaan 4 per rivi ja rivin ensimmÃ¤istÃ¤ edeltÃ¤Ã¤ vÃ¤lilyÃ¶nti. Pilkun jÃ¤lkeen ennen seuraavaa numeroa tulee olla tasan yksi vÃ¤lilyÃ¶nti.</p>

</div>

<h2>Loppuhuipennus</h2>

<p>Kurssi alkaa olla ohi ja on loppuhuipennuksen aika!</p>

<div class="tehtavat">

<h3>Matopeli</h3>


<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ luodaan rakenteet ja osa toiminnallisuudesta seuraavannÃ¤kÃ¶iseen matopeliin.</p>

    <p><img src="img-ohja/kali/170-matopeli.png"/></p>

<h4>Pala ja Omena</h4>

<p>Luo pakkaukseen <code>matopeli.domain</code> luokka <code>Pala</code>. Luokalla <code>Pala</code> on konstruktori <code>public Pala(int x, int y)</code>, joka saa palan sijainnin parametrina. LisÃ¤ksi luokalla <code>Pala</code> on seuraavat metodit.</p>

<ul>
  <li><code>public int getX()</code> palauttaa Palan konstruktorissa saadun x-koordinaatin.</li>
  <li><code>public int getY()</code> palauttaa Palan konstruktorissa saadun y-koordinaatin.</li>
  <li><code>public boolean osuu(Pala pala)</code> palauttaa true jos oliolla on sama x- ja y-koordinaatti kuin parametrina saadulla Pala-luokan ilmentymÃ¤llÃ¤.</li>
  <li><code>public String toString()</code> palauttaa palan sijainnin muodossa <code>(x,y)</code>. Esim. <code>(5,2)</code> kun x-koordinaatin arvo on 5 ja y-koordinaatin arvo on 2.</li>
</ul>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> myÃ¶s luokka <code>Omena</code>. Peri luokalla Omena luokka <code>Pala</code>.</p>


<h4>Mato</h4>

<p>Toteuta pakkaukseen <code>matopeli.domain</code> luokka <code>Mato</code>. Luokalla <code>Mato</code> on konstruktori <code>public Mato(int alkuX, int alkuY, Suunta alkusuunta)</code>, joka luo uuden madon jonka suunta on parametrina annettu <code>alkusuunta</code>. Mato koostuu listasta <code>Pala</code>-luokan ilmentymiÃ¤. Huom: enum <code>Suunta</code> lÃ¶ytyy valmiina pakkauksesta <code>Matopeli</code>.</p>

<p>Mato luodaan yhden palan pituisena, mutta madon "aikuispituus" on kolme. Madon tulee kasvaa yhdellÃ¤ aina kun se liikkuu. Kun madon pituus on kolme, se kasvaa isommaksi vain syÃ¶dessÃ¤Ã¤n.</p>

<p>Toteuta madolle seuraavat metodit</p>

<ul>
  <li><code>public Suunta getSuunta()</code> palauttaa madon suunnan.</li>
  <li><code>public void setSuunta(Suunta suunta)</code> asettaa madolle uuden suunnan. Mato liikkuu uuteen suuntaan kun metodia <code>liiku</code> kutsutaan seuraavan kerran.</li>
  <li><code>public int getPituus()</code> palauttaa madon pituuden. Madon pituuden tulee olla sama kuin <code>getPalat()</code>-metodikutsun palauttaman listan alkioiden mÃ¤Ã¤rÃ¤.</li>
  <li><code>public List&lt;Pala&gt; getPalat()</code> palauttaa listan pala-olioita, joista mato koostuu. Palat ovat listalla jÃ¤rjestyksessÃ¤, siten ettÃ¤ pÃ¤Ã¤ sijaitsee listan lopussa.</li>
  <li><code>public void liiku()</code> liikuttaa matoa yhden palan verran eteenpÃ¤in.</li>
  <li><code>public void kasva()</code> kasvattaa madon kokoa yhdellÃ¤. Madon kasvaminen tapahtuu seuraavan <code>liiku</code>-metodikutsun yhteydessÃ¤. SitÃ¤ seuraaviin liiku-kutsuihin kasvaminen ei enÃ¤Ã¤ vaikuta.</li>
  <li><code>public boolean osuu(Pala pala)</code> tarkistaa osuuko mato parametrina annettuun palaan. Jos mato osuu palaan, eli joku madon pala osuu metodille parametrina annettuun palaan, tulee metodin palauttaa arvo <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
  <li><code>public boolean osuuItseensa()</code> tarkistaa osuuko mato itseensÃ¤. Jos mato osuu itseensÃ¤, eli joku sen pala osuu johonkin toiseen sen palaan, metodi palauttaa arvon <code>true</code>. Muuten metodi palauttaa arvon <code>false</code>.</li>
</ul>

<p>Metodien <code>public void kasva()</code> ja <code>public void liiku()</code> toiminnallisuus tulee toteuttaa siten, ettÃ¤ mato kasvaa vasta seuraavalla liikkumiskerralla.</p>

<p>Liikkuminen kannattaa toteuttaa siten, ettÃ¤ madolle luodaan liikkuessa aina uusi pala. Uuden palan sijainti riippuu madon kulkusuunnasta: vasemmalle mennessÃ¤ uuden palan sijainti on edellisen pÃ¤Ã¤palan sijainnista yksi vasemmalle, eli sen x-koordinaatti on yhtÃ¤ pienempi. Jos uuden palan sijainti on edellisen pÃ¤Ã¤palan alapuolella, eli madon suunta on alas, tulee uuden palan y-koordinaatin olla yhtÃ¤ isompi kuin pÃ¤Ã¤palan y-koordinaatti (kÃ¤ytÃ¤mme siis piirtÃ¤misestÃ¤ tuttua koordinaattijÃ¤rjestelmÃ¤Ã¤, jossa y-akseli on kÃ¤Ã¤ntynyt).</p>

<p>Liikkuessa uusi pala lisÃ¤tÃ¤Ã¤n listalle, ja viimeisin poistetaan listan lopusta. TÃ¤llÃ¶in jokaisen palan koordinaatteja ei tarvitse pÃ¤ivittÃ¤Ã¤ erikseen. Toteuta kasvaminen siten, ettÃ¤ palaa viimeisintÃ¤ palaa ei poisteta jos metodia <code>kasva</code> on juuri kutsuttu.</p>

<p>Huom! Kasvata matoa aina sen liikkuessa jos sen pituus on pienempi kuin 3.</p>

<pre class="sh_java">
        Mato mato = new Mato(5, 5, Suunta.OIKEA);
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());
        
        mato.kasva();
        System.out.println(mato.getPalat());
        mato.liiku();
        System.out.println(mato.getPalat());

        mato.setSuunta(Suunta.VASEN);
        System.out.println(mato.osuuItseensa());
        mato.liiku();
        System.out.println(mato.osuuItseensa());
</pre>

<pre>
[(5,5)]
[(6,5), (5,5)]
[(7,5), (6,5), (5,5)]
[(8,5), (7,5), (6,5)]
[(8,5), (7,5), (6,5)]
[(9,5), (8,5), (7,5), (6,5)]
false
true
</pre>

<h4>Matopeli, osa 1</h4>

<p>Muokataan seuraavaksi pakkauksessa <code>matopeli.peli</code> olevaa matopelin toiminnallisuutta kapseloivaa luokka <code>Matopeli</code>. Matopeli-luokka perii luokan <code>Timer</code>, joka tarjoaa ajastustoiminnallisuuden pelin pÃ¤ivittÃ¤miseen. Luokka <code>Timer</code> vaatii toimiakseen <code>ActionListener</code>-rajapinnan toteuttavan luokan. Olemme toteuttaneet luokalla <code>Matopeli</code> rajapinnan <code>ActionListener</code>.</p>

<p>Muokkaa matopelin konstruktorin toiminnallisuutta siten, ettÃ¤ konstruktorissa luodaan peliin liittyvÃ¤ <code>Mato</code>. Luo mato siten, ettÃ¤ sijainti riippuu Matopeli-luokan konstruktorissa saaduista parametreista. Madon x-koordinaatin tulee olla <code>leveys / 2</code>, y-koordinaatin <code>korkeus / 2</code> ja suunnan <code>Suunta.ALAS</code>.</p>

<p>Luo konstruktorissa myÃ¶s omena. Konstruktorissa luotavan omenan sijainnin tulee olla satunnainen, kuitenkin niin ettÃ¤ omenan x-koordinaatti on aina vÃ¤lillÃ¤ <code>[0, leveys[</code>, ja y-koordinaatti vÃ¤lillÃ¤ <code>[0, korkeus[</code>.</p>

<p>LisÃ¤Ã¤ matopeliin lisÃ¤ksi seuraavat metodit</p>
<ul>
  <li><code>public Mato getMato()</code> palauttaa matopelin madon.</li>
  <li><code>public void setMato(Mato mato)</code> asettaa matopeliin metodin parametrina olevan madon. Jos metodia <code>getMato</code> kutsutaan madon asetuksen jÃ¤lkeen, tulee metodin <code>getMato</code> palauttaa viite <em>samaan</em> matoon.</li>
  <li><code>public Omena getOmena</code> palauttaa matopelin omenan.</li>
  <li><code>public void setOmena(Omena omena)</code> asettaa matopeliin metodin parametrina olevan omenan. Jos metodia <code>getOmena</code> kutsutaan omenan asetuksen jÃ¤lkeen, tulee metodin <code>getOmena</code> palauttaa viite <em>samaan</em> omenaan.</li>
</ul>



<h4>Matopeli, osa 2</h4>

<p>Muokkaa metodin <code>actionPerformed</code>-toiminnallisuutta siten, ettÃ¤ metodissa toteutetaan seuraavat askeleet annetussa jÃ¤rjestyksessÃ¤.</p>

<ol>
  <li>Liikuta matoa</li>
  <li>Jos mato osuu omenaan, syÃ¶ omena ja kutsu madon kasva-metodia. Arvo peliin uusi omena.</li>
  <li>Jos mato tÃ¶rmÃ¤Ã¤ itseensÃ¤, aseta muuttujan <code>jatkuu</code> arvoksi <code>false</code></li>
  <li>Kutsu rajapinnan <code>Paivitettava</code> toteuttavan muuttujan <code>paivitettava</code> metodia <code>paivita</code>.</li>
  <li>Kutsu Timer-luokalta perittyÃ¤ <code>setDelay</code>-metodia siten, ettÃ¤ pelin nopeus kasvaa suhteessa madon pituuteen. Kutsu <code>setDelay(1000 / <em>mato</em>.getPituus());</code> kÃ¤y hyvin: kutsussa oletetaan ettÃ¤ olet mÃ¤Ã¤ritellyt oliomuuttujan nimeltÃ¤ <code>mato</code>.</li>
</ol>

<p>Aletaan seuraavaksi rakentamaan kÃ¤yttÃ¶liittymÃ¤komponentteja.</p>

<h4>NÃ¤ppÃ¤imistÃ¶n kuuntelija</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Nappaimistonkuuntelija</code>. Luokalla on konstruktori <code>public Nappaimistonkuuntelija(Mato mato)</code>, ja se toteuttaa rajapinnan <code>KeyListener</code>. Korvaa metodi <code>keyPressed</code> siten, ettÃ¤ nuolinÃ¤ppÃ¤intÃ¤ ylÃ¶s painettaessa madolle asetetaan suunta ylÃ¶s. NuolinÃ¤ppÃ¤intÃ¤ alas painettaessa madolle asetetaan suunta alas, vasemmalle painettaessa suunta vasen, ja oikealle painettaessa suunta oikea.</p>

<h4>Piirtoalusta</h4>

<p>Toteuta pakkaukseen <code>matopeli.gui</code> luokka <code>Piirtoalusta</code>, joka perii luokan <code>JPanel</code>. Piirtoalusta saa konstruktorin parametrina luokan <code>Matopeli</code> ilmentymÃ¤n sekÃ¤ int-tyyppisen muuttujan <code>palanSivunPituus</code>. Muuttuja <code>palanSivunPituus</code> kertoo minkÃ¤ levyinen ja korkuinen yksittÃ¤inen pala on.</p>

<p>Korvaa luokalta <code>JPanel</code> peritty metodi <code>paintComponent</code> siten, ettÃ¤ piirrÃ¤t metodissa <code>paintComponent</code> madon ja omenan. KÃ¤ytÃ¤ madon piirtÃ¤miseen Graphics-olion tarjoamaa <code>fill3DRect</code>-metodia. Madon vÃ¤rin tulee olla valkoinen (<code>Color.WHITE</code>). Omenan piirtÃ¤misessÃ¤ tulee kÃ¤yttÃ¤Ã¤ Graphics-olion tarjoamaa <code>fillOval</code>-metodia. Omenan vÃ¤rin tulee olla punainen (<code>Color.RED</code>).</p>

<p>Toteuta luokalla <code>Piirtoalusta</code> myÃ¶s rajapinta <code>Paivitettava</code>. Paivitettava-rajapinnan mÃ¤Ã¤rittelemÃ¤n metodin <code>paivita</code> tulee kutsua JPanel-luokan <code>repaint</code>-metodia.</p>

<h4>Kayttoliittyma</h4>

<p>Muuta luokkaa <code>Kayttoliittyma</code> siten, ettÃ¤ kÃ¤yttÃ¶liittymÃ¤ sisÃ¤ltÃ¤Ã¤ piirtoalustan. Metodissa <code>luoKomponentit</code> tulee luoda piirtoalustan ilmentymÃ¤ ja lisÃ¤tÃ¤ se container-olioon. Luo metodin <code>luoKomponentit</code> lopussa luokan <code>Nappaimistokuuntelija</code> ilmentymÃ¤, ja lisÃ¤Ã¤ se frame-olioon.</p>

<p>LisÃ¤Ã¤ luokalle <code>Kayttoliittyma</code> myÃ¶s metodi <code>public Paivitettava getPaivitettava()</code>, joka palauttaa metodissa <code>luoKomponentit</code> luotavan piirtoalustan.</p>

<p>Voit kÃ¤ynnistÃ¤Ã¤ kÃ¤yttÃ¶liittymÃ¤n <code>Main</code>-luokassa seuraavasti. Ennen pelin kÃ¤ynnistystÃ¤ odotamme ettÃ¤ kÃ¤yttÃ¶liittymÃ¤ luodaan. Kun kÃ¤yttÃ¶liittymÃ¤ on luotu, se kytketÃ¤Ã¤n matopeliin ja matopeli kÃ¤ynnistetÃ¤Ã¤n.</p>

<pre class="sh_java">
        Matopeli matopeli = new Matopeli(20, 20);

        Kayttoliittyma kali = new Kayttoliittyma(matopeli, 20);
        SwingUtilities.invokeLater(kali);

        while (kali.getPaivitettava() == null) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                System.out.println("Piirtoalustaa ei ole vielÃ¤ luotu.");
            }
        }

        matopeli.setPaivitettava(kali.getPaivitettava());
        matopeli.start();
</pre>

</div>

<h2>Kurssipalaute</h2>

<div class="tehtavat">

<h3>Kurssipalaute</h3>

<p>Olemme saaneet paljon arvokasta palautetta TMC:n kautta. NÃ¤in kurssin viimeisenÃ¤ kysymyksenÃ¤ haluaisimme koko kurssin sisÃ¤ltÃ¶Ã¤ koskevan palautteen. Anna palaute tÃ¤yttÃ¤mÃ¤llÃ¤ <a href="https://ilmo.cs.helsinki.fi/kurssit/servlet/Valinta">tÃ¤Ã¤ltÃ¤</a> lÃ¶ytyvÃ¤lomake. Palaute on anonyymi.</p> 

<p>Jotta saat merkatuksi tÃ¤mÃ¤n tehtÃ¤vÃ¤n, aja tehtÃ¤vÃ¤n TMC-testit ja lÃ¤hetÃ¤ tehtÃ¤vÃ¤ palvelimelle. </p>

</div>

<div class="viikkoraja">Retired</div>

<h3>Tiedostojen valitseminen kÃ¤yttÃ¶liittymÃ¤stÃ¤</h3>

<p>Silloin tÃ¤llÃ¶in eteen tulee tilanne, jossa kÃ¤yttÃ¤jÃ¤n pitÃ¤Ã¤ pystyÃ¤ valitsemaan tiedosto tiedostojÃ¤rjestelmÃ¤stÃ¤. Java tarjoaa tiedostojen valintaan valmiin kÃ¤yttÃ¶liittymÃ¤komponentin <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/JFileChooser.html" target="_blank">JFileChooser</a></code>.</p>

<p>JFileChooser poikkeaa tÃ¤hÃ¤n mennessÃ¤ kÃ¤yttÃ¤mistÃ¤mme kÃ¤yttÃ¶liittymÃ¤komponenteista siinÃ¤, ettÃ¤ se avaa uuden ikkunan. Avautuvan ikkunan ulkonÃ¤kÃ¶ riippuu hieman kÃ¤yttÃ¶jÃ¤rjestelmÃ¤stÃ¤, esimerkiksi hieman vanhemmassa <a href="http://fedoraproject.org/" target="_blank">Fedora</a>-kÃ¤yttÃ¶jÃ¤rjestelmÃ¤ssÃ¤ ikkuna on seuraavannÃ¤kÃ¶inen.</p>

<p><img src="img-ohja/kali/jfilechooser-kuva.png"/></p>

<p>JFileChooser-olio voidaan luoda missÃ¤ tahansa. Olion metodille <code>showOpenDialog</code> annetaan parametrina kÃ¤yttÃ¶liittymÃ¤komponentti, johon se liittyy, esimerkiksi <code>JFrame</code>-luokan ilmentymÃ¤. Metodi <code>showOpenDialog</code> avaa tiedostonvalintaikkunan, ja palauttaa <code>int</code>-tyyppisen statuskoodin riippuen kÃ¤yttÃ¤jÃ¤n valinnasta. Luokassa <code>JFileChooser</code> on mÃ¤Ã¤ritelty <code>int</code>-tyyppiset luokkamuuttujat, jotka kuvaavat statuskoodeja. Esimerkiksi onnistuneella valinnalla on arvo <code>JFileChooser.APPROVE_OPTION</code>.</p>

<p>Valittuun tiedostoon pÃ¤Ã¤see <code>JFileChooser</code>-oliosta kÃ¤siksi metodilla <code>getSelectedFile</code>.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<p>YllÃ¤ oleva esimerkki avaa valintaikkunan, ja tulostaa valitun tiedoston nimen jos valinta onnistuu. Jos valinta epÃ¤onnistuu, ohjelma tulostaa <code>"Et valinnut tiedostoa!"</code>.</p>

<h4>Tiedostojen filtterÃ¶inti</h4>

<p>Tiedostojen filtterÃ¶innillÃ¤ tarkoitetaan vain tietynlaisten tiedostojen nÃ¤yttÃ¤mistÃ¤ tiedostoikkunassa. JFileChooser-oliolle voi asettaa filtterin metodilla <code>setFileFilter</code>. Metodi <code>setFileFilter</code> saa parametrina abstraktin luokan <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileFilter.html" target="_blank">FileFilter</a></code>-ilmentymÃ¤n, esimerkiksi luokasta <code><a href="http://docs.oracle.com/javase/6/docs/api/javax/swing/filechooser/FileNameExtensionFilter.html" target="_blank">FileNameExtensionFilter</a></code> tehdyn olion.</p>

<p>Luokka <code>FileNameExtensionFilter</code> mahdollistaa tiedostojen filtterÃ¶innin niiden pÃ¤Ã¤tteiden perusteella. Esimerkiksi pelkÃ¤t <code>txt</code>-pÃ¤Ã¤tteiset tekstitiedostot saa nÃ¤kyviin seuraavasti.</p>

<pre class="sh_java">
    JFileChooser chooser = new JFileChooser();
    chooser.setFileFilter(new FileNameExtensionFilter("Tekstitiedostot", "txt"));

    int valinta = chooser.showOpenDialog(frame);

    if (valinta == JFileChooser.APPROVE_OPTION) {
        File valittu = chooser.getSelectedFile();
        System.out.println("Valitsit tiedoston: " + valittu.getName());
    } else if (valinta == JFileChooser.CANCEL_OPTION) {
        System.out.println("Et valinnut tiedostoa!");
    }
</pre>

<div class="tehtavat">


<NEXTWEEK></NEXTWEEK>
<h3>Nopeustesti</h3>



<p>Luodaan ohjelma, joka mittaa kliksutteluvauhtia. KÃ¤yttÃ¶liittymÃ¤ tulee nÃ¤yttÃ¤mÃ¤Ã¤n esimerkiksi seuraavalta.</p>

<p><img src="img-ohja/kali/169-nopeustesti.png"/></p>

<h4 class="req">Oma luokka JButtonille</h4>

<p>Toteuta pakkaukseen <code>nopeustesti</code> luokka <code>Nappi</code>, joka perii JButtonin. Luokalla <code>Nappi</code> tulee olla konstruktori <code>public Nappi(String text, Color aktiivinen, Color passiivinen)</code>. Konstruktorin parametrina saama characterString <code>text</code> tulee antaa parametrina ylÃ¤luokan konstruktorille (kutsu <code>super(text)</code>).</p> 

<p>Korvaa luokasta JButton peritty metodi <code>protected void paintComponent(Graphics g)</code> siten, ettÃ¤ piirrÃ¤t metodissa napin kokoisen vÃ¤rillisen ympyrÃ¤n. Saat napin leveyden ja korkeuden JButton-luokalta perityistÃ¤ metodeista <code>getWidth()</code> ja <code>getHeight()</code>. Kutsu korvatun metodin alussa ylÃ¤luokan <code>paintComponent</code>-metodia.</p>

<p>YmpyrÃ¤n vÃ¤rin tulee riippua Napin tilasta: jos nappi on aktiivinen (metodi <code>isEnabled</code> palauttaa <code>true</code> tulee ympyrÃ¤n vÃ¤ri olla konstruktorin parametrina saatu <code>aktiivinenVari</code>. Muulloin kÃ¤ytetÃ¤Ã¤n vÃ¤riÃ¤ <code>passiivinenVari</code>.</p>

<h4 class="req">Perustoiminta</h4>

<p>Toteuta luokkaan <code>Nopeustesti</code> kÃ¤yttÃ¶liittymÃ¤, jossa on neljÃ¤ nappulaa ja teksti. KÃ¤ytÃ¤ asettelussa napeille omaa JPanel-alustaa, joka asetetaan BorderLayout-asettelijan keskelle. Teksti tulee BorderLayout-asettelijan alaosaan.</p>

<p>KÃ¤ytÃ¤ edellisessÃ¤ osassa luomaasi <code>Nappi</code>-luokkaa. Napeille tulee antaa konstruktorissa tekstit 1, 2, 3 ja 4.</p>

<h4 class="req">Nappuloiden aktiivisuus</h4>

<p>Vain yhden nappulan kerrallaan tulee olla painettavissa (eli aktiivisena). Voit tehdÃ¤ nappulasta ei-aktiivisen metodikutsulla <code>nappi.setEnabled(false)</code>. Vastaavasti nappi muutetaan aktiiviseksi kutsulla <code>nappi.setEnabled(true)</code>.</p>

<p>Kun aktiivisena olevaa nappulaa painetaan, tulee kÃ¤yttÃ¶liittymÃ¤n arpoa uusi aktiivinen nappi.</p>

<h4 class="req">Pisteytys</h4>

<p>TehdÃ¤Ã¤n peliin pisteytys: mitataan 20 painallukseen kuluva aika. Helpoin tapa ajan mittaamiseen on metodin <code>System.currentTimeMillis()</code> kutsuminen. Metodi palauttaa kokonaisluvunu, joka laskee millisekunteja (tuhannesosasekunteja) jostain tietysti ajanhetkestÃ¤ lÃ¤htien. SiispÃ¤ voit mitata kulunutta aikaa kutsumalla <code>currentTimeMillis</code> pelin alussa ja lopussa ja laskemalla erotuksen.</p>

<p>Toteuta siis seuraava: peli laskee napinpainallusten mÃ¤Ã¤rÃ¤n, ja 20. painalluksen jÃ¤lkeen asettaa kaikki nappulat epÃ¤aktiivisiksi ja nÃ¤yttÃ¤Ã¤ <code>JLabel</code>-komponentissa viestin <code>"Pisteesi: XXXX"</code>, jossa <code>XXXX</code> on painalluksiin kulunut aika (millisekunteina) jaettuna 20:lla. Pienempi pistemÃ¤Ã¤rÃ¤ on siis parempi.</p>

<h3>TiedostonnÃ¤ytin</h3>

<p>TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ toteutetaan ohjelma, joka lukee kÃ¤yttÃ¤jÃ¤n valitseman tiedoston ja nÃ¤yttÃ¤Ã¤ sen sisÃ¤llÃ¶n kÃ¤yttÃ¶liittymÃ¤ssÃ¤.</p>

<p>Ohjelmassa on eroteltu kÃ¤yttÃ¶liittymÃ¤Ã¤n ja sovelluslogiikka. TehtÃ¤vÃ¤pohjassa on valmiina sovelluslogiikan rajapinta <code>TiedostonLukija</code> sekÃ¤ kÃ¤yttÃ¶liittymÃ¤luokan runko <code>Kayttoliittyma</code>.</p>

<h4>KÃ¤yttÃ¶liittymÃ¤n rakentaminen</h4>

<p>TÃ¤ydennÃ¤ kÃ¤yttÃ¶liittymÃ¤luokan metodi <code>luoKomponentit</code>. Ohjelma tarvitsee toimiakseen kolme kÃ¤yttÃ¶liittymÃ¤komponenttia:</p>

<ul>
  <li><strong>JButton</strong>-nappi, jossa on teksti &quot;Valitse tiedosto...&quot;</li>
  <li><strong>JTextArea</strong>-tekstieditorin avulla nÃ¤ytetÃ¤Ã¤n tiedoston sisÃ¤ltÃ¶, komponentin editointimahdollisuus tulee kytkeÃ¤ pois pÃ¤Ã¤ltÃ¤ metodilla <code>setEditable</code>. <code>JTextArea</code> eroaa <code>JTextField</code>-komponentista siten, ettÃ¤ <code>JTextArea</code>-komponentissa voi olla tekstiÃ¤ useammalla rivillÃ¤.</li>
  <li><strong>JLabel</strong>-tietokenttÃ¤, joka sisÃ¤ltÃ¤Ã¤ nÃ¤ytettÃ¤vÃ¤n tiedoston nimen (ilman polkua!)</li>
</ul>

<p>Koska tÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ on vain kolme aseteltavaa komponenttia, riittÃ¤vÃ¤t asetteluun <code>BorderLayout</code>-asettelijan vaihtoehdot: <code>BorderLayout.NORTH</code>, <code>BorderLayout.CENTER</code> ja <code>BorderLayout.SOUTH</code>. KÃ¤yttÃ¶liittymÃ¤komponentti <code>JTextArea</code> kannattaa sijoittaa keskelle, jotta se saa mahdollisimman paljon tilaa tekstin nÃ¤yttÃ¤miselle.</p>

<p>KÃ¤yttÃ¶liittymÃ¤n pitÃ¤isi nÃ¤yttÃ¤Ã¤ suunnilleen seuraavalta. Alla olevassa esimerkissÃ¤ <code>JLabel</code>-oliossa ei ole mitÃ¤Ã¤n tekstiÃ¤.</p>

    <p><img src="img-ohja/kali/161-tiedostonnaytin-alku.png"/></p>


<h4>Tiedoston lukeminen</h4>

<p>Luo pakkaukseen <code>tiedostonnaytin.sovelluslogiikka</code> luokka <code>OmaTiedostonLukija</code>, joka toteuttaa rajapinnan <code>TiedostonLukija</code>. Rajapinnassa on yksi metodi, <code>lueTiedosto</code>, joka lukee sille annetun tiedoston kokonaisuudessaan characterStringon ja palauttaa tÃ¤mÃ¤n characterStringn.</p>

<p>Rajapinnan koodi:</p>

<pre class="sh_java">
package tiedostonnaytin.sovelluslogiikka;

import java.io.File;

public interface TiedostonLukija {
    String lueTiedosto(File tiedosto);
}
</pre>

<p><b>Huom:</b> Palautettavassa characterStringssa tulee sÃ¤ilyttÃ¤Ã¤ myÃ¶s rivinvaihdot <code>"\n"</code>. Esimerkiksi <code>Scanner</code>-lukijan metodi <code>nextLine()</code> poistaa palauttamistaan characterStringista rivinvaihdot, joten joudut joko lisÃ¤Ã¤mÃ¤Ã¤n ne takaisin tai lukemaan tiedostoa eri tavalla.</p>

<h4>KÃ¤yttÃ¶liittymÃ¤n kytkeminen sovelluslogiikkaan</h4>

<p>ViimeisessÃ¤ tehtÃ¤vÃ¤n osassa toteutetaan kÃ¤yttÃ¶liittymÃ¤n <code>JButton</code>-napille tapahtumankuuntelija. Saat itse pÃ¤Ã¤ttÃ¤Ã¤ luokalle sopivan nimen.</p>

<p>Tapahtumankuuntelijan tehtÃ¤vÃ¤nÃ¤ on nÃ¤yttÃ¤Ã¤ <code>JFileChooser</code>-tiedostonvalintaikkuna kun <code>JButton</code>-nappia painetaan. Kun kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee tapahtumankuuntelijan lukea tiedoston sisÃ¤ltÃ¶ ja nÃ¤yttÃ¤Ã¤ se <code>JTextArea</code>-kentÃ¤ssÃ¤. TÃ¤mÃ¤n jÃ¤lkeen tapahtumankuuntelijan tulee vielÃ¤ pÃ¤ivittÃ¤Ã¤ <code>JLabel</code>-kenttÃ¤Ã¤n nÃ¤ytetyn tiedoston nimi (ilman tiedostopolkua).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa mÃ¤Ã¤riteltyÃ¤ <code>TiedostonLukija</code>-oliota apuna kÃ¤yttÃ¤en. Kannattaa luoda tapahtumankuuntelija siten, ettÃ¤ sille annetaan konstruktorissa kaikki tarvitut oliot.</p>

<p>Huomaa, ettÃ¤ valintaikkunan voi myÃ¶s sulkea valitsematta tiedostoa!</p>

<!--
<p><code>JButton</code>-nappiin tulee siis liittÃ¤Ã¤ <code>ActionListener</code>-rajapinnan toteuttava tapahtumankuuntelija, joten tehtÃ¤vÃ¤ssÃ¤ tÃ¤ytyy luoda tÃ¤tÃ¤ varten uusi luokka. <code>JFileChooser</code> palauttaa kÃ¤yttÃ¤jÃ¤n valitsemaa operaatiota vastaavan paluuarvon sekÃ¤ viitteen valittuun tiedostoon, jos kÃ¤yttÃ¤jÃ¤ valitsi tiedoston (eikÃ¤ peruuttanut valintaa).</p>

<p>JFileChooser-olion metodille <code>showOpenDialog</code> tulee antaa parametrina <code>Kayttoliittyma</code>-luokassa oleva <code>JFrame</code>-ikkunaolio. Jos kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee tiedosto lukea tapahtumankuuntelijassa <code>Kayttoliittyma</code>-luokassa mÃ¤Ã¤riteltyÃ¤ <code>TiedostonLukija</code>-oliota apuna kÃ¤yttÃ¤en. Kannattaa luoda tapahtumankuuntelija siten, ettÃ¤ sille annetaan konstruktorissa tarvitut oliot.</p>

<p>Kun kÃ¤yttÃ¤jÃ¤ valitsee tiedoston, tulee <code>JTextArea</code>-kentÃ¤n tekstisisÃ¤llÃ¶ksi asettaa tiedoston sisÃ¤ltÃ¶.</p>-->

<p>Kun tiedosto on avattu, tulee kÃ¤yttÃ¶liittymÃ¤n nÃ¤yttÃ¤Ã¤ esimerkiksi seuraavalta.</p>

    <p><img src="img-ohja/kali/161-tiedostonnaytin-avattu.png"/></p>

</div>


<div class="tehtavat">



<h3>Tekstiseikkailu</h3>


  <p>TehtÃ¤vÃ¤sarjassa tehdÃ¤Ã¤n laajennettava tekstiseikkailupelin runko. Seikkailu koostuu <em>kohdista</em>, joissa jokaisessa ruudulle tulee tekstiÃ¤. Kohdat voivat olla joko vÃ¤livaiheita, kysymyksiÃ¤, tai monivalintakohtia. Monivalinta-tyyppisen kohdan nÃ¤yttÃ¤mÃ¤ teksti voi olla esimerkiksi seuraavanlainen:</p>

<pre>
Huoneessa on kaksi ovea. Kumman avaat?

1. Vasemmanpuoleisen.
2. Oikeanpuoleisen.
3. Juoksen pakoon.
</pre>

  <p>KÃ¤yttÃ¤jÃ¤ vastaa kohdassa esitettÃ¤vÃ¤Ã¤n tekstiin. YllÃ¤ olevaan tekstiin voi vastata <code>1</code>, <code>2</code> tai <code>3</code>, ja vastauksesta riippuu, minne kÃ¤yttÃ¤jÃ¤ siirtyy seuraavaksi.</p>

  <p>Peliin tullaan toteuttamaan kohtia kuvaava rajapinta ja tekstikÃ¤yttÃ¶liittymÃ¤, jonka kautta peliÃ¤ pelataan.</p>

  <p><em>Huom!</em> Toteuta kaikki tehtÃ¤vÃ¤n vaiheet pakkaukseen "seikkailu"</p>

  <h4 class="req">Kohta ja VÃ¤livaihe</h4>

  <p>PelissÃ¤ voi olla hyvinkin erilaisia kohtia, ja edellÃ¤ olleessa esimerkissÃ¤ ollut monivalinta on vain erÃ¤s vaihtoehto.</p>

  <p>Toteuta kohdan kÃ¤yttÃ¤ytymistÃ¤ kuvaava rajapinta <code>Kohta</code>. Rajapinnalla <code>Kohta</code> tulee olla metodi <code>String teksti()</code>, joka palauttaa kohdassa tulostettavan tekstin. Metodin <code>teksti</code> lisÃ¤ksi kohdalla tulee olla metodi <code>Kohta seuraavaKohta(String vastaus)</code>, jonka toteuttavat luokat palauttavat seuraavan kohdan vastauksen perusteella.</p>

  <p>Toteuta tÃ¤mÃ¤n jÃ¤lkeen yksinkertaisin tekstiseikkailun kohta, eli ei-interaktiivinen tekstiruutu, josta pÃ¤Ã¤see etenemÃ¤Ã¤n millÃ¤ tahansa syÃ¶tteellÃ¤. Toteuta ei-interaktiivista tekstiruutua varten luokka <code>Valivaihe</code>, jolla on seuraavanlainen API.</p>

  <p>
    <ul>
      <li> Luokka toteuttaa rajapinnan <code>Kohta</code>. </li>
      <li> Konstruktori ottaa parametrikseen kÃ¤yttÃ¤jÃ¤lle nÃ¤ytettÃ¤vÃ¤n tekstin. </li>
      <li> <code>public String teksti()</code>-metodi palauttaa konstruktorissa annetun tekstin sekÃ¤ rivin <code>"(jatka painamalla enteriÃ¤)"</code>. (Rivinvaihto saadaan aikaan merkillÃ¤ "\n".)</li>
      <li> <code>public void asetaSeuraava(Kohta seuraava)</code>-metodilla voidaan asettaa <code>Kohta</code>-olio, jonka <code>seuraavaKohta(String vastaus)</code> aina palauttaa (vastauksesta riippumatta). </li>
    </ul>
  </p>

  <p>Testaa ohjelmaasi seuraavalla esimerkillÃ¤:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Valivaihe alkuteksti = new Valivaihe("Olipa kerran ohjelmoija.");
    Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
    alkuteksti.asetaSeuraava(johdanto);

    Kohta nykyinen = alkuteksti;
    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen == null) {
        System.out.println("Virhe ohjelmassa!");
    }

    System.out.println(nykyinen.teksti());

    nykyinen = nykyinen.seuraavaKohta(reader.nextLine());
    if (nykyinen != null) {
        System.out.println("Virhe ohjelmassa!");
    }
</pre>

<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriÃ¤)

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriÃ¤)

</pre>


<h4>KÃ¤yttÃ¶liittymÃ¤</h4>

  <p>Pelin kÃ¤yttÃ¶liittymÃ¤ (luokka <code>Kayttoliittyma</code>) saa konstruktorin parametrina <code>Scanner</code>-olion ja <code>Kohta</code>-rajapinnan toteuttavan pelin aloittavan olion. Luokka tarjoaa metodin <code>public void start()</code>, joka kÃ¤ynnistÃ¤Ã¤ pelin suorituksen.</p>

  <p>KÃ¤yttÃ¶liittymÃ¤ kÃ¤sittelee kaikkia kohtia <code>Kohta</code>-rajapinnan kautta. KÃ¤yttÃ¶liittymÃ¤n tulee jokaisessa kohdassa kysyÃ¤ kohtaan liittyvÃ¤ltÃ¤ metodilta <code>teksti</code> tekstiÃ¤, joka kÃ¤yttÃ¤jÃ¤lle nÃ¤ytetÃ¤Ã¤n. TÃ¤mÃ¤n jÃ¤lkeen kÃ¤yttÃ¶liittymÃ¤ kysyy kÃ¤yttÃ¤jÃ¤ltÃ¤ vastauksen, ja antaa sen parametrina kohta-olion metodille <code>seuraavaKohta</code>. Metodi <code>seuraavaKohta</code> palauttaa vastauksen perusteella seuraavan kohdan, johon pelin on mÃ¤Ã¤rÃ¤ siirtyÃ¤. Peli loppuu, kun metodi <code>seuraavaKohta</code> palauttaa arvon <code>null</code>.</p>

  <p>Koska pÃ¤Ã¤ohjelma tulee kÃ¤yttÃ¤mÃ¤Ã¤n kohtia vain <code>Kohta</code>-rajapinnan kautta, voidaan peliin lisÃ¤tÃ¤ vaikka minkÃ¤laisia kohtia pÃ¤Ã¤ohjelmaa muuttamatta. RiittÃ¤Ã¤ tehdÃ¤ uusia <code>Kohta</code>-rajapinnan toteuttavia luokkia.</p>

  <p>Toteuta luokka <code>Kayttoliittyma</code>, ja testaa sen toimintaa seuraavalla esimerkillÃ¤</p>

<pre class="sh_java">
        Scanner lukija = new Scanner(System.in);
        Valivaihe alku = new Valivaihe("Olipa kerran ohjelmoija.");
        Valivaihe johdanto = new Valivaihe("Joka alkoi ohjelmoimaan Javalla.");
        Valivaihe loppu = new Valivaihe("Ja pÃ¤Ã¤tti muuttaa Helsinkiin.");

        alku.asetaSeuraava(johdanto);
        johdanto.asetaSeuraava(loppu);

        new Kayttoliittyma(lukija, alku).start();
</pre>


<pre>
Olipa kerran ohjelmoija.
(jatka painamalla enteriÃ¤)
&gt;

Joka alkoi ohjelmoimaan Javalla.
(jatka painamalla enteriÃ¤)
&gt;

Ja pÃ¤Ã¤tti muuttaa Helsinkiin.
(jatka painamalla enteriÃ¤)
&gt;

</pre>

  <p>KÃ¤ytÃ¤ seuraavaa metodia kÃ¤yttÃ¶liittymÃ¤n <code>start</code>-metodina. YritÃ¤ piirtÃ¤Ã¤ paperille mitÃ¤ kÃ¤y kun kÃ¤yttÃ¶liittymÃ¤ kÃ¤ynnistetÃ¤Ã¤n.</p>

<pre class="sh_java">
    public void start() {
        Kohta nykyinen = alkukohta;

        while (nykyinen != null) {
            System.out.println(nykyinen.teksti());
            System.out.print("&gt; ");
            String vastaus = reader.nextLine();

            nykyinen = nykyinen.seuraavaKohta(vastaus);
            System.out.println("");
        }
    }
</pre>

  <p>KÃ¤yttÃ¶liittymÃ¤n <code>start</code>-metodi sisÃ¤ltÃ¤Ã¤ siis toistolauseen, jossa ensin tulostetaan kÃ¤siteltÃ¤vÃ¤n kohdan teksti. TÃ¤mÃ¤n jÃ¤lkeen kysytÃ¤Ã¤n kÃ¤yttÃ¤jÃ¤ltÃ¤ syÃ¶tettÃ¤. KÃ¤yttÃ¤jÃ¤n syÃ¶te annetaan vastauksena kÃ¤siteltÃ¤vÃ¤n kohdan <code>seuraavaKohta</code>-metodille. Metodi <code>seuraavaKohta</code> palauttaa kohdan, jota kÃ¤sitellÃ¤Ã¤n seuraavalla toiston kierroksella. Jos palautettu kohta oli <code>null</code>, lopetetaan toisto.</p>

    <h4>KysymyksiÃ¤</h4>

    <p>Tekstiseikkailussa voi olla kysymyksiÃ¤, joihin on annettava oikea vastaus ennen kuin pelaaja pÃ¤Ã¤see eteenpÃ¤in. Tee luokka <code>Kysymys</code> seuraavasti:</p>

    <p>
      <ul>
        <li> Luokka toteuttaa <code>Kohta</code>-rajapinnan. </li>
        <li> Konstruktori saa parametreina kysymystekstin ja oikean vastauksen. </li>
        <li> Seuraavan kohdan voi asettaa <code>asetaSeuraava</code>-metodilla. </li>
        <li> Jos <code>seuraavaKohta</code>-metodia kutsutaan oikealla vastauksella, metodi palauttaa seuraavan kohdan, muuten metodi ei pÃ¤Ã¤stÃ¤ etenemÃ¤Ã¤n ja palauttaa arvon <code>this</code>, eli viitteen tÃ¤hÃ¤n olioon. </li>
      </ul>
    </p>

    <p>Luokkaa voi testata seuraavalla pÃ¤Ã¤ohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Kysymys alku = new Kysymys("MinÃ¤ vuonna Javan ensimmÃ¤inen versio julkaistiin?", "1995");
    Valivaihe hyva = new Valivaihe("HyvÃ¤! LisÃ¤tietoa: Javan alkuperÃ¤inen ideoija on James Gosling.");

    alku.asetaSeuraava(hyva);

    new Kayttoliittyma(lukija, alku).start();
</pre>

<pre>
MinÃ¤ vuonna Javan ensimmÃ¤inen versio julkaistiin?
&gt; <font color="red">2000</font>

MinÃ¤ vuonna Javan ensimmÃ¤inen versio julkaistiin?
&gt; <font color="red">1995</font>

HyvÃ¤! LisÃ¤tietoa: Javan alkuperÃ¤inen ideoija on James Gosling.
(jatka painamalla enteriÃ¤)
&gt;
</pre>



<h4 class="req">Monivalintakysymykset</h4>

    <p>TÃ¤llÃ¤ hetkellÃ¤ tekstiseikkailu tukee vÃ¤livaiheita ja yksinkertaisia kysymyksiÃ¤. Tekstiseikkailu on siis lineaarinen, eli lopputulokseen ei voi kÃ¤ytÃ¤nnÃ¶ssÃ¤ vaikuttaa. LisÃ¤tÃ¤Ã¤n seikkailuun monivalintakysymyksiÃ¤, joiden avulla pelin kehittÃ¤jÃ¤ voi luoda vaihtoehtoista toimintaa.</p>

    <p>Esimerkki vaihtoehtoisesta toiminnasta:</p>

<pre>
Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Ruoka on loppu :(
(jatka painamalla enteriÃ¤)
&gt;
</pre>


<pre>
Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">2</font>

Mainio valinta!
(jatka painamalla enteriÃ¤)
&gt;
</pre>

    <p>Toteuta luokka <code>Monivalinta</code>, jonka API on seuraavanlainen</p>

    <p>
      <ul>
        <li> Toteuttaa rajapinnan <code>Kohta</code>. </li><br/>
        <li> <code>public Monivalinta(String teksti)</code></li> Luokan konstruktori saa parametrina nÃ¤ytettÃ¤vÃ¤n tekstin. <br/>
        <li> <code>public void lisaaVaihtoehto(String valinta, Kohta seuraava)</code></li> LisÃ¤Ã¤ vaihtoehdon ja siihen liittyvÃ¤n seuraavan kohdan. YhdessÃ¤ monivalintakysymyksessÃ¤ voi olla rajaton mÃ¤Ã¤rÃ¤ vaihtoehtoja.<br/>
        <li> <code>public String teksti()</code></li> Palauttaa characterStringna sekÃ¤ konstruktorissa annetun perustekstin ettÃ¤ kaikki valintavaihtoehdot. Valintavaihtoehdot tulee olla eritelty numeroilla.<br/>
        <li> <code>public Kohta seuraavaKohta(String valinta)</code></li> Palauttaa kÃ¤yttÃ¤jÃ¤n valitsemaa vaihtoehtoa vastaavan kohdan. KÃ¤yttÃ¤jÃ¤ valitsee aina kirjoittamalla numeron. Huom! Voit muuttaa characterStringn numeroksi luokan <code>Integer</code> luokkametodilla <code>parseInt</code>. <br/>
      </ul>
    </p>


    <p>Testaa ohjelmasi toimintaa seuraavalla pÃ¤Ã¤ohjelmalla:</p>

<pre class="sh_java">
    Scanner lukija = new Scanner(System.in);

    Monivalinta lounas = new Monivalinta("Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?");
    Monivalinta chemicum = new Monivalinta("Lounasvaihtoehtosi ovat seuraavat:");

    Valivaihe exactum = new Valivaihe("Exactumista on kaikki loppu, joten menet Chemicumiin.");

    exactum.asetaSeuraava(chemicum);

    lounas.lisaaVaihtoehto("Exactumiin", exactum);
    lounas.lisaaVaihtoehto("Chemicumiin", chemicum);

    Valivaihe nom = new Valivaihe("Olipas hyvÃ¤Ã¤");

    chemicum.lisaaVaihtoehto("Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta", nom);
    chemicum.lisaaVaihtoehto("Jauhelihakebakot, paprikakastiketta", nom);
    chemicum.lisaaVaihtoehto("Mausteista kalapataa", nom);

    new Kayttoliittyma(lukija, lounas).start();
</pre>

<pre>
Kello on 13:37 ja pÃ¤Ã¤tÃ¤t mennÃ¤ syÃ¶mÃ¤Ã¤n. Minne menet?
1. Exactumiin
2. Chemicumiin
&gt; <font color="red">1</font>

Exactumista on kaikki loppu, joten menet Chemicumiin.
(jatka painamalla enteriÃ¤)
&gt;

Lounasvaihtoehtosi ovat seuraavat:
1. Punajuurikroketteja, ruohosipuli-soijajogurttikastiketta
2. Jauhelihakebakot, paprikakastiketta
3. Mausteista kalapataa
&gt; <font color="red">2</font>

Olipas hyvÃ¤Ã¤
(jatka painamalla enteriÃ¤)
&gt;

</pre>

    <p><em>Luokan <code>Monivalinta</code> sisÃ¤inen toteutus saattaa olla haastava. Kannattaa esimerkiksi kÃ¤yttÃ¤Ã¤ listaa vastausvaihtoehtojen (characterStringjen) tallentamiseen, ja hajautustaulua kohtien tallentamiseen valintavaihtoehdon indeksillÃ¤. </em></p>

</div>


<div class="tehtavat">

  <h3>Tilastot kuntoon</h3>

  <p>NHL:ssÃ¤ pidetÃ¤Ã¤n pelaajista yllÃ¤ monenlaisia tilastotietoja. Teemme nyt oman ohjelman NHL-pelaajien tilastojen hallintaan.</p>

<h4>Pelaajalistan tulostus</h4>

  <p>Tee luokka <code>Pelaaja</code>, johon voidaan tallettaa pelaajan nimi, joukkue, pelatut ottelut, maalimÃ¤Ã¤rÃ¤, ja syÃ¶ttÃ¶mÃ¤Ã¤rÃ¤. Luokalla tulee olla konstruktori, joka saa edellÃ¤mainitut tiedot edellÃ¤ annetussa jÃ¤rjestyksessÃ¤.</p>

  <p>Tee kaikille edellÃ¤minituille arvoille myÃ¶s ns. getterimetodit, jotka palauttavat arvot:</p>

<ul>
  <li><code>String getName</code></li>
  <li><code>String getJoukkue</code></li>
  <li><code>int getOttelut</code></li>
  <li><code>int getMaalit</code></li>
  <li><code>int getSyotot</code></li>
  <li><code>int getPisteet</code> - laskee kokonaispistemÃ¤Ã¤rÃ¤n eli maalien ja syÃ¶ttÃ¶jen summan</li>
</ul>

<p>Talleta seuraavat pelaajat ArrayList:iin ja tulosta listan sisÃ¤ltÃ¶:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        pelaajat.add(new Pelaaja("Alex Ovechkin", "WSH", 71, 28, 46));
        pelaajat.add(new Pelaaja("Dustin Byfuglien", "ATL", 69, 19, 31));
        pelaajat.add(new Pelaaja("Phil Kessel", "TOR", 70, 28, 24));
        pelaajat.add(new Pelaaja("Brendan Mikkelson", "ANA, CGY", 23, 0, 2));
        pelaajat.add(new Pelaaja("Matti Luukkainen", "SaPKo", 1, 0, 0 ));

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
    }
</pre>

<p>Pelaajan <code>toString()</code>-metodin muodostaman tulostuksen tulee olla seuraavassa muodossa:</p>

<pre>
Alex Ovechkin WSH 71 28 + 46 = 74
Dustin Byfuglien ATL 69 19 + 31 = 50
Phil Kessel TOR 70 28 + 24 = 52
Brendan Mikkelson ANA, CGY 23 0 + 2 = 2
Matti Luukkainen SaPKo 1 0 + 0 = 0
</pre>

  <p>Ensin siis nimi, sitten joukkue, jonka jÃ¤lkeen ottelut, maalit, plusmerkki, syÃ¶tÃ¶t, yhtÃ¤suuruusmerkki ja kokonaispisteet eli maalien ja syÃ¶ttÃ¶jen summa.</p>

<h4>Tulostuksen siistiminen</h4>

  <p>Tee <code>Pelaaja</code>-luokkaan metodi <code>toSiisticharacterString()</code>, joka palauttaa samat tiedot siististi aseteltuna siten, ettÃ¤ jokaiselle muuttujalle on varattu tietty mÃ¤Ã¤rÃ¤ tilaa tulostuksessa.</p>

<p>Tulostuksen tulee nÃ¤yttÃ¤Ã¤ seuraavalta:</p>

<pre>
Alex Ovechkin             WSH             71  28 + 46 = 74
Dustin Byfuglien          ATL             69  19 + 31 = 50
Phil Kessel               TOR             70  28 + 24 = 52
Brendan Mikkelson         ANA, CGY        23   0 +  2 =  2
Matti Luukkainen          SaPKo            1   0 +  0 =  0
</pre>

  <p>Nimen jÃ¤lkeen joukkueen nimien tÃ¤ytyy alkaa samasta kohdasta. Saat tÃ¤mÃ¤n aikaan esim. muotoilemalla nimen tulostuksen yhteydessÃ¤ seuraavasti:</p>

<pre class="sh_java">
String nameJaTyhjaa = String.format("%-25s", nimi);
</pre>

  <p>Komento tekee characterStringn <code>nimiJaTyhjaa</code> joka alkaa characterStringn <code>nimi</code> sisÃ¤llÃ¶llÃ¤ ja se jÃ¤lkeen tulee vÃ¤lilyÃ¶ntejÃ¤ niin paljon ettÃ¤ characterStringn pituudeksi tulee 25. Joukkueen nimi tulee vastaavalla tavalla tulostaa 14 merkin pituisena characterStringna. TÃ¤mÃ¤n jÃ¤lkeen on otteluiden mÃ¤Ã¤rÃ¤ (2 merkkiÃ¤), jota seuraa 2 vÃ¤lilyÃ¶ntiÃ¤. TÃ¤mÃ¤n jÃ¤lkeen on maalien mÃ¤Ã¤rÃ¤ (2 merkkiÃ¤), jota seuraa characterString " + ". TÃ¤tÃ¤ seuraa syÃ¶ttÃ¶jen mÃ¤Ã¤rÃ¤ (2 merkkiÃ¤), characterString " = ", ja lopuksi yhteispisteet (2 merkkiÃ¤).</p>

  <p>Lukuarvot eli ottelu-, maali-, syÃ¶ttÃ¶- ja pistemÃ¤Ã¤rÃ¤ muotoillaan kahden merkin mittaisena, eli lukeman 0 sijaan tulee tulostua vÃ¤lilyÃ¶nti ja nolla. Seuraava komento auttaa tÃ¤ssÃ¤:</p>

<pre class="sh_java">
String maalitMerkkeina = String.format("%2d", maalit);
</pre>

<h4>PistepÃ¶rssin tulostus</h4>

  <p>LisÃ¤Ã¤ luokalle Pelaaja rajapinta <code>Comparable&lt;Pelaaja&gt;</code>, jonka avulla pelaajat voidaan jÃ¤rjestÃ¤Ã¤ kokonaispistemÃ¤Ã¤rÃ¤n mukaiseen <em>laskevaan</em> jÃ¤rjestykseen. JÃ¤rjestÃ¤ pelaajat Collections-luokan avulla ja tulosta pistepÃ¶rssi:</p>

<pre class="sh_java">
        Collections.sort(pelaajat);

        System.out.println("NHL pistepÃ¶rssi:\n");
        for (Pelaaja pelaaja : pelaajat) {
            System.out.println(pelaaja);
        }
</pre>

<p>
Tulostuu:
</p>

<pre>
NHL pistepÃ¶rssi:

Alex Ovechkin             WSH           71  28 + 46 = 74
Phil Kessel               TOR           70  28 + 24 = 52
Dustin Byfuglien          ATL           69  19 + 31 = 50
</pre>

  <p>Ohjeita tÃ¤hÃ¤n tehtÃ¤vÃ¤Ã¤n materiaalissa.</p>

<h4>Kaikkien pelaajien tiedot</h4>

  <p>Tilastomme on vielÃ¤ hieman vajavainen, siinÃ¤ on vaan muutaman pelaajan tiedot (ja nekin vastaavat 16.3. tilannetta). Kaikkien tietojen syÃ¶ttÃ¤minen kÃ¤sin olisi kovin vaivalloista. Onneksemme internetistÃ¤ osoitteesta <code>http://nhlstatistics.herokuapp.com/players.txt</code> lÃ¶ytyy pÃ¤ivittyvÃ¤, koneen luettavaksi tarkoitettu lista pelaajatiedoista.</p>

  <p><b>Huom:</b> kun menet osoitteeseen ensimmÃ¤istÃ¤ kertaa, sivun latautuminen kestÃ¤Ã¤ muutaman sekunnin (sivu pyÃ¶rii virtuaalipalvelimella joka sammutetaan jos sivua ei ole hetkeen kÃ¤ytetty). Sen jÃ¤lkeen sivu toimii nopeasti.</p>

  <p>Datan lukeminen internetistÃ¤ on helppoa. Projektissasi on valmiina luokka <code>Tilasto</code>, joka lataa annetun verkkosivun.</p>

<pre class="sh_java">
import java.io.InputStream;
import java.net.URL;
import java.util.Scanner;

public class Tilasto {
    private static final String OSOITE =
            "http://nhlstatistics.herokuapp.com/players.txt";

    private Scanner lukija;

    public Tilasto() {
        this(OSOITE);
    }

    public Tilasto(String osoite) {
        try {
            URL url = new URL(osoite);
            lukija = new Scanner(url.openStream());
        } catch (Exception ex) {
        }
    }

    public Tilasto(InputStream in) {
        try {
            lukija = new Scanner(in);
        } catch (Exception ex) {
        }
    }

    public boolean onkoRivejaJaljella() {
        return reader.hasNextLine();
    }

    public String annaSeuraavaRivi() {
        String rivi = reader.nextLine();
        return rivi.trim();
    }
}
</pre>

  <p><code>Tilasto</code>-luokka lukee pelaajien tilastotiedot internetistÃ¤. Metodilla <code>annaSeuraavaRivi()</code> saadaan selville yhden pelaajan tiedot. Tietoja on tarkoitus lukea niin kauan kuin pelaajia riittÃ¤Ã¤, tÃ¤mÃ¤ voidaan tarkastaa metodilla <code>onkoRivejaJaljella()</code> </p>

  <p>Kokeile ettÃ¤ ohjelmasi onnistuu tulostamaan <code>Tilasto</code>-luokan hakemat tiedot:</p>

<pre class="sh_java">
    public static void main(String[] args) {
        Tilasto tilasto = new Tilasto();

        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            System.out.println(pelaajaRivina);
        }
    }
</pre>

  <p>Tulostus on seuraavan muodoinen:</p>

<pre>
Evgeni Malkin;PIT;62;39;46;54 <br/>

Steven Stamkos;TBL;70;50;34;64 <br/>

Claude Giroux;PHI;66;26;56;27 <br/>

Jason Spezza;OTT;72;29;46;30 <br/>
// ... ja yli 800:n muun pelaajan tiedot
</pre>

  <p><b>Huom:</b> tulostuksen alussa ja lopussa ja jokaisen pelaajan vÃ¤lissÃ¤ on html-tÃ¤gejÃ¤, esim. &lt;br/&gt; joka aiheuttaa www-sivulle rivin vaihtumisen.</p>

  <p>Tulostuksessa pelaajan tiedot on erotettu toisistaan puolipisteellÃ¤. Ensin nimi, sitten joukkue, ottelut, maalit, syÃ¶tÃ¶t ja laukaukset.</p>

  <p>Pelaajaa vastaava characterString on siis yksittÃ¤inen characterString. Saat pilkottua sen osiin <code>split</code>-komennolla seuraavasti:</p>

<pre class="sh_java">
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");
            for (int j = 0; j < pelaajaOsina.length; j++) {
                System.out.print(pelaajaOsina[j] + " ");
            }
            System.out.println("");
        }
</pre>

  <p>Kokeile ettÃ¤ tÃ¤mÃ¤ toimii. Saat tÃ¤stÃ¤ tehtÃ¤vÃ¤stÃ¤ pisteet seuraavan tehtÃ¤vÃ¤n yhteydessÃ¤.</p>

  <h4>Kaikkien pelaajien pistepÃ¶rssi</h4>

  <p>Tee kaikista <code>Tilasto</code>-luokan hakemien pelaajien tiedoista Pelaaja-olioita ja lisÃ¤Ã¤ ne ArrayListiin. LisÃ¤Ã¤ tehtÃ¤vÃ¤Ã¤n luokka <code>PelaajatTilastosta</code>. KÃ¤ytÃ¤ alla olevaa koodia luokan runkona.</p>

<pre class="sh_java">
import java.util.ArrayList;

public class PelaajatTilastosta {
    public ArrayList&lt;Pelaaja&gt; haePelaajat(Tilasto tilasto) {
        ArrayList&lt;Pelaaja&gt; pelaajat = new ArrayList&lt;Pelaaja&gt;();
        while (tilasto.onkoRivejaJaljella()) {
            String pelaajaRivina = tilasto.annaSeuraavaRivi();
            String[] pelaajaOsina = pelaajaRivina.split(";");

            // LisÃ¤tÃ¤Ã¤n uusi pelaaja vain, jos syÃ¶tteessÃ¤ on kenttiÃ¤ riittÃ¤vÃ¤sti
            if (pelaajaOsina.length &gt; 4) {
                int ottelut = Integer.parseInt(pelaajaOsina[2].trim());
                // TÃ¤ydennÃ¤ koodia lukemalla kaikki pelaajaOsina-taulukon kentÃ¤t uuteen Pelaaja-olioon
                // ...
                // pelaajat.add(new Pelaaja( ... ));
            }
        }

        return pelaajat;
    }
}
</pre>

  <p>TehtÃ¤vÃ¤nÃ¤si on tÃ¤ydentÃ¤Ã¤ runkoa siten, ettÃ¤ jokaisesta luetusta rivistÃ¤ luodaan pelaaja, joka lisÃ¤tÃ¤Ã¤n pelaajat-listaan. Huom! <code>Tilasto</code>-luokka palauttaa characterStringja, joten joudut muuntamaan characterStringja myÃ¶s numeroiksi. Esimerkiksi numeromuotoinen <code>ottelut</code> on muutettava <code>int</code>:iksi <code>Integer.parseInt</code>-metodilla.</p>

  <p>Jos characterStringn metodi <code>split</code> ei ole tuttu, se jakaa characterStringn useampaan osaan annetun merkin kohdalta. Esimerkiksi komento <code>characterString.split(";");</code> palauttaa characterStringsta taulukon, jossa alkuperÃ¤isen characterStringn puolipisteellÃ¤ erotetut osat ovat kukin omassa taulukon indeksissÃ¤.</p>

  <p>Voit kÃ¤yttÃ¤Ã¤ testauksen apuna seuraavaa pÃ¤Ã¤ohjelmaa:</p>

<pre class="sh_java">
        Tilasto tilasto = new Tilasto();

        PelaajatTilastosta pelaajienHakija = new PelaajatTilastosta();
        ArrayList&lt;Pelaaja&gt; pelaajat = pelaajienHakija.haePelaajat(tilasto);

        for (Pelaaja pelaaja : pelaajat) {
            System.out.println( pelaaja );
        }
</pre>

<h4>Maali ja syÃ¶ttÃ¶pÃ¶rssi</h4>

  <p>Haluamme tulostaa myÃ¶s maalintekijÃ¤pÃ¶rssin eli pelaajien tiedot maalimÃ¤Ã¤rÃ¤n mukaan jÃ¤rjestettynÃ¤ sekÃ¤ syÃ¶ttÃ¶pÃ¶rssin. <a href="http://www.nhl.com/ice/app?component=completePointLeadersList&page=statshome&service=direct">NHL:n</a> kotisivu tarjoaa tÃ¤mÃ¤nkaltaisen toiminnallisuuden, eli selaimessa nÃ¤ytettÃ¤vÃ¤ lista on mahdollista saada jÃ¤rjestettyÃ¤ halutun kriteerin mukaan.</p>

  <p>Edellinen tehtÃ¤vÃ¤ mÃ¤Ã¤ritteli pelaajien suuruusjÃ¤rjestyksen perustuvan kokonaispistemÃ¤Ã¤rÃ¤Ã¤n. Luokalla voi olla vain yksi <code>compareTo</code>-metodi, joten joudumme muunlaisia jÃ¤rjestyksiÃ¤ saadaksemme turvautumaan muihin keinoihin.</p>

        <p>Vaihtoehtoiset jÃ¤rjestÃ¤mistavat toteutetaan erillisten luokkien avulla. Pelaajien vaihtoehtoisten jÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokkien tulee toteuttaa <code>Comparator&lt;Pelaaja&gt;</code>-rajapinta. JÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokan olio vertailee kahta parametrina saamaansa pelaajaa. Metodeja on ainoastaan yksi <code>compare(Pelaaja p1, Pelaaja p2)</code>, jonka tulee palauttaa negatiivinen arvo, jos pelaaja <code>p1</code> on jÃ¤rjestyksessÃ¤ ennen pelaajaa <code>p2</code>, positiivinen arvo jos <code>p2</code> on jÃ¤rjestyksessÃ¤ ennen
<code>p1</code>:stÃ¤ ja 0 muuten.</p>

  <p>Periaatteena on luoda jokaista jÃ¤rjestÃ¤mistapaa varten oma vertailuluokka, esim. maalipÃ¶rssin jÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤ luokka:</p>

<pre class="sh_java">
import java.util.Comparator;

public class Maali implements Comparator&lt;Pelaaja&gt; {
    public int compare(Pelaaja p1, Pelaaja p2) {
        // maalien perusteella tapahtuvan vertailun koodi tÃ¤nne
    }
}
</pre>

  <p>Tee <code>Comparator</code>-rajapinnan toteuttavat luokat <code>Maali</code> ja <code>Syotto</code>, ja niille vastaavat maali- ja syÃ¶ttÃ¶pÃ¶rssien generoimiseen sopivat sopivat vertailufunktiot.</p>

  <p>JÃ¤rjestÃ¤minen tapahtuu edelleen luokan <code>Collections</code> metodin <code>sort</code> avulla. Metodi saa nyt toiseksi parametrikseen jÃ¤rjestyksen mÃ¤Ã¤rÃ¤Ã¤vÃ¤n luokan olion:</p>

<pre class="sh_java">
Maali maalintekijat = new Maali();
Collections.sort(pelaajat, maalintekijat);
System.out.println("NHL parhaat maalintekijÃ¤t\n");

// tulostetaan maalipÃ¶rssi
</pre>

  <p>JÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤ olio voidaan myÃ¶s luoda suoraan sort-kutsun yhteydessÃ¤:</p>

<pre class="sh_java">
Collections.sort(pelaajat, new Maali());
System.out.println("NHL parhaat maalintekijÃ¤t\n");

// tulostetaan maalipÃ¶rssi
</pre>

  <p>Kun sort-metodi saa jÃ¤rjestyksen mÃ¤Ã¤rittelevÃ¤n olion parametrina, se kÃ¤yttÃ¤Ã¤ olion <code>compareTo()</code>-metodia pelaajia jÃ¤rjestÃ¤essÃ¤Ã¤n.</p>


</div>

<div class="tehtavat">

  <h3>Olioiden samuus</h3>

<p>
<b>pois?</b>
</p>

  <p>Kaikki oliot ovat tyyppiÃ¤ <code>Object</code>, joten minkÃ¤ tahansa tyyppisen olion voi antaa parametrina <code>Object</code>-tyyppisiÃ¤ parametreja vastaanottavalle metodille.</p>

  <p>TehtÃ¤vÃ¤n mukana tulee rajapinta <code>Vertaaja</code>. Toteuta pakkaukseen <code>samuus</code> luokka <code>OlioidenVertaaja</code>, joka toteuttaa rajapinnan <code>Vertaaja</code>. Metodien tulee toimia seuraavasti:</p>

  <ul>
    <li><strong>public boolean samaOlio(Object o1, Object o2)</strong> metodi palauttaa true, mikÃ¤li parametrina saatujen olioiden viitteet ovat samat, muutoin metodi palauttaa false. Olioiden viitteiden samuutta vertaillaan &quot;==&quot;-ilmaisulla.</li>
    <li><strong>public boolean vastaavat(Object o1, Object o2)</strong> metodi palauttaa true, mikÃ¤li parametrina saadut oliot ovat samanlaiset. Muutoin metodi palauttaa false. KÃ¤ytÃ¤ tÃ¤ssÃ¤ vertailussa <code>equals</code>-metodia. Tarkemmin <code>equals</code>-metodin toiminnasta <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#equals(java.lang.Object)">Javan Object luokan APIsta</a>. Huomaa, ettÃ¤ <code>equals</code>-metodin toiminta riippuu siitÃ¤, onko verrattavan olion luokka korvannut <code>Object</code>-luokassa mÃ¤Ã¤ritellyn <code>equals</code>-metodin. </li>
    <li><strong>public boolean samacharacterStringEsitys(Object o1, Object o2)</strong> metodi palauttaa true, mikÃ¤li parametrina saatujen olioiden characterStringesitykset (metodin <code>toString</code>-palauttamat characterStringt) ovat samat. Muutoin metodi palauttaa false.</li>
  </ul>

  <p>TehtÃ¤vÃ¤n mukana tulee luokka <code>Person</code>, jossa <code>equals</code>- ja <code>compareTo</code>-metodit on korvattu. Kokeile toteuttamiesi metodien toimintaa seuraavalla esimerkkikoodilla.</p>

<pre class="sh_java">
   OlioidenVertaaja vertaaja = new OlioidenVertaaja();
   Person henkilo1 = new Person("221078-123X", "Pekka", "Helsinki");
   Person henkilo2 = new Person("221078-123X", "Pekka", "Helsinki");  // tÃ¤ysin samansisÃ¤ltÃ¶inen kuin eka
   Person henkilo3 = new Person("110934-123X", "Pekka", "Helsinki");  // eri pekka vaikka asuukin helsingissÃ¤

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo1));
   System.out.println(vertaaja.samaOlio(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo2));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo3));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo2));

   Person henkilo4 = new Person("221078-123X", "Pekka", "Savonlinna"); // henkilo1:n pekka mutta asuinpaikka muuttuu

   System.out.println(vertaaja.samaOlio(henkilo1, henkilo4));
   System.out.println(vertaaja.vastaavat(henkilo1, henkilo4));
   System.out.println(vertaaja.samacharacterStringEsitys(henkilo1, henkilo4));
</pre>

  <p>YllÃ¤olevan koodin tulostuksen pitÃ¤isi olla seuraava:</p>

<pre>
true
false
true
false
true
false
true
false
</pre>


<h3>Kuviot</h3>

    <p>TehtÃ¤vÃ¤pohjan mukana tulee luokat <code>Ympyra</code>, <code>Suorakulmio</code> ja <code>TasasivuinenKolmio</code>. Luokat liittyvÃ¤t samaan aihepiiriin, ja niillÃ¤ on hyvin paljon yhteistÃ¤ toiminnallisuutta. Tutustu luokkiin ennenkuin lÃ¤hdet tekemÃ¤Ã¤n, jolloin hahmotat tarkemmin syyt muutoksille. Jos huomaat ettÃ¤ luokissa on alustavasti sisennys hieman pielessÃ¤, kannattaa sisennys hoitaa kuntoon luettavuuden helpottamiseksi.</p>

    <h4>Kuvio</h4>

    <p>Toteuta pakkaukseen <code>kuviot</code> abstrakti luokka <code>Kuvio</code>, jossa on kuvioihin liittyvÃ¤Ã¤ toiminnallisuutta. Luokan kuvio tulee sisÃ¤ltÃ¤Ã¤ konstruktori <code>public Kuvio(int x, int y)</code>, metodit <code>public int getX()</code>, <code>public int getY()</code>, sekÃ¤ abstraktit metodit <code>public abstract double pintaAla()</code> ja <code>public abstract double piiri()</code>.</p>


    <h4>Ympyra perii kuvion</h4>

    <p>Muuta luokan <code>Ympyra</code> toteutusta siten, ettÃ¤ se perii luokan <code>Kuvio</code>. Luokan <code>Ympyra</code> ulkoinen toiminnallisuus ei saa muuttua, eli sen tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse. Muistathan ettÃ¤ konstruktorikutsun <code>super</code> avulla voit kÃ¤yttÃ¤Ã¤ yliluokan konstruktoria. Kun metodi <code>public int getX()</code> on toteutettu jo yliluokassa se ei tarvitse erillistÃ¤ toteutusta luokassa <code>Ympyra</code>.</p>

<pre class="sh_java">
        Kuvio kuvio = new Ympyra(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 706.85834...
Piiri 94.24777...
</pre>

    <h4>Suorakulmio ja Tasakylkinen kolmio perii kuvion</h4>

    <p>Muuta luokkien <code>Suorakulmio</code> ja <code>TasakylkinenKolmio</code> toteutusta siten, ettÃ¤ ne perivÃ¤t luokan <code>Kuvio</code>. Luokkien ulkoinen toiminnallisuus ei saa muuttua, eli niiden tulee tarjota samat metodit kuin aiemminkin -- joko luokan <code>Kuvio</code> avulla tai itse.</p>

<pre class="sh_java">
        Kuvio kuvio = new Suorakulmio(10, 10, 15, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
        System.out.println("");

        kuvio = new TasakylkinenKolmio(10, 10, 15);
        System.out.println("X " + kuvio.getX());
        System.out.println("Y " + kuvio.getY());
        System.out.println("Pinta-ala " + kuvio.pintaAla());
        System.out.println("Piiri " + kuvio.piiri());
</pre>

<pre>
X 10
Y 10
Pinta-ala 225.0
Piiri 60.0

X 10
Y 10
Pinta-ala 97.42785...
Piiri 45.0
</pre>


</div>



<h3>TreeMap</h3>

        <p>Joukkojen jÃ¤rjestyksessÃ¤ pitÃ¤minen onnistuu <code>Set</code> rajapinnan toteuttavan <code>TreeSet</code>-olion avulla. Aiemmassa <code>Tehtavakirjanpito</code>-esimerkissÃ¤ henkilÃ¶kohtaiset tehtÃ¤vÃ¤pisteet tallennettiin <code>Map</code>-rajapinnan toteuttavaan <code>HashMap</code>-olioon. Kuten <code>HashSet</code>, <code>HashMap</code> ei pidÃ¤ alkioita jÃ¤rjestyksessÃ¤. Rajapinnasta <code>Map</code> on olemassa toteutus <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html" target="_blank">TreeMap</a></code>, jossa hajautustaulun avaimia pidetÃ¤Ã¤n jÃ¤rjestyksessÃ¤. Muutetaan <code>Tehtavakirjanpito</code>-luokkaa siten, ettÃ¤ henkilÃ¶kohtaiset pisteet tallennetaan <code>TreeMap</code>-tyyppiseen hajautustauluun.</p>

<pre class="sh_java">
public class Tehtavakirjanpito {
    private Map&lt;String, Set&lt;Integer&gt;&gt; tehdytTehtavat;

    public Tehtavakirjanpito() {
        this.tehdytTehtavat = new TreeMap&lt;String, Set&lt;Integer&gt;&gt;();
    }

    public void lisaa(String kayttaja, int tehtava) {
        if (!this.tehdytTehtavat.containsKey(kayttaja)) {
            this.tehdytTehtavat.put(kayttaja, new TreeSet&lt;Integer&gt;());
        }

        Set&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
        tehdyt.add(tehtava);
    }

    public void tulosta() {
        for (String kayttaja: this.tehdytTehtavat.keySet()) {
            System.out.println(kayttaja + ": " + this.tehdytTehtavat.get(kayttaja));
        }
    }
}
</pre>

        <p>Muunsimme samalla <code>Set</code>-rajapinnan toteutukseksi <code>TreeSet</code>-luokan. Huomaa ettÃ¤ koska olimme kÃ¤yttÃ¤neet rajapintoja, muutoksia tuli hyvin pieneen osaan koodista. Etsi kohdat jotka muuttuivat!</p>

        <p>KÃ¤yttÃ¤jÃ¤kohtaiset tehtÃ¤vÃ¤t voidaan nyt tulostaa jÃ¤rjestyksessÃ¤.</p>

<pre class="sh_java">
        Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 4);
        kirjanpito.lisaa("Mikael", 3);
        kirjanpito.lisaa("Mikael", 3);

        kirjanpito.lisaa("Pekka", 4);
        kirjanpito.lisaa("Pekka", 4);

        kirjanpito.lisaa("Matti", 1);
        kirjanpito.lisaa("Matti", 2);

        kirjanpito.tulosta();
</pre>

<pre>
Matti: [1, 2]
Mikael: [3, 4]
Pekka: [4]
</pre>


    <p>Luokka <code>TreeMap</code> vaatii ettÃ¤ <em>avaimena</em> kÃ¤ytetyn luokan tulee toteuttaa <code>Comparable</code>-rajapinta. Jos luokka ei toteuta rajapintaa <code>Comparable</code>, voidaan luokalle <code>TreeMap</code> antaa konstruktorin parametrina <code>Comparator</code>-luokan toteuttama olio aivan kuten <code>TreeSet</code>-luokalle.</p>



<div class="tehtavat">



  <h3>SÃ¤hkÃ¶posteja</h3>

  <p>TehtÃ¤vÃ¤nÃ¤si on toteuttaa sÃ¤hkÃ¶postiohjelmaan komponentti, joka sÃ¤ilÃ¶Ã¶ viestejÃ¤. TehtÃ¤vÃ¤pohjan mukana tulee luokka <code>Sahkoposti</code>, joka esittÃ¤Ã¤ sÃ¤hkÃ¶postiviestiÃ¤. Luokalla <code>Sahkoposti</code> on oliomuuttujat:</p>

  <p>
    <ul>
      <li>saapumisaika (yksinkertaisesti kokonaisluku)</li>
      <li>lÃ¤hettÃ¤jÃ¤</li>
      <li>otsikko</li>
      <li>sisÃ¤ltÃ¶</li>
    </ul>
  </p>

  <p>Toteutetaan tÃ¤ssÃ¤ luokka <code>Viestivarasto</code>, joka tarjoaa sÃ¤hkÃ¶postien hallintaan liittyviÃ¤ toimintoja.</p>

  <h4>Viestivarasto, lisÃ¤Ã¤minen ja hakeminen</h4>

<p>Luo pakkaukseen <code>posti</code> luokka <code>Viestivarasto</code>, ja lisÃ¤Ã¤ sille seuraavat metodit:</p>

<p>
  <ul>
    <li><code>public void lisaa(Sahkoposti s)</code> lisÃ¤Ã¤ viestin</li>
    <li><code>public Sahkoposti hae(String otsikko)</code> palauttaa viestin jolla on annettu otsikko tai <em>null</em> jos sellaista ei ole. </li>
  </ul>
</p>

<p>Voit olettaa ettÃ¤ millÃ¤Ã¤n kahdella viestillÃ¤ ei ole samaa otsikkoa.</p>



  <h4>Ajan perusteella hakeminen</h4>

  <p>LisÃ¤Ã¤ luokkaan <code>Viestivarasto</code> seuraavat metodit</p>

<p>
  <ul>
    <li><code>public Sahkoposti hae(int aika)</code> palauttaa viestin joka saapui annettuun aikaan tai <em>null</em> jos sellaista ei ole. Voit olettaa ettÃ¤ millÃ¤Ã¤n kahdella viestillÃ¤ ei ole samaa saapumisaikaa.</li>
    <li><code>public Sahkoposti haeUusinViesti()</code> hakee uusimman viestin (eli sen jonka saapumisaika on isoin) ai <em>null</em> jos sellaista ei ole.</li>
    <li><code>public Sahkoposti haeUusinViesti(int ylaraja)</code> hakee uusimman viestin joka ei ole saapunut annetun ajan <code>ylaraja</code> jÃ¤lkeen. Metodi palauttaa <em>null</em> jos tÃ¤llaista viestiÃ¤ ei ole.</li>
  </ul>
</p>

  <p><em>Huom!</em> Kannattaa kÃ¤yttÃ¤Ã¤ kahta erillistÃ¤ rakennetta viestien tallentamiseen. Otsikon perusteella tallentamiseen voit kÃ¤yttÃ¤Ã¤ <code>HashMap</code>pia, ja viestien tallentamiseen ajan mukaan <code>TreeMap</code>pia. NÃ¤in saat toteutettua hae-operaatiot tehokkaasti. Tutustu myÃ¶s <code>TreeMap</code>in metodeihin <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#lastKey()" target="_blank">lastKey()</a></code> ja <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html#floorKey()" target="_blank">floorKey()</a></code>.</p>

</div>


<h2>Ohjelmien automaattinen testaaminen</h2>

<p><em>Errare humanum est</em></p>

<p>Ihminen on erehtyvÃ¤inen ja paraskin ohjelmoija tekee virheitÃ¤. Ohjelman kehitysvaiheessa tapahtuvien virheiden lisÃ¤ksi huomattava osa virheistÃ¤ syntyy olemassa olevaa ohjelmaa muokattaessa. Ohjelman muokkauksen aikana tehdyt virheet eivÃ¤t vÃ¤lttÃ¤mÃ¤ttÃ¤ nÃ¤y muokattavassa osassa, vaan voivat ilmaantua vÃ¤lillisesti erillisessÃ¤ osassa ohjelmaa: osassa, joka kÃ¤yttÃ¤Ã¤ muutettua osaa.</p>

<p>Ohjelmien automaattinen testaaminen tarkoittaa toistettavien testien luomista. TesteillÃ¤ varmistetaan ettÃ¤ ohjelma toimii halutusti, ja ettÃ¤ ohjelma sÃ¤ilyttÃ¤Ã¤ toiminnallisuutensa myÃ¶s muutosten jÃ¤lkeen. Sanalla <em>automaattinen</em> painotetaan sitÃ¤, ettÃ¤ luodut testit ovat toistettavia ja ettÃ¤ ne voidaan suorittaa aina haluttaessa -- ohjelmoijan ei tarvitse olla lÃ¤snÃ¤ testejÃ¤ suoritettaessa.</p>

<p>Otimme aiemmin askeleita kohti testauksen automatisointia antamalla Scanner-oliolle parametrina characterStringn, jonka se tulkitsee kÃ¤yttÃ¤jÃ¤n nÃ¤ppÃ¤imistÃ¶ltÃ¤ antamaksi syÃ¶tteeksi. Automaattisessa testaamisessa testaaminen viedÃ¤Ã¤n viedÃ¤ pidemmÃ¤lle: koneen tehtÃ¤vÃ¤nÃ¤ on myÃ¶s tarkistaa ettÃ¤ ohjelman tuottama vastaus on odotettu.</p>

<p>Automaattisen testauksen tÃ¤llÃ¤ kurssilla painotettu osa-alue on <em>yksikkÃ¶testaus</em>, jossa testataan ohjelman pienten osakokonaisuuksien -- metodien ja luokkien -- toimintaa. YksikkÃ¶testaamiseen kÃ¤ytetÃ¤Ã¤n Javalla yleensÃ¤ <a href="http://www.junit.org" target="_blank">JUnit</a>-testauskirjastoa.</p>

<h3>Pino ja automaattiset testit</h3>

<p>Pino on kaikille ihmisille tuttu asia. Esimerkiksi ravintola Unicafessa lautaset ovat yleensÃ¤ pinossa. Pinon pÃ¤Ã¤ltÃ¤ voi ottaa lautasen ja pinon pÃ¤Ã¤lle voi lisÃ¤tÃ¤ lautasia. On myÃ¶s helppo selvittÃ¤Ã¤ onko pinossa vielÃ¤ lautasia jÃ¤ljellÃ¤.</p>

<p>Pino on myÃ¶s ohjelmoinnissa usein kÃ¤ytetty aputietorakenne. Rajapintana lukuja sisÃ¤ltÃ¤vÃ¤ pino nÃ¤yttÃ¤Ã¤ seuraavalta.</p>

<pre class="sh_java">
public interface Pino {
    boolean tyhja();
    boolean taynna();
    void pinoon(int luku);
    int pinosta();
    int huipulla();
    int lukuja();
}
</pre>

<p>Rajapinnan mÃ¤Ã¤rittelemien metodien on tarkoitus toimia seuraavasti:</p>

<ul>
  <li><code>public boolean tyhja()</code> palauttaa true jos pino on tyhjÃ¤</li>
  <li><code>public boolean taynna()</code> palauttaa true jos pino on tÃ¤ynnÃ¤</li>
  <li><code>public void pinoon(int luku)</code> laittaa parametrina olevan luvun pinon pÃ¤Ã¤lle</li>
  <li><code>public int huipulla()</code> kertoo pinon huipulla olevan alkion</li>
  <li><code>public int pinosta()</code> poistaa ja palauttaa pinon pÃ¤Ã¤llÃ¤ olevan alkion</li>
  <li><code>public int lukuja()</code> kertoo pinossa olevien lukujen mÃ¤Ã¤rÃ¤n</li>
  <li><code>public int tilaa()</code> kertoo pinon vapaan tilan mÃ¤Ã¤rÃ¤n</li>
</ul>

<p>Toteutetaan rajapinnan <code>Pino</code> toteuttava luokka <code>OmaPino</code>, johon talletetaan lukuja. Pinoon mahtuvien lukujen mÃ¤Ã¤rÃ¤ annetaan pinon konstruktorissa. Toteutamme pinon hieman aiemmasta poikkeavasti -- emme testaa ohjelmaa pÃ¤Ã¤ohjelman avulla, vaan  kÃ¤ytÃ¤mme pÃ¤Ã¤ohjelman sijasta automatisoituja JUnit-testejÃ¤ ohjelman testaamiseen.</p>

<h4 class="req">Tutustuminen JUnitiin</h4>

<p>NetBeansissa olevat ohjelmamme ovat tÃ¤hÃ¤n asti sijainneet aina <em>Source Packages</em>issa tai sen sisÃ¤llÃ¤ olevissa pakkauksissa. Ohjelman lÃ¤hdekoodit tulevat aina kansioon <em>Source Packages</em>. Automaattisia testejÃ¤ luodessa testit luodaan valikon <em>Test Packages</em> alle. Uusia JUnit-testejÃ¤ voi luoda valitsemalla projektin oikealla hiirennapilla ja valitsemalla avautuvasta valikosta <code>New -> JUnit Test...</code>. Jos vaihtoehto JUnit test ei nÃ¤y listassa, lÃ¶ydÃ¤t sen valitsemalla <em>Other</em>.</p>

<p><img src="img-ohja/testaus/new-junit-test.png"/></p>

<p>JUnit-testit sijaitsevat luokassa. Uutta testitiedostoa luodessa ohjelma pyytÃ¤Ã¤ testitiedoston nimen. Tyypillisesti nimeksi annetaan testattavan luokan tai toiminnallisuuden nimi. Luokan nimen tulee aina pÃ¤Ã¤ttyÃ¤ sanaan <code>Test</code>. Esimerkiksi alla luodaan testiluokka <code>PinoTest</code>, joka sijaitsee pakkauksessa <code>pino</code>. NetBeans haluaa luoda kÃ¤yttÃ¶Ã¶mme myÃ¶s valmista runkoa testiluokalle -- joka kÃ¤y hyvin.</p>

<p><img src="img-ohja/testaus/pinotest.png"/></p>

<p>Jos NetBeans kysyy minkÃ¤ JUnit-version haluat kÃ¤yttÃ¶Ã¶si, valitse <code>JUnit 4.x</code>.</p>

<p><img src="img-ohja/testaus/junit4.png"/></p>

<p>Kun testiluokka <code>PinoTest</code> on luotu, nÃ¤kyy se projektin valikon <em>Test Packages</em> alla.</p>

<p><img src="img-ohja/testaus/pinotest-luotu.png"/></p>

<p>Luokka <code>PinoTest</code> nÃ¤yttÃ¤Ã¤ aluksi seuraavalta</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    public PinoTest() {
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
    }

    @Before
    public void setUp() {
    }

    @After
    public void tearDown() {
    }
    // TODO add test methods here.
    // The methods must be annotated with annotation @Test. For example:
    //
    // @Test
    // public void hello() {}
}
</pre>

<p>Meille oleellisia osia luokassa <code>PinoTest</code> ovat metodit <code>public void setUp</code>, jonka ylÃ¤puolella on merkintÃ¤ <code>@Before</code>, ja kommentoitu metodipohja <code>public void hello()</code>, jonka ylÃ¤puolella on merkintÃ¤ <code>@Test</code>. Metodit, joiden ylÃ¤puolella on merkintÃ¤ <code>@Test</code> ovat ohjelman toiminnallisuutta testaavia testimetodeja. Metodi <code>setUp</code> taas suoritetaan ennen jokaista testiÃ¤.</p>

<p>Muokataan luokkaa <code>PinoTest</code> siten, ettÃ¤ sillÃ¤ testataan rajapinnan <code>Pino</code> toteuttamaa luokkaa <code>OmaPino</code>. ÃlÃ¤ vÃ¤litÃ¤ vaikkei luokkaa <code>OmaPino</code> ole vielÃ¤ luotu. Pino on testiluokan oliomuuttuja, joka alustetaan ennen jokaista testiÃ¤ metodissa <code>setUp</code>.</p>

<pre class="sh_java">
package pino;

import org.junit.*;
import static org.junit.Assert.*;

public class PinoTest {

    Pino pino;

    @Before
    public void setUp() {
        pino = new OmaPino(3);
    }

    @Test
    public void alussaTyhja() {
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisayksenJalkeenEiTyhja() {
        pino.pinoon(5);
        assertFalse(pino.tyhja());
    }

    @Test
    public void lisattyAlkioTuleePinosta() {
        pino.pinoon(3);
        assertEquals(3, pino.pinosta());
    }

    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }

    @Test
    public void lisatytAlkiotTulevatPinostaOikeassaJarjestyksessa() {
        pino.pinoon(1);
        pino.pinoon(2);
        pino.pinoon(3);

        assertEquals(3, pino.pinosta());
        assertEquals(2, pino.pinosta());
        assertEquals(1, pino.pinosta());
    }

    @Test
    public void tyhjennyksenJalkeenPinoonLaitettuAlkioTuleeUlosPinosta() {
        pino.pinoon(1);
        pino.pinosta();

        pino.pinoon(5);

        assertEquals(5, pino.pinosta());
    }

    // ...
}
</pre>

<p>Jokainen testi, eli merkinnÃ¤llÃ¤ <code>@Test</code> varustettu metodi, alkaa tilanteesta, jossa on luotu uusi tyhjÃ¤ pino. Jokainen yksittÃ¤inen @Test-merkitty metodi on oma testinsÃ¤. YksittÃ¤isellÃ¤ testimetodilla testataan aina yhtÃ¤ pientÃ¤ osaa pinon toiminnallisuudesta. Testit suoritetaan toisistaan tÃ¤ysin riippumattomina, eli jokainen testi alkaa "puhtaaltÃ¤ pÃ¶ydÃ¤ltÃ¤", <code>setUp</code>-metodin alustamasta tilanteesta.</p>

<p>YksittÃ¤iset testit noudattavat aina samaa kaavaa. Ensin luodaan tilanne jossa tapahtuvaa toimintoa halutaan testata, sitten tehdÃ¤Ã¤n testattava toimenpide, ja lopuksi tarkastetaan onko tilanne odotetun kaltainen. Esimerkiksi seuraava testi testaa ettÃ¤ lisÃ¤yksen ja poiston jÃ¤lkeen pino on taas tyhjÃ¤ -- huomaa myÃ¶s kuvaava testimetodin nimentÃ¤:</p>

<pre class="sh_java">
    @Test
    public void lisayksenJaPoistonJalkeenPinoOnTaasTyhja() {
        pino.pinoon(3);
        pino.pinosta();
        assertTrue(pino.tyhja());
    }
</pre>

<p>YllÃ¤oleva testi testaa toimiiko metodi <code>tyhja()</code> jos pino on tyhjennetty. Ensin laitetaan pinoon luku metodilla <code>pinoon</code>, jonka jÃ¤lkeen pino tyhjennetÃ¤Ã¤n kutsumalla metodia <code>pinosta()</code>. TÃ¤llÃ¶in on saatu aikaan tilanne jossa pinon <em>pitÃ¤isi</em> olla tyhjennetty. ViimeisellÃ¤ rivillÃ¤ testataan, ettÃ¤ pinon metodi <code>tyhja()</code> palauttaa arvon <code>true</code> testausmetodilla <code>assertTrue()</code>. Jos metodi <code>tyhja()</code> ei palauta arvoa <code>true</code> nÃ¤emme testejÃ¤ suorittaessa virheen. </p>

<p>Jokainen testi pÃ¤Ã¤ttyy jonkun <code>assert</code>-metodin kutsuun. Esimerkiksi metodilla <code>assertEquals()</code> voidaan varmistaa onko metodin palauttama luku tai characterString haluttu, ja metodilla <code>assertTrue()</code> varmistetaan ettÃ¤ metodin palauttama arvo on <code>true</code>. Erilaiset <code>assert</code>-metodit saadaan kÃ¤yttÃ¶Ã¶n luokan alussa olevalla mÃ¤Ã¤rittelyllÃ¤ <code>import static org.junit.Assert.*;</code>.

<p>Testit suoritetaan joko painamalla <em>alt</em> ja <em>F6</em> tai valitsemalla <em>Run -> Test project</em>. (Macintosh-koneissa tulee painaa <em>ctrl</em> ja <em>F6</em>). Punainen vÃ¤ri ilmaisee ettÃ¤ testin suoritus epÃ¤onnistui -- testattava toiminnallisuus ei toiminut kuten toivottiin. VihreÃ¤ vÃ¤ri kertoo ettÃ¤ testin testaama toiminnallisuus toimi kuten haluttiin.</p>

<h4 class="req">Luokan OmaPino toteutus</h4>

<p>Pinon toteuttaminen testien avulla tapahtuisi askel kerrallaan siten, ettÃ¤ lopulta kaikki testit toimivat. Ohjelman rakentaminen aloitetaan yleensÃ¤ hyvin varovasti. Rakennetaan ensin luokka <code>OmaPino</code> siten, ettÃ¤ ensimmÃ¤inen testi <em>alussaTyhja</em> alkaa toimimaan. ÃlÃ¤ tee mitÃ¤Ã¤n kovin monimutkaista, "quick and dirty"-ratkaisu kelpaa nÃ¤in alkuun. Kun testi menee lÃ¤pi (eli nÃ¤yttÃ¤Ã¤ vihreÃ¤Ã¤), siirry ratkaisemaan seuraavaa kohtaa.</p>

<p>Testi <em>alussaTyhja</em> menee lÃ¤pi aina kun palautamme arvon <code>true</code> metodista <code>tyhja</code>.</p>

<pre class="sh_java">
package pino;

import java.util.ArrayList;
import java.util.List;

public class OmaPino implements Pino {

    public OmaPino(int maksimikoko) {
    }

    @Override
    public boolean tyhja() {
        return true;
    }

    // tyhjÃ¤t metodirungot
</pre>

<p>SiirrytÃ¤Ã¤n ratkaisemaan kohtaa <em>lisayksenJalkeenEiTyhja</em>. Tarvitsemme toteutuksen metodille <code>pinoon</code>. Yksi lÃ¤hestymistapa on muokata luokkaa <code>OmaPino</code> siten, ettÃ¤ se sisÃ¤ltÃ¤Ã¤ taulukon. Taulukkoa kÃ¤ytetÃ¤Ã¤n, ettÃ¤ pinottavat values talletetaan pinon taulukkoon yksi kerrallaan. Seuraava kuvasarja selkeyttÃ¤Ã¤ taulukossa olevien alkioiden pinoon laittamista ja pinosta ottamista.</p>

<pre>
<font color ="red">pino = new OmaPino(4);</font>

  0   1   2   3
-----------------
|   |   |   |   |
-----------------
alkioita: 0

<font color ="red">pino.pinoon(5);</font>

  0   1   2   3
-----------------
| 5 |   |   |   |
-----------------
alkiota: 1

<font color ="red">pino.pinoon(3);</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2

<font color ="red">pino.pinoon(7);</font>

  0   1   2   3
-----------------
| 5 | 3 | 7 |   |
-----------------
alkiota: 3

<font color ="red">pino.pinosta();</font>

  0   1   2   3
-----------------
| 5 | 3 |   |   |
-----------------
alkiota: 2
</pre>

<p>Ohjelman tulee siis muistaa kuinka monta alkiota pinossa on. Uusi alkio laitetaan jo pinossa olevien perÃ¤Ã¤n. Alkion poisto aiheuttaa sen, ettÃ¤ taulukon viimeinen kÃ¤ytÃ¶ssÃ¤ ollut paikka vapautuu ja alkiomÃ¤Ã¤rÃ¤n muistavan muuttujan arvo pienenee.</p>

<p>Luokan <code>OmaPino</code> toteutusta jatketaan askel kerrallaan kunnes kaikki testit menevÃ¤t lÃ¤pi. Jossain vaiheessa ohjelmoija todennÃ¤kÃ¶isesti huomaisi, ettÃ¤ taulukko kannattaa vaihtaa <code>ArrayList</code>-rakenteeksi.</p>

<p>Huomaat todennÃ¤kÃ¶isesti yllÃ¤olevan esimerkin luettuasi ettÃ¤ olet jo tehnyt hyvin monta testejÃ¤ kÃ¤yttÃ¤vÃ¤Ã¤ ohjelmaa. Osa TMC:n toiminnallisuudesta rakentuu JUnit-testien varaan, ongelmat ovat varsinkin kurssin alkupuolella pilkottu pieniin testeihin, joiden avulla ohjelmoijaa on ohjattu eteenpÃ¤in. TMC:n mukana tulevat testit ovat kuitenkin usein monimutkaisempia kuin ohjelmien normaalissa automaattisessa testauksessa niiden tarvitsee olla. TMC:ssÃ¤ ja kurssilla kÃ¤ytettÃ¤vien testien kirjoittajien tulee muunmuassa varmistaa luokkien olemassaolo, jota normaalissa automaattisessa testauksessa harvemmin tarvitsee tehdÃ¤.</p>

<p>Harjoitellaan seuraavaksi ensin testien lukemista, jonka jÃ¤lkeen kirjoitetaan muutama testi.</p>

<div class="tehtavat" id="viikko11">



  <h3>TehtÃ¤vÃ¤lista</h3>

  <p>TehtÃ¤vÃ¤pohjassa on rajapinnan <code>Tehtavalista</code> toteuttava luokka <code>MuistiTehtavalist</code>. Ohjelmaa varten on koodattu valmiiksi testit, joita ohjelma ei kuitenkaan lÃ¤pÃ¤ise. TehtÃ¤vÃ¤nÃ¤si on tutustua testiluokkaan <code>TehtavalistaTest</code>, ja korjata luokka <code>MuistiTehtavalista</code> siten, ettÃ¤ ohjelman testit menevÃ¤t lÃ¤pi.</p>

  <p>Huom! TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ sinun ei tarvitse koskea  testiluokkaan <code>TehtavalistaTest</code>.</p>


  <h3>Lukutilasto</h3>

  <p><em>Huom!</em> TÃ¤ssÃ¤ tehtÃ¤vÃ¤ssÃ¤ on jo mukana testiluokka, johon sinun tulee kirjoittaa lisÃ¤Ã¤ testejÃ¤. Vastauksen oikeellisuus testataan vasta TMC-palvelimella: tehtÃ¤vÃ¤stÃ¤ saa pisteet vasta kun <em>molemmat</em> tehtÃ¤vÃ¤t on suoritettu palvelimella hyvÃ¤ksytysti. Ole tarkka metodien nimennÃ¤n <em>ja</em> lisÃ¤ttyjen lukujen kanssa.</p>

  <p>TehtÃ¤vÃ¤ssÃ¤ tulee pakkauksessa <code>tilasto</code> sijaitseva luokka <code>Lukutilasto</code>.</p>

<ul>
  <li><code>public void lisaaLuku(int luku)</code><br/>LisÃ¤Ã¤ annetun luvun lukutilastoon.</li>
  <li><code>public int sum()</code><br/>Palauttaa tilastossa olevien lukujen summan.</li>
  <li><code>public int lukujenMaara()</code><br/>Palauttaa tilastossa olevien lukujen maaran.</li>
  <li><code>public boolean sisaltaa(int luku)</code><br/>Palauttaa totuusarvon, joka kertoo onko parametrina annettu luku tilastossa.</li>
</ul>

  <p>Testikansiossa olevassa pakkauksessa <code>tilasto</code> on luokka <code>LukutilastoTest</code>, johon sinun tulee lisÃ¤tÃ¤ uusia testimetodeja.</p>

  <h4>Lukujen mÃ¤Ã¤rÃ¤n kasvamisen tarkistus</h4>

  <p>LisÃ¤Ã¤ testiluokkaan testimetodi <code>public void lukujenMaaraKasvaaKahdellaKunLisataanKaksiLukua()</code>, jossa lukutilastoon lisÃ¤tÃ¤Ã¤n values 3 ja 5. TÃ¤mÃ¤n jÃ¤lkeen metodissa tarkistetaan ettÃ¤ lukutilastossa on kaksi lukua kÃ¤yttÃ¤en lukutilaston metodia lukujenMaara. KÃ¤ytÃ¤ <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>

  <h4>Summan tarkistus yhdellÃ¤ luvulla</h4>

  <p>LisÃ¤Ã¤ testiluokkaan testimetodi <code>public void summaOikeinYhdellaLuvulla()</code>, jossa lukutilastoon lisÃ¤tÃ¤Ã¤n luku 3. TÃ¤mÃ¤n jÃ¤lkeen metodissa tarkistetaan lukutilaston summa-metodin avulla ettÃ¤ tilastossa olevien lukujen summa on 3.  KÃ¤ytÃ¤ <code>Assert</code>-luokan <code>assertEquals</code>-metodia palautettujen arvojen tarkastamiseen.</p>
</div>



<h3>JÃ¤tkÃ¤nshakin sovelluslogiikka (pakollinen)</h3>

<p><em>Huom!</em> tÃ¤mÃ¤ tehtÃ¤vÃ¤ on pakollinen yliopistoon hakeville.</p>

<p><em>TÃ¤mÃ¤ tehtÃ¤vÃ¤ on kolmen yksittÃ¤isen tehtÃ¤vÃ¤pisteen arvoinen.</em> TehtÃ¤vÃ¤ssÃ¤ toteutetaan sovelluslogiikka jÃ¤tkÃ¤nshakille ja harjoitellaan ohjelmarakenteen osittaista omatoimista suunnittelua.</p>

<p>TehtÃ¤vÃ¤pohjassa tulee mukana kÃ¤yttÃ¶liittymÃ¤ <a href="http://fi.wikipedia.org/wiki/Ristinolla">jÃ¤tkÃ¤nshakille</a>, jossa pelilaudan koko on aina 3x3 ruutua. KÃ¤yttÃ¶liittymÃ¤ huolehtii ainoastaan pelilaudalla tehtyihin tapahtumiin reagoimisesta, sekÃ¤ pelilaudan ja pelitilanteen tietojen pÃ¤ivittÃ¤misestÃ¤. Pelin logiikka on erotettu <code>JatkanshakinSovelluslogiikka</code>-rajapinnan avulla omaksi luokakseen.</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public interface JatkanshakinSovelluslogiikka {
    char getNykyinenVuoro();
    int getMerkkienMaara();

    void asetaMerkki(int sarake, int rivi);
    char getMerkki(int sarake, int rivi);

    boolean isPeliLoppu();
    char getVoittaja();
}
</pre>


<p>Rajapinnan <code>JatkanshakinSovelluslogiikka</code> lisÃ¤ksi tehtÃ¤vÃ¤pohjassa on apuluokka, joka mÃ¤Ã¤rittelee pelilaudan ruutujen mahdolliset tilat <code>char</code>-tyyppisinÃ¤ kirjaimina. Ruutu voi olla joko tyhjÃ¤, tai siinÃ¤ voi olla risti tai nolla. Apuluokassa <code>Jatkanshakki</code> on nÃ¤ille mÃ¤Ã¤rittelyt:</p>

<pre class="sh_java">
package jatkanshakki.sovelluslogiikka;

public class Jatkanshakki {
    public static final char RISTI = 'X';
    public static final char NOLLA = 'O';
    public static final char TYHJA = ' ';
}
</pre>

<p>TehtÃ¤vÃ¤nÃ¤si on tÃ¤ydentÃ¤Ã¤ pakkauksessa <code>jatkanshakki.sovelluslogiikka</code> olevaa rajapinnan <code>JatkanshakinSovelluslogiikka</code> toteuttavaa luokkaa <code>OmaJatkanshakinSovelluslogiikka</code>. Luokka <code>OmaJatkanshakinSovelluslogiikka</code> mahdollistaa jÃ¤tkÃ¤nshakin pelaamisen.</p>

<p>Rajapinta <code>JatkanshakinSovelluslogiikka</code> mÃ¤Ã¤rittelee seuraavat toiminnot, jotka luokan <code>OmaJatkanshakinSovelluslogiikka</code> tulee toteuttaa:</p>

  <ul>
    <li><strong>char getNykyinenVuoro()</strong> palauttaa pelaajan merkkiÃ¤ vastaavan arvon: <code>RISTI</code>, <code>NOLLA</code> tai pelin pÃ¤Ã¤tyttyÃ¤ <code>TYHJA</code></li>
    <li><strong>int getMerkkienMaara()</strong> palauttaa pelilaudalle tÃ¤hÃ¤n mennessÃ¤ asetettujen merkkien mÃ¤Ã¤rÃ¤n (vÃ¤lillÃ¤ 0-9)</li>
    <li><strong>void asetaMerkki(int sarake, int rivi)</strong> asettaa pelaajan vuoron mukaisen merkin annettuun ruutuun sarakkeen (0-2) ja rivin (0-2) perusteella ja antaa vuoron toiselle pelaajalle. Metodi heittÃ¤Ã¤ poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella tai ruudussa on jo merkki, ja poikkeuksen <code>IllegalStateException</code>, jos peli on jo loppu.</li>
    <li><strong>char getMerkki(int sarake, int rivi)</strong> palauttaa sarakkeen ja rivin mÃ¤Ã¤rittelemÃ¤n ruudun tilan, joka voi olla <code>TYHJA</code>, <code>RISTI</code> tai <code>NOLLA</code>. Metodi heittÃ¤Ã¤ poikkeuksen <code>IllegalArgumentException</code>, jos sarake tai rivi on pelilaudan ulkopuolella.</li>
    <li><strong>boolean isPeliLoppu()</strong> palauttaa arvon <code>true</code>, jos toinen pelaajista voitti pelin tai peli pÃ¤Ã¤ttyi tasapeliin, muutoin metodi palauttaa <code>false</code></li>
    <li><strong>char getVoittaja()</strong> palauttaa arvon <code>TYHJA</code>, jos peli on kesken tai peli pÃ¤Ã¤ttyi tasapeliin, muutoin metodi palauttaa voittajan merkin: <code>RISTI</code> tai <code>NOLLA</code></ul>

<p>EnsimmÃ¤inen pelivuoro on aina merkillÃ¤ <code>RISTI</code>. Pelin voittaa se pelaaja, joka saa ensimmÃ¤isenÃ¤ kolme merkkiÃ¤ vaakasuoraan, pystysuoraan tai vinottain. Tasapeli todetaan vasta, kun pelilauta on tÃ¤ynnÃ¤ merkkejÃ¤ eli tyhjiÃ¤ ruutuja ei enÃ¤Ã¤ ole.</p>

<p><b>Vinkki:</b> Pelilaudan tilanteen voi esittÃ¤Ã¤ esimerkiksi yhdeksÃ¤n alkion <code>char</code>-taulukolla, jonne talletetaan peliruutujen tilat. Sarakkeen ja rivin perusteella voidaan laskea taulukon indeksi: <code>rivi * 3 + sarake</code>.</p>

</div>



<!-- END SNIP -->

<!-- FLOATING MENU -->
<div id="fl_menu">
  <div class="label">Materiaali</div>
  <div class="menu" id="fl_menu_items">
  </div>
</div>



<script>
//config
$float_speed=0; //milliseconds
$float_easing="easeOutQuint";
$menu_fade_speed=0; //milliseconds
$closed_menu_opacity=0.5;

//cache vars
$fl_menu=$("#fl_menu");
$fl_menu_menu=$("#fl_menu .menu");
$fl_menu_label=$("#fl_menu .label");

$(window).load(function() {
    menuPosition=$('#fl_menu').position().top;
    FloatMenu();
    $fl_menu.hover(
        function(){ //mouse over
            $fl_menu_label.fadeTo($menu_fade_speed, 1);
            $fl_menu_menu.fadeIn($menu_fade_speed);
        },
        function(){ //mouse out
            $fl_menu_label.fadeTo($menu_fade_speed, $closed_menu_opacity);
            $fl_menu_menu.fadeOut($menu_fade_speed);
        }
    );
});

$(window).scroll(function () {
    FloatMenu();
});

function FloatMenu(){
    var scrollAmount=$(document).scrollTop();
    var newPosition=menuPosition+scrollAmount;
    if($(window).height()<$fl_menu.height()+$fl_menu_menu.height()){
        $fl_menu.css("top",menuPosition);
    } else {
        $fl_menu.stop().animate({top: newPosition}, $float_speed, $float_easing);
    }
}
</script>



</body>

</html>


